// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 验证码枚举
/// 说明：手机号码登录获取验证码不用传类型
public enum OSCodeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case type0 // = 0

  /// 实名认证验证手机号码、手机绑定验证原手机号码、新手机号码绑定
  case type1 // = 1

  /// 忘记密码时验证手机号
  case type2 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .type0
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .type0
    case 1: self = .type1
    case 2: self = .type2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .type0: return 0
    case .type1: return 1
    case .type2: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSCodeType] = [
    .type0,
    .type1,
    .type2,
  ]

}

/// 性别枚举
public enum OSGender: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 未知性别
  case unknown // = 0

  /// 男性
  case male // = 1

  /// 女性
  case female // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .male
    case 2: self = .female
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .male: return 1
    case .female: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSGender] = [
    .unknown,
    .male,
    .female,
  ]

}

/// 礼物栏标签枚举
public enum OSGiftTag: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// 礼物
  case gift // = 1

  /// 背包
  case backpack // = 2

  /// 福袋
  case luckybag // = 3

  /// 特权卡
  case privilegecard // = 4

  /// 星座礼物
  case starsign // = 5

  /// 粉丝团礼物
  case fansclub // = 6

  /// 互动礼物
  case metaGift // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .gift
    case 2: self = .backpack
    case 3: self = .luckybag
    case 4: self = .privilegecard
    case 5: self = .starsign
    case 6: self = .fansclub
    case 9: self = .metaGift
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .gift: return 1
    case .backpack: return 2
    case .luckybag: return 3
    case .privilegecard: return 4
    case .starsign: return 5
    case .fansclub: return 6
    case .metaGift: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSGiftTag] = [
    .unknown,
    .gift,
    .backpack,
    .luckybag,
    .privilegecard,
    .starsign,
    .fansclub,
    .metaGift,
  ]

}

/// 房间模式
public enum OSChannelType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unkown // = 0

  /// 娱乐模式 YU_LE
  case yuLe // = 1

  /// 开黑模式 KAI_HEI
  case kaiHei // = 2

  /// 小游戏模式 MINI_GAME
  case miniGame // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unkown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unkown
    case 1: self = .yuLe
    case 2: self = .kaiHei
    case 3: self = .miniGame
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unkown: return 0
    case .yuLe: return 1
    case .kaiHei: return 2
    case .miniGame: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSChannelType] = [
    .unkown,
    .yuLe,
    .kaiHei,
    .miniGame,
  ]

}

/// 权限
public enum OSPowerType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// 房主
  case owner // = 1

  /// 超级管理员
  case superAdmin // = 2

  /// 管理员
  case admin // = 3

  /// 普通用户
  case normal // = 4

  /// 公会会长
  case familyOwner // = 5

  /// 黑名单用户
  case blacklist // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .owner
    case 2: self = .superAdmin
    case 3: self = .admin
    case 4: self = .normal
    case 5: self = .familyOwner
    case 6: self = .blacklist
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .owner: return 1
    case .superAdmin: return 2
    case .admin: return 3
    case .normal: return 4
    case .familyOwner: return 5
    case .blacklist: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSPowerType] = [
    .unknown,
    .owner,
    .superAdmin,
    .admin,
    .normal,
    .familyOwner,
    .blacklist,
  ]

}

/// 关注状态
public enum OSFollowStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 未关注
  case unfollow // = 0

  /// 已关注
  case follow // = 1

  /// 互相关注
  case bothfollow // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unfollow
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unfollow
    case 1: self = .follow
    case 2: self = .bothfollow
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unfollow: return 0
    case .follow: return 1
    case .bothfollow: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSFollowStatus] = [
    .unfollow,
    .follow,
    .bothfollow,
  ]

}

/// 房间内排行榜类型
public enum OSChannelRankType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 在线榜
  case online // = 0

  /// 财富周榜
  case guardWeek // = 1

  /// 财富总榜
  case guardTotal // = 2

  /// 魅力总榜
  case charmTotal // = 3

  /// 财富日榜
  case guardDay // = 4

  /// 魅力日榜
  case charmDay // = 5

  /// 魅力周榜
  case charmWeek // = 6

  /// 财富月榜(守护)
  case guardMonth // = 7

  /// 魅力月榜
  case charmMonth // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .online
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .online
    case 1: self = .guardWeek
    case 2: self = .guardTotal
    case 3: self = .charmTotal
    case 4: self = .guardDay
    case 5: self = .charmDay
    case 6: self = .charmWeek
    case 7: self = .guardMonth
    case 8: self = .charmMonth
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .online: return 0
    case .guardWeek: return 1
    case .guardTotal: return 2
    case .charmTotal: return 3
    case .guardDay: return 4
    case .charmDay: return 5
    case .charmWeek: return 6
    case .guardMonth: return 7
    case .charmMonth: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSChannelRankType] = [
    .online,
    .guardWeek,
    .guardTotal,
    .charmTotal,
    .guardDay,
    .charmDay,
    .charmWeek,
    .guardMonth,
    .charmMonth,
  ]

}

/// 装扮栏类型
public enum OSDressUpTagType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 坐骑
  case mount // = 0

  /// 麦位框
  case headShow // = 1

  /// 气泡框
  case bubble // = 2

  /// 主页飘
  case homeDecoration // = 3

  /// 尾灯
  case tailLight // = 4

  /// 账号标签
  case userLabel // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .mount
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .mount
    case 1: self = .headShow
    case 2: self = .bubble
    case 3: self = .homeDecoration
    case 4: self = .tailLight
    case 5: self = .userLabel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .mount: return 0
    case .headShow: return 1
    case .bubble: return 2
    case .homeDecoration: return 3
    case .tailLight: return 4
    case .userLabel: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSDressUpTagType] = [
    .mount,
    .headShow,
    .bubble,
    .homeDecoration,
    .tailLight,
    .userLabel,
  ]

}

/// 系统消息类型 1文本消息 2图文消息 3公会消息
public enum OSSystemMessageType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// 文本消息
  case textMessage // = 1

  /// 图文消息
  case imageTextMessage // = 2

  /// 公会消息
  case familyMessage // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .textMessage
    case 2: self = .imageTextMessage
    case 3: self = .familyMessage
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .textMessage: return 1
    case .imageTextMessage: return 2
    case .familyMessage: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSSystemMessageType] = [
    .unknown,
    .textMessage,
    .imageTextMessage,
    .familyMessage,
  ]

}

/// 家族消息类型
public enum OSFamilyMessageType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// 家族公共消息
  case familyCommon // = 1

  /// 家族申请
  case familyApply // = 2

  /// 加入家族
  case familyJoin // = 3

  /// 退出家族
  case familyExit // = 4

  /// 移除成员
  case familyRemove // = 5

  /// 解散家族
  case familyDisband // = 6

  /// 家族邀请签约
  case familyInviteSign // = 7

  /// 主播申请签约
  case familyApplySign // = 8

  /// 家族邀请续约
  case familyInviteRenew // = 9

  /// 主播申请续约
  case familyApplyRenew // = 10

  /// 家族发起解约
  case familyUnBind // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .familyCommon
    case 2: self = .familyApply
    case 3: self = .familyJoin
    case 4: self = .familyExit
    case 5: self = .familyRemove
    case 6: self = .familyDisband
    case 7: self = .familyInviteSign
    case 8: self = .familyApplySign
    case 9: self = .familyInviteRenew
    case 10: self = .familyApplyRenew
    case 11: self = .familyUnBind
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .familyCommon: return 1
    case .familyApply: return 2
    case .familyJoin: return 3
    case .familyExit: return 4
    case .familyRemove: return 5
    case .familyDisband: return 6
    case .familyInviteSign: return 7
    case .familyApplySign: return 8
    case .familyInviteRenew: return 9
    case .familyApplyRenew: return 10
    case .familyUnBind: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSFamilyMessageType] = [
    .unknown,
    .familyCommon,
    .familyApply,
    .familyJoin,
    .familyExit,
    .familyRemove,
    .familyDisband,
    .familyInviteSign,
    .familyApplySign,
    .familyInviteRenew,
    .familyApplyRenew,
    .familyUnBind,
  ]

}

/// 装扮穿戴状态
public enum OSDressUpStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 未穿戴
  case unWear // = 0

  /// 已穿戴
  case weat // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unWear
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unWear
    case 1: self = .weat
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unWear: return 0
    case .weat: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSDressUpStatus] = [
    .unWear,
    .weat,
  ]

}

/// 消息跳转类型
public enum OSMsgLinkType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 跳房间
  case linkChannel // = 0

  /// 跳网页
  case linkWeb // = 1

  /// 跳APP首页
  case linkAppIndex // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .linkChannel
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .linkChannel
    case 1: self = .linkWeb
    case 2: self = .linkAppIndex
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .linkChannel: return 0
    case .linkWeb: return 1
    case .linkAppIndex: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSMsgLinkType] = [
    .linkChannel,
    .linkWeb,
    .linkAppIndex,
  ]

}

/// 大厅排行榜类型
public enum OSLobbyRankType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 魅力榜
  case charmRank // = 0

  /// 财富榜
  case wealthRank // = 1

  /// 房间榜
  case channelRank // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .charmRank
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .charmRank
    case 1: self = .wealthRank
    case 2: self = .channelRank
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .charmRank: return 0
    case .wealthRank: return 1
    case .channelRank: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSLobbyRankType] = [
    .charmRank,
    .wealthRank,
    .channelRank,
  ]

}

/// 大厅排行榜时间范围类型
public enum OSLobbyRankDateRange: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 日榜
  case dayRange // = 0

  /// 周榜
  case weekRange // = 1

  /// 月榜
  case monthRange // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .dayRange
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dayRange
    case 1: self = .weekRange
    case 2: self = .monthRange
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .dayRange: return 0
    case .weekRange: return 1
    case .monthRange: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSLobbyRankDateRange] = [
    .dayRange,
    .weekRange,
    .monthRange,
  ]

}

/// PK类型
public enum OSPkType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 1v1
  case oneToOne // = 0

  /// 团战PK4v4
  case manyToMany // = 1

  /// 跨厅PK
  case channelToChannel // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .oneToOne
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .oneToOne
    case 1: self = .manyToMany
    case 2: self = .channelToChannel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .oneToOne: return 0
    case .manyToMany: return 1
    case .channelToChannel: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSPkType] = [
    .oneToOne,
    .manyToMany,
    .channelToChannel,
  ]

}

/// PK队伍
public enum OSPkTeam: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case teamUnknown // = 0

  /// 蓝方
  case blue // = 1

  /// 红方
  case red // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .teamUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .teamUnknown
    case 1: self = .blue
    case 2: self = .red
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .teamUnknown: return 0
    case .blue: return 1
    case .red: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSPkTeam] = [
    .teamUnknown,
    .blue,
    .red,
  ]

}

public enum OSPointReportType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case point0 // = 0

  /// 动态视频预览
  case point1 // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .point0
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .point0
    case 1: self = .point1
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .point0: return 0
    case .point1: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSPointReportType] = [
    .point0,
    .point1,
  ]

}

public enum OSCharacterType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case notset // = 0
  case boy // = 1
  case girl // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .notset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notset
    case 1: self = .boy
    case 2: self = .girl
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notset: return 0
    case .boy: return 1
    case .girl: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSCharacterType] = [
    .notset,
    .boy,
    .girl,
  ]

}

/// 装备类型，与EquipmentComponent的序号对应
public enum OSEquipmentType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case notset // = 0
  case body // = 2
  case head // = 3
  case eyes // = 4
  case hair // = 5

  /// 眉毛
  case brow // = 6

  /// 鼻型
  case nose // = 7

  /// 嘴型
  case mouth // = 8

  /// 脸型
  case face // = 9

  /// 腮红
  case blush // = 10

  /// 瞳孔
  case pupil // = 11

  /// 睫毛
  case eyelash // = 12

  /// 眼妆
  case eyeshadow // = 13

  /// 眉色
  case browColor // = 14

  /// 口红
  case lipstick // = 15

  /// 胡子
  case beard // = 16
  case top // = 30
  case bottom // = 31
  case shoes // = 32
  case coat // = 33
  case hat // = 34
  case dress // = 50
  case dollDress // = 51
  case bag // = 100
  case necklace // = 101
  case bracelet // = 102
  case earring // = 103
  case UNRECOGNIZED(Int)

  public init() {
    self = .notset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notset
    case 2: self = .body
    case 3: self = .head
    case 4: self = .eyes
    case 5: self = .hair
    case 6: self = .brow
    case 7: self = .nose
    case 8: self = .mouth
    case 9: self = .face
    case 10: self = .blush
    case 11: self = .pupil
    case 12: self = .eyelash
    case 13: self = .eyeshadow
    case 14: self = .browColor
    case 15: self = .lipstick
    case 16: self = .beard
    case 30: self = .top
    case 31: self = .bottom
    case 32: self = .shoes
    case 33: self = .coat
    case 34: self = .hat
    case 50: self = .dress
    case 51: self = .dollDress
    case 100: self = .bag
    case 101: self = .necklace
    case 102: self = .bracelet
    case 103: self = .earring
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notset: return 0
    case .body: return 2
    case .head: return 3
    case .eyes: return 4
    case .hair: return 5
    case .brow: return 6
    case .nose: return 7
    case .mouth: return 8
    case .face: return 9
    case .blush: return 10
    case .pupil: return 11
    case .eyelash: return 12
    case .eyeshadow: return 13
    case .browColor: return 14
    case .lipstick: return 15
    case .beard: return 16
    case .top: return 30
    case .bottom: return 31
    case .shoes: return 32
    case .coat: return 33
    case .hat: return 34
    case .dress: return 50
    case .dollDress: return 51
    case .bag: return 100
    case .necklace: return 101
    case .bracelet: return 102
    case .earring: return 103
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSEquipmentType] = [
    .notset,
    .body,
    .head,
    .eyes,
    .hair,
    .brow,
    .nose,
    .mouth,
    .face,
    .blush,
    .pupil,
    .eyelash,
    .eyeshadow,
    .browColor,
    .lipstick,
    .beard,
    .top,
    .bottom,
    .shoes,
    .coat,
    .hat,
    .dress,
    .dollDress,
    .bag,
    .necklace,
    .bracelet,
    .earring,
  ]

}

/// 设备信息
public struct OSDevice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0:Android;1:iOS;2:小程序;3:PC;4:Web
  public var os: Int32 = 0

  /// 手机系统版本
  public var osVersion: String = String()

  /// 手机型号
  public var model: String = String()

  /// app版本号,如1.0.0
  public var appVersion: String = String()

  /// 安卓id,,IOS不用传
  public var android: String = String()

  /// 设备id
  public var deviceID: String = String()

  public var oaid: String = String()

  public var imei: String = String()

  /// app包id,IOS不用传
  public var appID: Int32 = 0

  /// openid,IOS固定传“520”
  public var openid: String = String()

  /// 来源渠道id,IOS不用传
  public var channelID: Int32 = 0

  /// 来源子渠道id,IOS不用传
  public var subChannelID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 空结构，方便拓展
public struct OSNone: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 表查找请求
public struct OSTableReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 如果非0，加载在此ID之后的项。如果 beforeId 和 afterId 都为0，则从头加载。
  public var afterID: Int64 = 0

  /// 加载的数量
  public var count: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 表查找返回
public struct OSTableRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 有没有更多
  public var hasMore_p: Bool = false

  /// 总数，可选
  public var totalCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 分页请求
public struct OSPageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 第几页
  public var current: Int32 = 0

  /// 页大小
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 分页响应
public struct OSPageRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 第几页
  public var pageIndex: Int32 = 0

  /// 页大小
  public var pageSize: Int32 = 0

  /// 页总数，可选
  public var pageCount: Int32 = 0

  /// 总数量，可选
  public var itemCount: Int32 = 0

  /// 有没有更多
  public var hasMore_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间信息
public struct OSChannelVo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间号,展示用
  public var channelNo: Int32 {
    get {return _storage._channelNo}
    set {_uniqueStorage()._channelNo = newValue}
  }

  /// 房间系统id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 名称
  public var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  /// 头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 房间类型
  public var channelType: OSChannelType {
    get {return _storage._channelType}
    set {_uniqueStorage()._channelType = newValue}
  }

  /// 房主id
  public var ownerID: String {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  /// 状态
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// 在线人数
  public var onlineNumber: Int32 {
    get {return _storage._onlineNumber}
    set {_uniqueStorage()._onlineNumber = newValue}
  }

  /// 假人人数
  public var falseOnlineNumber: Int32 {
    get {return _storage._falseOnlineNumber}
    set {_uniqueStorage()._falseOnlineNumber = newValue}
  }

  /// 上锁状态,0:未上锁 1:上锁
  public var lockedStatus: Int32 {
    get {return _storage._lockedStatus}
    set {_uniqueStorage()._lockedStatus = newValue}
  }

  /// 欢迎语
  public var welcomingSpeech: String {
    get {return _storage._welcomingSpeech}
    set {_uniqueStorage()._welcomingSpeech = newValue}
  }

  /// 公屏开启状态,0:未开启 1:开启
  public var publicScreenStatus: Int32 {
    get {return _storage._publicScreenStatus}
    set {_uniqueStorage()._publicScreenStatus = newValue}
  }

  /// 房主账号id,展示用
  public var ownerAccountid: Int32 {
    get {return _storage._ownerAccountid}
    set {_uniqueStorage()._ownerAccountid = newValue}
  }

  /// 标签集合
  public var labels: String {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// 房主昵称
  public var ownerNickname: String {
    get {return _storage._ownerNickname}
    set {_uniqueStorage()._ownerNickname = newValue}
  }

  /// 背景图
  public var coverURL: String {
    get {return _storage._coverURL}
    set {_uniqueStorage()._coverURL = newValue}
  }

  /// 展示数
  public var displayNumber: Int32 {
    get {return _storage._displayNumber}
    set {_uniqueStorage()._displayNumber = newValue}
  }

  /// 标签名
  public var labelName: String {
    get {return _storage._labelName}
    set {_uniqueStorage()._labelName = newValue}
  }

  /// 房主位锁状态(锁)（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat0Status: Int32 {
    get {return _storage._seat0Status}
    set {_uniqueStorage()._seat0Status = newValue}
  }

  /// 1号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat1Status: Int32 {
    get {return _storage._seat1Status}
    set {_uniqueStorage()._seat1Status = newValue}
  }

  /// 2号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat2Status: Int32 {
    get {return _storage._seat2Status}
    set {_uniqueStorage()._seat2Status = newValue}
  }

  /// 3号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat3Status: Int32 {
    get {return _storage._seat3Status}
    set {_uniqueStorage()._seat3Status = newValue}
  }

  /// 4号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat4Status: Int32 {
    get {return _storage._seat4Status}
    set {_uniqueStorage()._seat4Status = newValue}
  }

  /// 5号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat5Status: Int32 {
    get {return _storage._seat5Status}
    set {_uniqueStorage()._seat5Status = newValue}
  }

  /// 6号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat6Status: Int32 {
    get {return _storage._seat6Status}
    set {_uniqueStorage()._seat6Status = newValue}
  }

  /// 7号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat7Status: Int32 {
    get {return _storage._seat7Status}
    set {_uniqueStorage()._seat7Status = newValue}
  }

  /// 8号麦位锁状态（0锁麦并开麦 1解锁麦并开麦 2解锁麦并闭麦 3锁麦并闭麦）
  public var seat8Status: Int32 {
    get {return _storage._seat8Status}
    set {_uniqueStorage()._seat8Status = newValue}
  }

  /// 创建时间
  public var createTime: String {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// 更新时间
  public var updateTime: String {
    get {return _storage._updateTime}
    set {_uniqueStorage()._updateTime = newValue}
  }

  /// 房间密码
  public var channelPwd: String {
    get {return _storage._channelPwd}
    set {_uniqueStorage()._channelPwd = newValue}
  }

  /// 菜单唯一值
  public var uniCode: String {
    get {return _storage._uniCode}
    set {_uniqueStorage()._uniCode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 用户个人信息
public struct OSUserVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 生日
  public var birthday: String = String()

  /// 个性签名
  public var signature: String = String()

  /// 关注数量
  public var following: Int32 = 0

  /// 粉丝数量
  public var followers: Int32 = 0

  /// 封面图片
  public var coverURL: String = String()

  /// 房间权限 OWNER:房主 SUPER_ADMIN:超级管理员 ADMIN:管理员 NORMAL:普通用户 FAMILY_OWNER:公会会长 BLACKLIST:黑名单用户
  public var powerType: OSPowerType = .unknown

  /// 创建时间
  public var visitTime: String = String()

  /// 声音介绍-语音
  public var showVoice: String = String()

  /// 声音介绍-语音时长(毫秒)
  public var showDuration: Int32 = 0

  /// 声音介绍-状态(0:未设置, 1:已通过, 2:审核中)
  public var showStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户在房间内信息
public struct OSUserInChannel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 用户系统id
  public var userID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 麦位
  public var seat: Int32 = 0

  /// 是否允许发言(用户是否能说话)
  public var allowToSpeak: Int32 = 0

  /// 是否允许打字(用户是否能公屏打字)
  public var allowToType: Int32 = 0

  /// 权限 OWNER:房主 SUPER_ADMIN:超级管理员 ADMIN:管理员 NORMAL:普通用户 FAMILY_OWNER:公会会长 BLACKLIST:黑名单用户
  public var powerType: OSPowerType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户设置信息
public struct OSUserSetting: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户id
  public var userID: String = String()

  /// 是否实名认证 0:未实名 1:已实名
  public var hasCertification_p: Int32 = 0

  /// 实名年龄
  public var certificationAge: Int32 = 0

  /// 是否开启青少年模式 0:否 1:是
  public var hasAdolescent_p: Int32 = 0

  /// 密码,由md5加密,只有登录接口会返回
  public var password: String = String()

  /// 展示身份证姓名
  public var displayName: String = String()

  /// 展示身份证号
  public var displayNumber: String = String()

  ///未实名是否有创建房间权限，0=无，1=有
  public var createChannelAuth: Int32 = 0

  ///未实名是否有上麦权限，0=无，1=有
  public var upSeatAuth: Int32 = 0

  ///未实名是否有发公屏权限，0=无，1=有
  public var publicChatAuth: Int32 = 0

  ///未实名是否有发布动态权限，0=无，1=有
  public var momentAuth: Int32 = 0

  ///未实名是否有评论动态权限，0=无，1=有
  public var commentAuth: Int32 = 0

  ///未实名是否有创建家族权限，0=无，1=有
  public var createFamilyAuth: Int32 = 0

  /// 是否人脸识别（0否1是）
  public var faceVerification: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户勋章列表
public struct OSMedalList: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 勋章id
  public var medalID: Int32 {
    get {return _storage._medalID}
    set {_uniqueStorage()._medalID = newValue}
  }

  /// 勋章名称,如财富值、魅力值
  public var medalName: String {
    get {return _storage._medalName}
    set {_uniqueStorage()._medalName = newValue}
  }

  /// 勋章标题,如英勇游侠
  public var medalLevelTitle: String {
    get {return _storage._medalLevelTitle}
    set {_uniqueStorage()._medalLevelTitle = newValue}
  }

  /// 勋章标识,如TREASURE_0_0
  public var medalIndex: String {
    get {return _storage._medalIndex}
    set {_uniqueStorage()._medalIndex = newValue}
  }

  /// 勋章等级图标(包含等级)
  public var medalLevelIcon: String {
    get {return _storage._medalLevelIcon}
    set {_uniqueStorage()._medalLevelIcon = newValue}
  }

  /// 勋章等级图标(右下角不带等级)
  public var medalLevelIcon2: String {
    get {return _storage._medalLevelIcon2}
    set {_uniqueStorage()._medalLevelIcon2 = newValue}
  }

  /// 勋章总等级
  public var totalLevel: Int32 {
    get {return _storage._totalLevel}
    set {_uniqueStorage()._totalLevel = newValue}
  }

  /// 勋章右下角rgb颜色值
  public var cornerColor: String {
    get {return _storage._cornerColor}
    set {_uniqueStorage()._cornerColor = newValue}
  }

  /// 开始经验值
  public var startLevelValue: Int32 {
    get {return _storage._startLevelValue}
    set {_uniqueStorage()._startLevelValue = newValue}
  }

  /// 当前经验值
  public var empiricalValue: Int32 {
    get {return _storage._empiricalValue}
    set {_uniqueStorage()._empiricalValue = newValue}
  }

  /// 下一等级信息
  public var nextUserMedalLevelVo: OSMedalList {
    get {return _storage._nextUserMedalLevelVo ?? OSMedalList()}
    set {_uniqueStorage()._nextUserMedalLevelVo = newValue}
  }
  /// Returns true if `nextUserMedalLevelVo` has been explicitly set.
  public var hasNextUserMedalLevelVo: Bool {return _storage._nextUserMedalLevelVo != nil}
  /// Clears the value of `nextUserMedalLevelVo`. Subsequent reads from it will return its default value.
  public mutating func clearNextUserMedalLevelVo() {_uniqueStorage()._nextUserMedalLevelVo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 装扮信息
public struct OSDressUpInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 头像框名称
  public var dressName: String = String()

  /// 头像框静态图片地址
  public var dressIcon: String = String()

  /// 头像框动态图片地址
  public var dressIconSvga: String = String()

  /// 资料卡装饰
  public var cardDecoration: [String] = []

  /// 主页装饰动画
  public var homeDecoration: [String] = []

  /// 尾灯
  public var taillightURL: String = String()

  /// 账号标签信息
  public var accountLabel: [OSAccountLabel] = []

  /// 靓号标识,0：没有靓号, 1：存在靓号
  public var prettyAccount: Int32 = 0

  /// 挂件列表信息
  public var pendantList: [OSPendantInfo2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 贵宾卡信息
public struct OSHonouredGuestCard: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 贵宾卡Id
  public var cardID: Int64 {
    get {return _storage._cardID}
    set {_uniqueStorage()._cardID = newValue}
  }

  /// 贵宾卡等级Id
  public var levelID: Int64 {
    get {return _storage._levelID}
    set {_uniqueStorage()._levelID = newValue}
  }

  /// 贵宾卡名称
  public var cardName: String {
    get {return _storage._cardName}
    set {_uniqueStorage()._cardName = newValue}
  }

  /// 贵宾卡标志
  public var cardIcon: String {
    get {return _storage._cardIcon}
    set {_uniqueStorage()._cardIcon = newValue}
  }

  /// 数量
  public var cardCount: Int32 {
    get {return _storage._cardCount}
    set {_uniqueStorage()._cardCount = newValue}
  }

  /// 贵宾卡背景样式
  public var backdropURL: String {
    get {return _storage._backdropURL}
    set {_uniqueStorage()._backdropURL = newValue}
  }

  /// 公屏提示样式
  public var promptURL: String {
    get {return _storage._promptURL}
    set {_uniqueStorage()._promptURL = newValue}
  }

  /// 字体颜色
  public var fontColor: String {
    get {return _storage._fontColor}
    set {_uniqueStorage()._fontColor = newValue}
  }

  /// 贵宾卡图标
  public var honouredGestURL: String {
    get {return _storage._honouredGestURL}
    set {_uniqueStorage()._honouredGestURL = newValue}
  }

  /// 房间号
  public var channelNo: Int32 {
    get {return _storage._channelNo}
    set {_uniqueStorage()._channelNo = newValue}
  }

  /// 房间名称
  public var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  /// 房间封面
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 房间id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 财富值
  public var wealthValue: Int64 {
    get {return _storage._wealthValue}
    set {_uniqueStorage()._wealthValue = newValue}
  }

  /// 保级值
  public var protectionValue: Int64 {
    get {return _storage._protectionValue}
    set {_uniqueStorage()._protectionValue = newValue}
  }

  /// 贵宾卡等级更新时间戳
  public var levelUpdateTime: Int64 {
    get {return _storage._levelUpdateTime}
    set {_uniqueStorage()._levelUpdateTime = newValue}
  }

  /// 当前系统时间戳
  public var systemTime: Int64 {
    get {return _storage._systemTime}
    set {_uniqueStorage()._systemTime = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 幻灵信息
public struct OSEidolonInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 我的幻灵id
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 账号标签信息
public struct OSAccountLabel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 标签名称
  public var labelName: String = String()

  /// 标签图片地址
  public var labelURL: String = String()

  /// // 标签图片地址
  public var labelURL2: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 挂件信息
public struct OSPendantInfo2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  /// 装扮名称
  public var dressName: String = String()

  /// 装扮图标
  public var dressIcon: String = String()

  /// 装扮特效
  public var effectURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 麦位用户信息
public struct OSUserInSeats: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 用户系统id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// 账号id
  public var accountID: Int32 {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  /// 昵称
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  /// 头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 性别 1男2女
  public var gender: OSGender {
    get {return _storage._gender}
    set {_uniqueStorage()._gender = newValue}
  }

  /// 麦位号 0-8
  public var seat: Int32 {
    get {return _storage._seat}
    set {_uniqueStorage()._seat = newValue}
  }

  /// 心动值
  public var lovenum: Int32 {
    get {return _storage._lovenum}
    set {_uniqueStorage()._lovenum = newValue}
  }

  /// 允许发言(用户是否能说话)
  public var allowToSpeak: Int32 {
    get {return _storage._allowToSpeak}
    set {_uniqueStorage()._allowToSpeak = newValue}
  }

  /// 允许打字(用户是否能公屏打字)
  public var allowToType: Int32 {
    get {return _storage._allowToType}
    set {_uniqueStorage()._allowToType = newValue}
  }

  /// 角色
  public var powerType: OSPowerType {
    get {return _storage._powerType}
    set {_uniqueStorage()._powerType = newValue}
  }

  /// 房间外部管理角色权限（0.没权限 1.签约厅家族长 2.普通家族长）
  public var channelPowerType: Int32 {
    get {return _storage._channelPowerType}
    set {_uniqueStorage()._channelPowerType = newValue}
  }

  /// 是否机器人
  public var robot: Int32 {
    get {return _storage._robot}
    set {_uniqueStorage()._robot = newValue}
  }

  /// 状态 0不在房间 1在房间内 2隐身进房
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// 装扮信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  /// 贵宾卡信息
  public var honouredGuestCard: OSHonouredGuestCard {
    get {return _storage._honouredGuestCard ?? OSHonouredGuestCard()}
    set {_uniqueStorage()._honouredGuestCard = newValue}
  }
  /// Returns true if `honouredGuestCard` has been explicitly set.
  public var hasHonouredGuestCard: Bool {return _storage._honouredGuestCard != nil}
  /// Clears the value of `honouredGuestCard`. Subsequent reads from it will return its default value.
  public mutating func clearHonouredGuestCard() {_uniqueStorage()._honouredGuestCard = nil}

  ///3D任务形象
  public var equipment: OSEquipmentComponent {
    get {return _storage._equipment ?? OSEquipmentComponent()}
    set {_uniqueStorage()._equipment = newValue}
  }
  /// Returns true if `equipment` has been explicitly set.
  public var hasEquipment: Bool {return _storage._equipment != nil}
  /// Clears the value of `equipment`. Subsequent reads from it will return its default value.
  public mutating func clearEquipment() {_uniqueStorage()._equipment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 互动消息
public struct OSInteractionVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// 互动类型(1.动态评论 2.评论回复 3.动态点赞 4.评论点赞 5.关注)
  public var interactiveType: Int32 = 0

  /// 被互动的目标用户Id
  public var targetUserID: String = String()

  /// 被互动的瞬间（动态）评论Id/回复评论Id/点赞Id/关注Id
  public var interactiveTargetID: Int32 = 0

  /// 辅助记录Id
  public var assistTargetID: Int64 = 0

  /// 互动内容
  public var interactiveContent: String = String()

  /// 用户系统id
  public var userID: String = String()

  /// 操作用户头像
  public var avatarURL: String = String()

  /// 昵称
  public var nickname: String = String()

  /// 是否已读(0.未读 1.已读)
  public var hasRead_p: Int32 = 0

  /// 时间戳
  public var createTimestamp: Int64 = 0

  /// 动态的第一张图
  public var momentFirstPic: String = String()

  ///动态内容
  public var thought: String = String()

  ///动态类型 0图文，1视频，2音频
  public var momentType: Int32 = 0

  ///互动状态（0.失效(删除) 1.有效）
  public var status: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间用户信息
public struct OSChatChannelUserVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 麦位
  public var seat: Int32 = 0

  /// 角色权限
  public var powerType: OSPowerType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝团信息
public struct OSFansClubVo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// 账号id
  public var accountID: Int32 {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  /// 昵称
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  /// 头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 粉丝团Id
  public var clubID: Int64 {
    get {return _storage._clubID}
    set {_uniqueStorage()._clubID = newValue}
  }

  /// 房间Id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 粉丝团人数
  public var count: Int32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// 粉丝团勋章名称
  public var badgeName: String {
    get {return _storage._badgeName}
    set {_uniqueStorage()._badgeName = newValue}
  }

  /// 粉丝团勋章等级icon
  public var badgeIcon: String {
    get {return _storage._badgeIcon}
    set {_uniqueStorage()._badgeIcon = newValue}
  }

  /// 粉丝团勋章等级
  public var badgeLevel: String {
    get {return _storage._badgeLevel}
    set {_uniqueStorage()._badgeLevel = newValue}
  }

  /// 粉丝团状态 0失效 1审核中 2拒绝 3通过 ; (粉丝团用户状态 0无关系 1粉丝成员)
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  ///目标用户Id
  public var targetID: String {
    get {return _storage._targetID}
    set {_uniqueStorage()._targetID = newValue}
  }

  ///粉丝团等级
  public var level: Int32 {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  ///当前等级亲密值
  public var intimacyValue: Int64 {
    get {return _storage._intimacyValue}
    set {_uniqueStorage()._intimacyValue = newValue}
  }

  ///下一等级
  public var nextLevel: Int32 {
    get {return _storage._nextLevel}
    set {_uniqueStorage()._nextLevel = newValue}
  }

  ///下一等级亲密度阀值
  public var nextLevelValue: Int64 {
    get {return _storage._nextLevelValue}
    set {_uniqueStorage()._nextLevelValue = newValue}
  }

  ///当日亲密值
  public var currentValue: Int32 {
    get {return _storage._currentValue}
    set {_uniqueStorage()._currentValue = newValue}
  }

  ///亲密值上限阀值
  public var upperLimitValue: Int32 {
    get {return _storage._upperLimitValue}
    set {_uniqueStorage()._upperLimitValue = newValue}
  }

  /// 最大等级亲密度
  public var maxLevelValue: Int64 {
    get {return _storage._maxLevelValue}
    set {_uniqueStorage()._maxLevelValue = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 粉丝团礼物信息
public struct OSFansClubGiftVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物Id
  public var giftID: Int32 = 0

  /// 礼物名称
  public var name: String = String()

  /// 礼物角标
  public var iconURL: String = String()

  /// 礼物价值
  public var value: String = String()

  /// 礼物动效
  public var effects: String = String()

  /// 角标Icon
  public var cornerIcon: String = String()

  /// 数量
  public var giftNum: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 亲密值信息
public struct OSIntimacyVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///当日亲密值
  public var currentValue: Int32 = 0

  ///亲密值上限阀值
  public var upperLimitValue: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝团信息
public struct OSFansClubTaskVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 任务id
  public var taskID: Int32 = 0

  /// 任务触发位置类型 1点击触发 2进房 3送礼 4分享 5公屏发言 6私聊 7麦位
  public var locationType: Int32 = 0

  /// 任务名称
  public var name: Int32 = 0

  /// 任务图标
  public var iconURL: Int32 = 0

  /// 奖品价值
  public var prizeValue: Int32 = 0

  /// 奖品数量
  public var count: Int32 = 0

  /// 按钮名称
  public var buttonName: Int32 = 0

  /// 礼物名称
  public var giftName: Int32 = 0

  /// 礼物Icon
  public var giftIconURL: Int32 = 0

  /// 任务条件（分钟）
  public var condition2: Int32 = 0

  /// 任务完成状态（0未完成1已完成）
  public var taskStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSWallet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 钻石
  public var diamondCount: Int64 = 0

  /// 水晶
  public var crystalCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///3D人物装扮
public struct OSEquipmentComponent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  /// 身体
  public var bodyID: Int64 = 0

  /// 头
  public var headID: Int64 = 0

  /// 眼睛
  public var eyesID: Int64 = 0

  /// 头发
  public var hairID: Int64 = 0

  /// 以下是衣物
  public var topID: Int64 = 0

  /// 裤子
  public var bottomID: Int64 = 0

  /// 鞋子
  public var shoesID: Int64 = 0

  /// 外套
  public var coatID: Int64 = 0

  /// 帽子
  public var hatID: Int64 = 0

  /// 以下是套装
  public var dressID: Int64 = 0

  /// 套装，全身装，不能与其他衣物或发型同时存在
  public var dollDressID: Int64 = 0

  /// 以下是挂件
  public var bagID: Int64 = 0

  /// 项链
  public var necklaceID: Int64 = 0

  /// 手饰
  public var braceletID: Int64 = 0

  /// 耳饰
  public var earringID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGoodsPrice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 价格
  public var value: Int32 = 0

  /// 时长
  public var duration: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///个播心愿礼物
public struct OSUserWishGiftVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否已达成，0：进行中，1：已完成
  public var finish: Int32 = 0

  /// 最大礼物限制价值
  public var maxLimitValue: Int32 = 0

  /// 心愿进度列表
  public var progressList: [OSWishGiftProgress] = []

  /// 前三用户列表
  public var topUser: [OSWishGifttopUser] = []

  /// 助力人数
  public var userCount: Int32 = 0

  /// 心愿礼物开关
  public var wishSwitch: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSWishGiftProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 角标icon
  public var cornerIcon: String = String()

  /// 角标icon
  public var effects: String = String()

  /// 已完成数
  public var finishCount: Int32 = 0

  /// 礼物数
  public var giftCount: Int32 = 0

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物icon
  public var iconURL: String = String()

  /// 礼物名称
  public var name: String = String()

  /// 礼物价值
  public var value: Int32 = 0

  /// 是否显示限时角标
  public var timedCornerMark: Int32 = 0

  /// 横幅类型
  public var bannerType: Int32 = 0

  /// 横幅内容
  public var bannerContent: String = String()

  /// 是否弹出
  public var showPop: Int32 = 0

  /// 礼物类型 0普通礼物 5粉丝团礼物
  public var giftType: Int32 = 0

  /// 粉丝团-是否入团礼物 (0否1是)
  public var giftFlag: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSWishGifttopUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户头像
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///礼物藏馆vo
public struct OSCollectionHallVo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 配置Id
  public var configID: Int32 {
    get {return _storage._configID}
    set {_uniqueStorage()._configID = newValue}
  }

  /// 名称
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// 等级
  public var level: Int32 {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  /// 数量
  public var count: Int32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// 总数量
  public var totalCount: Int32 {
    get {return _storage._totalCount}
    set {_uniqueStorage()._totalCount = newValue}
  }

  /// 父级Id
  public var parentID: Int64 {
    get {return _storage._parentID}
    set {_uniqueStorage()._parentID = newValue}
  }

  /// 亮图标
  public var brightURL: String {
    get {return _storage._brightURL}
    set {_uniqueStorage()._brightURL = newValue}
  }

  /// 灰图标
  public var greyURL: String {
    get {return _storage._greyURL}
    set {_uniqueStorage()._greyURL = newValue}
  }

  /// 礼物id
  public var giftID: Int32 {
    get {return _storage._giftID}
    set {_uniqueStorage()._giftID = newValue}
  }

  /// 礼物名称
  public var giftName: String {
    get {return _storage._giftName}
    set {_uniqueStorage()._giftName = newValue}
  }

  /// 礼物icon
  public var giftIconURL: String {
    get {return _storage._giftIconURL}
    set {_uniqueStorage()._giftIconURL = newValue}
  }

  /// 心动值
  public var giftLovenum: Int32 {
    get {return _storage._giftLovenum}
    set {_uniqueStorage()._giftLovenum = newValue}
  }

  /// 礼物价值
  public var giftValue: Int32 {
    get {return _storage._giftValue}
    set {_uniqueStorage()._giftValue = newValue}
  }

  /// 礼物动效,可返回空
  public var giftEffects: String {
    get {return _storage._giftEffects}
    set {_uniqueStorage()._giftEffects = newValue}
  }

  /// 礼物类型
  public var giftType: Int32 {
    get {return _storage._giftType}
    set {_uniqueStorage()._giftType = newValue}
  }

  /// 系列ID
  public var seriesID: Int32 {
    get {return _storage._seriesID}
    set {_uniqueStorage()._seriesID = newValue}
  }

  /// 礼物介绍
  public var remark: String {
    get {return _storage._remark}
    set {_uniqueStorage()._remark = newValue}
  }

  /// 等级名称
  public var levelName: String {
    get {return _storage._levelName}
    set {_uniqueStorage()._levelName = newValue}
  }

  /// 等级Icon
  public var levelIcon: String {
    get {return _storage._levelIcon}
    set {_uniqueStorage()._levelIcon = newValue}
  }

  /// 是否限时 0否1是
  public var limited: Int32 {
    get {return _storage._limited}
    set {_uniqueStorage()._limited = newValue}
  }

  /// 限时开始时间戳
  public var effectiveTimeTamp: Int64 {
    get {return _storage._effectiveTimeTamp}
    set {_uniqueStorage()._effectiveTimeTamp = newValue}
  }

  /// 限时结束时间戳
  public var expireTimeTamp: Int64 {
    get {return _storage._expireTimeTamp}
    set {_uniqueStorage()._expireTimeTamp = newValue}
  }

  /// 天数
  public var days: Int32 {
    get {return _storage._days}
    set {_uniqueStorage()._days = newValue}
  }

  /// 奖励标识
  public var prizeIndex: Int32 {
    get {return _storage._prizeIndex}
    set {_uniqueStorage()._prizeIndex = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSCodeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_0"),
    1: .same(proto: "TYPE_1"),
    2: .same(proto: "TYPE_2"),
  ]
}

extension OSGender: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENDER_UNKNOWN"),
    1: .same(proto: "MALE"),
    2: .same(proto: "FEMALE"),
  ]
}

extension OSGiftTag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GIFTTAG_UNKNOWN"),
    1: .same(proto: "GIFT"),
    2: .same(proto: "BACKPACK"),
    3: .same(proto: "LUCKYBAG"),
    4: .same(proto: "PRIVILEGECARD"),
    5: .same(proto: "STARSIGN"),
    6: .same(proto: "FANSCLUB"),
    9: .same(proto: "META_GIFT"),
  ]
}

extension OSChannelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNELTYPE_UNKOWN"),
    1: .same(proto: "YU_LE"),
    2: .same(proto: "KAI_HEI"),
    3: .same(proto: "MINI_GAME"),
  ]
}

extension OSPowerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POWERTYPE_UNKNOWN"),
    1: .same(proto: "OWNER"),
    2: .same(proto: "SUPER_ADMIN"),
    3: .same(proto: "ADMIN"),
    4: .same(proto: "NORMAL"),
    5: .same(proto: "FAMILY_OWNER"),
    6: .same(proto: "BLACKLIST"),
  ]
}

extension OSFollowStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNFOLLOW"),
    1: .same(proto: "FOLLOW"),
    2: .same(proto: "BOTHFOLLOW"),
  ]
}

extension OSChannelRankType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ONLINE"),
    1: .same(proto: "GUARD_WEEK"),
    2: .same(proto: "GUARD_TOTAL"),
    3: .same(proto: "CHARM_TOTAL"),
    4: .same(proto: "GUARD_DAY"),
    5: .same(proto: "CHARM_DAY"),
    6: .same(proto: "CHARM_WEEK"),
    7: .same(proto: "GUARD_MONTH"),
    8: .same(proto: "CHARM_MONTH"),
  ]
}

extension OSDressUpTagType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOUNT"),
    1: .same(proto: "HEAD_SHOW"),
    2: .same(proto: "BUBBLE"),
    3: .same(proto: "HOME_DECORATION"),
    4: .same(proto: "TAIL_LIGHT"),
    5: .same(proto: "USER_LABEL"),
  ]
}

extension OSSystemMessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYSTEM_MESSAGE_TYPE_UNKNOWN"),
    1: .same(proto: "TEXT_MESSAGE"),
    2: .same(proto: "IMAGE_TEXT_MESSAGE"),
    3: .same(proto: "FAMILY_MESSAGE"),
  ]
}

extension OSFamilyMessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAMILY_MESSAGE_TYPE_UNKNOWN"),
    1: .same(proto: "FAMILY_COMMON"),
    2: .same(proto: "FAMILY_APPLY"),
    3: .same(proto: "FAMILY_JOIN"),
    4: .same(proto: "FAMILY_EXIT"),
    5: .same(proto: "FAMILY_REMOVE"),
    6: .same(proto: "FAMILY_DISBAND"),
    7: .same(proto: "FAMILY_INVITE_SIGN"),
    8: .same(proto: "FAMILY_APPLY_SIGN"),
    9: .same(proto: "FAMILY_INVITE_RENEW"),
    10: .same(proto: "FAMILY_APPLY_RENEW"),
    11: .same(proto: "FAMILY_UN_BIND"),
  ]
}

extension OSDressUpStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UN_WEAR"),
    1: .same(proto: "WEAT"),
  ]
}

extension OSMsgLinkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LINK_CHANNEL"),
    1: .same(proto: "LINK_WEB"),
    2: .same(proto: "LINK_APP_INDEX"),
  ]
}

extension OSLobbyRankType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHARM_RANK"),
    1: .same(proto: "WEALTH_RANK"),
    2: .same(proto: "CHANNEL_RANK"),
  ]
}

extension OSLobbyRankDateRange: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAY_RANGE"),
    1: .same(proto: "WEEK_RANGE"),
    2: .same(proto: "MONTH_RANGE"),
  ]
}

extension OSPkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ONE_TO_ONE"),
    1: .same(proto: "MANY_TO_MANY"),
    2: .same(proto: "CHANNEL_TO_CHANNEL"),
  ]
}

extension OSPkTeam: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEAM_UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "RED"),
  ]
}

extension OSPointReportType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POINT_0"),
    1: .same(proto: "POINT_1"),
  ]
}

extension OSCharacterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CharacterType_NOTSET"),
    1: .same(proto: "Boy"),
    2: .same(proto: "Girl"),
  ]
}

extension OSEquipmentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EquipmentType_NOTSET"),
    2: .same(proto: "Body"),
    3: .same(proto: "Head"),
    4: .same(proto: "Eyes"),
    5: .same(proto: "Hair"),
    6: .same(proto: "Brow"),
    7: .same(proto: "Nose"),
    8: .same(proto: "Mouth"),
    9: .same(proto: "Face"),
    10: .same(proto: "Blush"),
    11: .same(proto: "Pupil"),
    12: .same(proto: "Eyelash"),
    13: .same(proto: "Eyeshadow"),
    14: .same(proto: "BrowColor"),
    15: .same(proto: "Lipstick"),
    16: .same(proto: "Beard"),
    30: .same(proto: "Top"),
    31: .same(proto: "Bottom"),
    32: .same(proto: "Shoes"),
    33: .same(proto: "Coat"),
    34: .same(proto: "Hat"),
    50: .same(proto: "Dress"),
    51: .same(proto: "DollDress"),
    100: .same(proto: "Bag"),
    101: .same(proto: "Necklace"),
    102: .same(proto: "Bracelet"),
    103: .same(proto: "Earring"),
  ]
}

extension OSDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "os"),
    2: .standard(proto: "os_version"),
    3: .same(proto: "model"),
    4: .standard(proto: "app_version"),
    5: .same(proto: "android"),
    6: .standard(proto: "device_id"),
    7: .same(proto: "oaid"),
    8: .same(proto: "imei"),
    9: .standard(proto: "app_id"),
    10: .same(proto: "openid"),
    11: .same(proto: "channelId"),
    12: .same(proto: "subChannelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.os) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.model) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.android) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.oaid) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.imei) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.appID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.openid) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.channelID) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.subChannelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.os != 0 {
      try visitor.visitSingularInt32Field(value: self.os, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    if !self.model.isEmpty {
      try visitor.visitSingularStringField(value: self.model, fieldNumber: 3)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 4)
    }
    if !self.android.isEmpty {
      try visitor.visitSingularStringField(value: self.android, fieldNumber: 5)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 6)
    }
    if !self.oaid.isEmpty {
      try visitor.visitSingularStringField(value: self.oaid, fieldNumber: 7)
    }
    if !self.imei.isEmpty {
      try visitor.visitSingularStringField(value: self.imei, fieldNumber: 8)
    }
    if self.appID != 0 {
      try visitor.visitSingularInt32Field(value: self.appID, fieldNumber: 9)
    }
    if !self.openid.isEmpty {
      try visitor.visitSingularStringField(value: self.openid, fieldNumber: 10)
    }
    if self.channelID != 0 {
      try visitor.visitSingularInt32Field(value: self.channelID, fieldNumber: 11)
    }
    if self.subChannelID != 0 {
      try visitor.visitSingularInt32Field(value: self.subChannelID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDevice, rhs: OSDevice) -> Bool {
    if lhs.os != rhs.os {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.model != rhs.model {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.android != rhs.android {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.oaid != rhs.oaid {return false}
    if lhs.imei != rhs.imei {return false}
    if lhs.appID != rhs.appID {return false}
    if lhs.openid != rhs.openid {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.subChannelID != rhs.subChannelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSNone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".None"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSNone, rhs: OSNone) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTableReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "after_id"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.afterID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.afterID != 0 {
      try visitor.visitSingularInt64Field(value: self.afterID, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTableReq, rhs: OSTableReq) -> Bool {
    if lhs.afterID != rhs.afterID {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTableRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_more"),
    2: .standard(proto: "total_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTableRes, rhs: OSTableRes) -> Bool {
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPageReq, rhs: OSPageReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PageRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pageIndex"),
    2: .same(proto: "pageSize"),
    3: .same(proto: "pageCount"),
    4: .same(proto: "itemCount"),
    5: .standard(proto: "has_more"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.itemCount) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.pageIndex, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if self.pageCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pageCount, fieldNumber: 3)
    }
    if self.itemCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemCount, fieldNumber: 4)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPageRes, rhs: OSPageRes) -> Bool {
    if lhs.pageIndex != rhs.pageIndex {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageCount != rhs.pageCount {return false}
    if lhs.itemCount != rhs.itemCount {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelNo"),
    2: .same(proto: "channelId"),
    3: .same(proto: "channelName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "channelType"),
    6: .same(proto: "ownerId"),
    7: .same(proto: "status"),
    8: .same(proto: "onlineNumber"),
    9: .same(proto: "falseOnlineNumber"),
    10: .same(proto: "lockedStatus"),
    11: .same(proto: "welcomingSpeech"),
    12: .same(proto: "publicScreenStatus"),
    13: .same(proto: "ownerAccountid"),
    14: .same(proto: "labels"),
    15: .same(proto: "ownerNickname"),
    16: .same(proto: "coverUrl"),
    17: .same(proto: "displayNumber"),
    18: .same(proto: "labelName"),
    19: .same(proto: "seat0Status"),
    20: .same(proto: "seat1Status"),
    21: .same(proto: "seat2Status"),
    22: .same(proto: "seat3Status"),
    23: .same(proto: "seat4Status"),
    24: .same(proto: "seat5Status"),
    25: .same(proto: "seat6Status"),
    26: .same(proto: "seat7Status"),
    27: .same(proto: "seat8Status"),
    28: .same(proto: "createTime"),
    29: .same(proto: "updateTime"),
    30: .same(proto: "channelPwd"),
    31: .same(proto: "uniCode"),
  ]

  fileprivate class _StorageClass {
    var _channelNo: Int32 = 0
    var _channelID: String = String()
    var _channelName: String = String()
    var _avatarURL: String = String()
    var _channelType: OSChannelType = .unkown
    var _ownerID: String = String()
    var _status: Int32 = 0
    var _onlineNumber: Int32 = 0
    var _falseOnlineNumber: Int32 = 0
    var _lockedStatus: Int32 = 0
    var _welcomingSpeech: String = String()
    var _publicScreenStatus: Int32 = 0
    var _ownerAccountid: Int32 = 0
    var _labels: String = String()
    var _ownerNickname: String = String()
    var _coverURL: String = String()
    var _displayNumber: Int32 = 0
    var _labelName: String = String()
    var _seat0Status: Int32 = 0
    var _seat1Status: Int32 = 0
    var _seat2Status: Int32 = 0
    var _seat3Status: Int32 = 0
    var _seat4Status: Int32 = 0
    var _seat5Status: Int32 = 0
    var _seat6Status: Int32 = 0
    var _seat7Status: Int32 = 0
    var _seat8Status: Int32 = 0
    var _createTime: String = String()
    var _updateTime: String = String()
    var _channelPwd: String = String()
    var _uniCode: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _channelNo = source._channelNo
      _channelID = source._channelID
      _channelName = source._channelName
      _avatarURL = source._avatarURL
      _channelType = source._channelType
      _ownerID = source._ownerID
      _status = source._status
      _onlineNumber = source._onlineNumber
      _falseOnlineNumber = source._falseOnlineNumber
      _lockedStatus = source._lockedStatus
      _welcomingSpeech = source._welcomingSpeech
      _publicScreenStatus = source._publicScreenStatus
      _ownerAccountid = source._ownerAccountid
      _labels = source._labels
      _ownerNickname = source._ownerNickname
      _coverURL = source._coverURL
      _displayNumber = source._displayNumber
      _labelName = source._labelName
      _seat0Status = source._seat0Status
      _seat1Status = source._seat1Status
      _seat2Status = source._seat2Status
      _seat3Status = source._seat3Status
      _seat4Status = source._seat4Status
      _seat5Status = source._seat5Status
      _seat6Status = source._seat6Status
      _seat7Status = source._seat7Status
      _seat8Status = source._seat8Status
      _createTime = source._createTime
      _updateTime = source._updateTime
      _channelPwd = source._channelPwd
      _uniCode = source._uniCode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._channelNo) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._channelName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._channelType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._ownerID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._onlineNumber) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._falseOnlineNumber) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._lockedStatus) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._welcomingSpeech) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._publicScreenStatus) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._ownerAccountid) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._labels) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._ownerNickname) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._coverURL) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._displayNumber) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._labelName) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._seat0Status) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._seat1Status) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._seat2Status) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._seat3Status) }()
        case 23: try { try decoder.decodeSingularInt32Field(value: &_storage._seat4Status) }()
        case 24: try { try decoder.decodeSingularInt32Field(value: &_storage._seat5Status) }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._seat6Status) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._seat7Status) }()
        case 27: try { try decoder.decodeSingularInt32Field(value: &_storage._seat8Status) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._createTime) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._updateTime) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._channelPwd) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._uniCode) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channelNo != 0 {
        try visitor.visitSingularInt32Field(value: _storage._channelNo, fieldNumber: 1)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 2)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if _storage._channelType != .unkown {
        try visitor.visitSingularEnumField(value: _storage._channelType, fieldNumber: 5)
      }
      if !_storage._ownerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerID, fieldNumber: 6)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 7)
      }
      if _storage._onlineNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._onlineNumber, fieldNumber: 8)
      }
      if _storage._falseOnlineNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._falseOnlineNumber, fieldNumber: 9)
      }
      if _storage._lockedStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lockedStatus, fieldNumber: 10)
      }
      if !_storage._welcomingSpeech.isEmpty {
        try visitor.visitSingularStringField(value: _storage._welcomingSpeech, fieldNumber: 11)
      }
      if _storage._publicScreenStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._publicScreenStatus, fieldNumber: 12)
      }
      if _storage._ownerAccountid != 0 {
        try visitor.visitSingularInt32Field(value: _storage._ownerAccountid, fieldNumber: 13)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labels, fieldNumber: 14)
      }
      if !_storage._ownerNickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerNickname, fieldNumber: 15)
      }
      if !_storage._coverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._coverURL, fieldNumber: 16)
      }
      if _storage._displayNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._displayNumber, fieldNumber: 17)
      }
      if !_storage._labelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelName, fieldNumber: 18)
      }
      if _storage._seat0Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat0Status, fieldNumber: 19)
      }
      if _storage._seat1Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat1Status, fieldNumber: 20)
      }
      if _storage._seat2Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat2Status, fieldNumber: 21)
      }
      if _storage._seat3Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat3Status, fieldNumber: 22)
      }
      if _storage._seat4Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat4Status, fieldNumber: 23)
      }
      if _storage._seat5Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat5Status, fieldNumber: 24)
      }
      if _storage._seat6Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat6Status, fieldNumber: 25)
      }
      if _storage._seat7Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat7Status, fieldNumber: 26)
      }
      if _storage._seat8Status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat8Status, fieldNumber: 27)
      }
      if !_storage._createTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTime, fieldNumber: 28)
      }
      if !_storage._updateTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._updateTime, fieldNumber: 29)
      }
      if !_storage._channelPwd.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelPwd, fieldNumber: 30)
      }
      if !_storage._uniCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uniCode, fieldNumber: 31)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelVo, rhs: OSChannelVo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelNo != rhs_storage._channelNo {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._channelName != rhs_storage._channelName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._channelType != rhs_storage._channelType {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._onlineNumber != rhs_storage._onlineNumber {return false}
        if _storage._falseOnlineNumber != rhs_storage._falseOnlineNumber {return false}
        if _storage._lockedStatus != rhs_storage._lockedStatus {return false}
        if _storage._welcomingSpeech != rhs_storage._welcomingSpeech {return false}
        if _storage._publicScreenStatus != rhs_storage._publicScreenStatus {return false}
        if _storage._ownerAccountid != rhs_storage._ownerAccountid {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._ownerNickname != rhs_storage._ownerNickname {return false}
        if _storage._coverURL != rhs_storage._coverURL {return false}
        if _storage._displayNumber != rhs_storage._displayNumber {return false}
        if _storage._labelName != rhs_storage._labelName {return false}
        if _storage._seat0Status != rhs_storage._seat0Status {return false}
        if _storage._seat1Status != rhs_storage._seat1Status {return false}
        if _storage._seat2Status != rhs_storage._seat2Status {return false}
        if _storage._seat3Status != rhs_storage._seat3Status {return false}
        if _storage._seat4Status != rhs_storage._seat4Status {return false}
        if _storage._seat5Status != rhs_storage._seat5Status {return false}
        if _storage._seat6Status != rhs_storage._seat6Status {return false}
        if _storage._seat7Status != rhs_storage._seat7Status {return false}
        if _storage._seat8Status != rhs_storage._seat8Status {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._channelPwd != rhs_storage._channelPwd {return false}
        if _storage._uniCode != rhs_storage._uniCode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "channelId"),
    4: .same(proto: "nickname"),
    5: .same(proto: "avatarUrl"),
    6: .same(proto: "gender"),
    7: .same(proto: "birthday"),
    8: .same(proto: "signature"),
    9: .same(proto: "following"),
    10: .same(proto: "followers"),
    11: .same(proto: "coverUrl"),
    12: .same(proto: "powerType"),
    13: .same(proto: "visitTime"),
    14: .same(proto: "showVoice"),
    15: .same(proto: "showDuration"),
    16: .same(proto: "showStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.birthday) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.following) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.followers) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.coverURL) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.powerType) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.visitTime) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.showVoice) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.showDuration) }()
      case 16: try { try decoder.decodeSingularInt32Field(value: &self.showStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 4)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    if !self.birthday.isEmpty {
      try visitor.visitSingularStringField(value: self.birthday, fieldNumber: 7)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 8)
    }
    if self.following != 0 {
      try visitor.visitSingularInt32Field(value: self.following, fieldNumber: 9)
    }
    if self.followers != 0 {
      try visitor.visitSingularInt32Field(value: self.followers, fieldNumber: 10)
    }
    if !self.coverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coverURL, fieldNumber: 11)
    }
    if self.powerType != .unknown {
      try visitor.visitSingularEnumField(value: self.powerType, fieldNumber: 12)
    }
    if !self.visitTime.isEmpty {
      try visitor.visitSingularStringField(value: self.visitTime, fieldNumber: 13)
    }
    if !self.showVoice.isEmpty {
      try visitor.visitSingularStringField(value: self.showVoice, fieldNumber: 14)
    }
    if self.showDuration != 0 {
      try visitor.visitSingularInt32Field(value: self.showDuration, fieldNumber: 15)
    }
    if self.showStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.showStatus, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVo, rhs: OSUserVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.birthday != rhs.birthday {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.following != rhs.following {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.coverURL != rhs.coverURL {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.visitTime != rhs.visitTime {return false}
    if lhs.showVoice != rhs.showVoice {return false}
    if lhs.showDuration != rhs.showDuration {return false}
    if lhs.showStatus != rhs.showStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserInChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "userId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "nickname"),
    5: .same(proto: "avatarUrl"),
    6: .same(proto: "gender"),
    7: .same(proto: "seat"),
    8: .same(proto: "allowToSpeak"),
    9: .same(proto: "allowToType"),
    10: .same(proto: "powerType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.seat) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.allowToSpeak) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.allowToType) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.powerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 4)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    if self.seat != 0 {
      try visitor.visitSingularInt32Field(value: self.seat, fieldNumber: 7)
    }
    if self.allowToSpeak != 0 {
      try visitor.visitSingularInt32Field(value: self.allowToSpeak, fieldNumber: 8)
    }
    if self.allowToType != 0 {
      try visitor.visitSingularInt32Field(value: self.allowToType, fieldNumber: 9)
    }
    if self.powerType != .unknown {
      try visitor.visitSingularEnumField(value: self.powerType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserInChannel, rhs: OSUserInChannel) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.seat != rhs.seat {return false}
    if lhs.allowToSpeak != rhs.allowToSpeak {return false}
    if lhs.allowToType != rhs.allowToType {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "hasCertification"),
    3: .same(proto: "certificationAge"),
    4: .same(proto: "hasAdolescent"),
    5: .same(proto: "password"),
    6: .same(proto: "displayName"),
    7: .same(proto: "displayNumber"),
    11: .same(proto: "createChannelAuth"),
    12: .same(proto: "upSeatAuth"),
    13: .same(proto: "publicChatAuth"),
    14: .same(proto: "momentAuth"),
    15: .same(proto: "commentAuth"),
    16: .same(proto: "createFamilyAuth"),
    10: .same(proto: "faceVerification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hasCertification_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.certificationAge) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.hasAdolescent_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.displayNumber) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.faceVerification) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.createChannelAuth) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.upSeatAuth) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.publicChatAuth) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.momentAuth) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.commentAuth) }()
      case 16: try { try decoder.decodeSingularInt32Field(value: &self.createFamilyAuth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.hasCertification_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasCertification_p, fieldNumber: 2)
    }
    if self.certificationAge != 0 {
      try visitor.visitSingularInt32Field(value: self.certificationAge, fieldNumber: 3)
    }
    if self.hasAdolescent_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasAdolescent_p, fieldNumber: 4)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 5)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 6)
    }
    if !self.displayNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.displayNumber, fieldNumber: 7)
    }
    if self.faceVerification != 0 {
      try visitor.visitSingularInt32Field(value: self.faceVerification, fieldNumber: 10)
    }
    if self.createChannelAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.createChannelAuth, fieldNumber: 11)
    }
    if self.upSeatAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.upSeatAuth, fieldNumber: 12)
    }
    if self.publicChatAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.publicChatAuth, fieldNumber: 13)
    }
    if self.momentAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.momentAuth, fieldNumber: 14)
    }
    if self.commentAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.commentAuth, fieldNumber: 15)
    }
    if self.createFamilyAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.createFamilyAuth, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserSetting, rhs: OSUserSetting) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.hasCertification_p != rhs.hasCertification_p {return false}
    if lhs.certificationAge != rhs.certificationAge {return false}
    if lhs.hasAdolescent_p != rhs.hasAdolescent_p {return false}
    if lhs.password != rhs.password {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.displayNumber != rhs.displayNumber {return false}
    if lhs.createChannelAuth != rhs.createChannelAuth {return false}
    if lhs.upSeatAuth != rhs.upSeatAuth {return false}
    if lhs.publicChatAuth != rhs.publicChatAuth {return false}
    if lhs.momentAuth != rhs.momentAuth {return false}
    if lhs.commentAuth != rhs.commentAuth {return false}
    if lhs.createFamilyAuth != rhs.createFamilyAuth {return false}
    if lhs.faceVerification != rhs.faceVerification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMedalList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MedalList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "medalId"),
    2: .same(proto: "medalName"),
    3: .same(proto: "medalLevelTitle"),
    4: .same(proto: "medalIndex"),
    5: .same(proto: "medalLevelIcon"),
    6: .same(proto: "medalLevelIcon2"),
    7: .same(proto: "totalLevel"),
    8: .same(proto: "cornerColor"),
    9: .same(proto: "startLevelValue"),
    10: .same(proto: "empiricalValue"),
    11: .same(proto: "nextUserMedalLevelVo"),
  ]

  fileprivate class _StorageClass {
    var _medalID: Int32 = 0
    var _medalName: String = String()
    var _medalLevelTitle: String = String()
    var _medalIndex: String = String()
    var _medalLevelIcon: String = String()
    var _medalLevelIcon2: String = String()
    var _totalLevel: Int32 = 0
    var _cornerColor: String = String()
    var _startLevelValue: Int32 = 0
    var _empiricalValue: Int32 = 0
    var _nextUserMedalLevelVo: OSMedalList? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _medalID = source._medalID
      _medalName = source._medalName
      _medalLevelTitle = source._medalLevelTitle
      _medalIndex = source._medalIndex
      _medalLevelIcon = source._medalLevelIcon
      _medalLevelIcon2 = source._medalLevelIcon2
      _totalLevel = source._totalLevel
      _cornerColor = source._cornerColor
      _startLevelValue = source._startLevelValue
      _empiricalValue = source._empiricalValue
      _nextUserMedalLevelVo = source._nextUserMedalLevelVo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._medalID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._medalName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._medalLevelTitle) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._medalIndex) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._medalLevelIcon) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._medalLevelIcon2) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._totalLevel) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._cornerColor) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._startLevelValue) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._empiricalValue) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._nextUserMedalLevelVo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._medalID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._medalID, fieldNumber: 1)
      }
      if !_storage._medalName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._medalName, fieldNumber: 2)
      }
      if !_storage._medalLevelTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._medalLevelTitle, fieldNumber: 3)
      }
      if !_storage._medalIndex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._medalIndex, fieldNumber: 4)
      }
      if !_storage._medalLevelIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._medalLevelIcon, fieldNumber: 5)
      }
      if !_storage._medalLevelIcon2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._medalLevelIcon2, fieldNumber: 6)
      }
      if _storage._totalLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalLevel, fieldNumber: 7)
      }
      if !_storage._cornerColor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cornerColor, fieldNumber: 8)
      }
      if _storage._startLevelValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._startLevelValue, fieldNumber: 9)
      }
      if _storage._empiricalValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._empiricalValue, fieldNumber: 10)
      }
      try { if let v = _storage._nextUserMedalLevelVo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMedalList, rhs: OSMedalList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._medalID != rhs_storage._medalID {return false}
        if _storage._medalName != rhs_storage._medalName {return false}
        if _storage._medalLevelTitle != rhs_storage._medalLevelTitle {return false}
        if _storage._medalIndex != rhs_storage._medalIndex {return false}
        if _storage._medalLevelIcon != rhs_storage._medalLevelIcon {return false}
        if _storage._medalLevelIcon2 != rhs_storage._medalLevelIcon2 {return false}
        if _storage._totalLevel != rhs_storage._totalLevel {return false}
        if _storage._cornerColor != rhs_storage._cornerColor {return false}
        if _storage._startLevelValue != rhs_storage._startLevelValue {return false}
        if _storage._empiricalValue != rhs_storage._empiricalValue {return false}
        if _storage._nextUserMedalLevelVo != rhs_storage._nextUserMedalLevelVo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressName"),
    2: .same(proto: "dressIcon"),
    3: .same(proto: "dressIconSvga"),
    4: .same(proto: "cardDecoration"),
    5: .same(proto: "homeDecoration"),
    6: .same(proto: "taillightUrl"),
    7: .same(proto: "accountLabel"),
    8: .same(proto: "prettyAccount"),
    9: .same(proto: "pendantList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressIcon) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressIconSvga) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.cardDecoration) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.homeDecoration) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.taillightURL) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.accountLabel) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.prettyAccount) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.pendantList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 1)
    }
    if !self.dressIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIcon, fieldNumber: 2)
    }
    if !self.dressIconSvga.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIconSvga, fieldNumber: 3)
    }
    if !self.cardDecoration.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cardDecoration, fieldNumber: 4)
    }
    if !self.homeDecoration.isEmpty {
      try visitor.visitRepeatedStringField(value: self.homeDecoration, fieldNumber: 5)
    }
    if !self.taillightURL.isEmpty {
      try visitor.visitSingularStringField(value: self.taillightURL, fieldNumber: 6)
    }
    if !self.accountLabel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountLabel, fieldNumber: 7)
    }
    if self.prettyAccount != 0 {
      try visitor.visitSingularInt32Field(value: self.prettyAccount, fieldNumber: 8)
    }
    if !self.pendantList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendantList, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpInfo, rhs: OSDressUpInfo) -> Bool {
    if lhs.dressName != rhs.dressName {return false}
    if lhs.dressIcon != rhs.dressIcon {return false}
    if lhs.dressIconSvga != rhs.dressIconSvga {return false}
    if lhs.cardDecoration != rhs.cardDecoration {return false}
    if lhs.homeDecoration != rhs.homeDecoration {return false}
    if lhs.taillightURL != rhs.taillightURL {return false}
    if lhs.accountLabel != rhs.accountLabel {return false}
    if lhs.prettyAccount != rhs.prettyAccount {return false}
    if lhs.pendantList != rhs.pendantList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHonouredGuestCard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HonouredGuestCard"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cardId"),
    2: .same(proto: "levelId"),
    3: .same(proto: "cardName"),
    4: .same(proto: "cardIcon"),
    5: .same(proto: "cardCount"),
    6: .same(proto: "backdropUrl"),
    7: .same(proto: "promptUrl"),
    8: .same(proto: "fontColor"),
    9: .same(proto: "honouredGestUrl"),
    10: .same(proto: "channelNo"),
    11: .same(proto: "channelName"),
    12: .same(proto: "avatarUrl"),
    13: .same(proto: "channelId"),
    14: .same(proto: "wealthValue"),
    15: .same(proto: "protectionValue"),
    16: .same(proto: "levelUpdateTime"),
    17: .same(proto: "systemTime"),
  ]

  fileprivate class _StorageClass {
    var _cardID: Int64 = 0
    var _levelID: Int64 = 0
    var _cardName: String = String()
    var _cardIcon: String = String()
    var _cardCount: Int32 = 0
    var _backdropURL: String = String()
    var _promptURL: String = String()
    var _fontColor: String = String()
    var _honouredGestURL: String = String()
    var _channelNo: Int32 = 0
    var _channelName: String = String()
    var _avatarURL: String = String()
    var _channelID: String = String()
    var _wealthValue: Int64 = 0
    var _protectionValue: Int64 = 0
    var _levelUpdateTime: Int64 = 0
    var _systemTime: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _cardID = source._cardID
      _levelID = source._levelID
      _cardName = source._cardName
      _cardIcon = source._cardIcon
      _cardCount = source._cardCount
      _backdropURL = source._backdropURL
      _promptURL = source._promptURL
      _fontColor = source._fontColor
      _honouredGestURL = source._honouredGestURL
      _channelNo = source._channelNo
      _channelName = source._channelName
      _avatarURL = source._avatarURL
      _channelID = source._channelID
      _wealthValue = source._wealthValue
      _protectionValue = source._protectionValue
      _levelUpdateTime = source._levelUpdateTime
      _systemTime = source._systemTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._cardID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._levelID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._cardName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._cardIcon) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._cardCount) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._backdropURL) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._promptURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._fontColor) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._honouredGestURL) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._channelNo) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._channelName) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._wealthValue) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._protectionValue) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._levelUpdateTime) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._systemTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cardID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._cardID, fieldNumber: 1)
      }
      if _storage._levelID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._levelID, fieldNumber: 2)
      }
      if !_storage._cardName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cardName, fieldNumber: 3)
      }
      if !_storage._cardIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cardIcon, fieldNumber: 4)
      }
      if _storage._cardCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cardCount, fieldNumber: 5)
      }
      if !_storage._backdropURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backdropURL, fieldNumber: 6)
      }
      if !_storage._promptURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._promptURL, fieldNumber: 7)
      }
      if !_storage._fontColor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fontColor, fieldNumber: 8)
      }
      if !_storage._honouredGestURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._honouredGestURL, fieldNumber: 9)
      }
      if _storage._channelNo != 0 {
        try visitor.visitSingularInt32Field(value: _storage._channelNo, fieldNumber: 10)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 11)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 12)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 13)
      }
      if _storage._wealthValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._wealthValue, fieldNumber: 14)
      }
      if _storage._protectionValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._protectionValue, fieldNumber: 15)
      }
      if _storage._levelUpdateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._levelUpdateTime, fieldNumber: 16)
      }
      if _storage._systemTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._systemTime, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHonouredGuestCard, rhs: OSHonouredGuestCard) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cardID != rhs_storage._cardID {return false}
        if _storage._levelID != rhs_storage._levelID {return false}
        if _storage._cardName != rhs_storage._cardName {return false}
        if _storage._cardIcon != rhs_storage._cardIcon {return false}
        if _storage._cardCount != rhs_storage._cardCount {return false}
        if _storage._backdropURL != rhs_storage._backdropURL {return false}
        if _storage._promptURL != rhs_storage._promptURL {return false}
        if _storage._fontColor != rhs_storage._fontColor {return false}
        if _storage._honouredGestURL != rhs_storage._honouredGestURL {return false}
        if _storage._channelNo != rhs_storage._channelNo {return false}
        if _storage._channelName != rhs_storage._channelName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._wealthValue != rhs_storage._wealthValue {return false}
        if _storage._protectionValue != rhs_storage._protectionValue {return false}
        if _storage._levelUpdateTime != rhs_storage._levelUpdateTime {return false}
        if _storage._systemTime != rhs_storage._systemTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEidolonInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EidolonInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEidolonInfo, rhs: OSEidolonInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAccountLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountLabel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labelName"),
    2: .same(proto: "labelUrl"),
    3: .same(proto: "labelUrl2"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.labelName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.labelURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.labelURL2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labelName.isEmpty {
      try visitor.visitSingularStringField(value: self.labelName, fieldNumber: 1)
    }
    if !self.labelURL.isEmpty {
      try visitor.visitSingularStringField(value: self.labelURL, fieldNumber: 2)
    }
    if !self.labelURL2.isEmpty {
      try visitor.visitSingularStringField(value: self.labelURL2, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAccountLabel, rhs: OSAccountLabel) -> Bool {
    if lhs.labelName != rhs.labelName {return false}
    if lhs.labelURL != rhs.labelURL {return false}
    if lhs.labelURL2 != rhs.labelURL2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPendantInfo2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendantInfo2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "dressName"),
    3: .same(proto: "dressIcon"),
    4: .same(proto: "effectUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressIcon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 2)
    }
    if !self.dressIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIcon, fieldNumber: 3)
    }
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPendantInfo2, rhs: OSPendantInfo2) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.dressName != rhs.dressName {return false}
    if lhs.dressIcon != rhs.dressIcon {return false}
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserInSeats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserInSeats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "userId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "nickname"),
    5: .same(proto: "avatarUrl"),
    6: .same(proto: "gender"),
    7: .same(proto: "seat"),
    8: .same(proto: "lovenum"),
    9: .same(proto: "allowToSpeak"),
    10: .same(proto: "allowToType"),
    11: .same(proto: "powerType"),
    12: .same(proto: "channelPowerType"),
    13: .same(proto: "robot"),
    14: .same(proto: "status"),
    15: .same(proto: "dressUpInfo"),
    16: .same(proto: "honouredGuestCard"),
    17: .same(proto: "equipment"),
  ]

  fileprivate class _StorageClass {
    var _channelID: String = String()
    var _userID: String = String()
    var _accountID: Int32 = 0
    var _nickname: String = String()
    var _avatarURL: String = String()
    var _gender: OSGender = .unknown
    var _seat: Int32 = 0
    var _lovenum: Int32 = 0
    var _allowToSpeak: Int32 = 0
    var _allowToType: Int32 = 0
    var _powerType: OSPowerType = .unknown
    var _channelPowerType: Int32 = 0
    var _robot: Int32 = 0
    var _status: Int32 = 0
    var _dressUpInfo: OSDressUpInfo? = nil
    var _honouredGuestCard: OSHonouredGuestCard? = nil
    var _equipment: OSEquipmentComponent? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _userID = source._userID
      _accountID = source._accountID
      _nickname = source._nickname
      _avatarURL = source._avatarURL
      _gender = source._gender
      _seat = source._seat
      _lovenum = source._lovenum
      _allowToSpeak = source._allowToSpeak
      _allowToType = source._allowToType
      _powerType = source._powerType
      _channelPowerType = source._channelPowerType
      _robot = source._robot
      _status = source._status
      _dressUpInfo = source._dressUpInfo
      _honouredGuestCard = source._honouredGuestCard
      _equipment = source._equipment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._accountID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._gender) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._seat) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._lovenum) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._allowToSpeak) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._allowToType) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._powerType) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._channelPowerType) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._robot) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._honouredGuestCard) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._equipment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if _storage._accountID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._accountID, fieldNumber: 3)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 4)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 5)
      }
      if _storage._gender != .unknown {
        try visitor.visitSingularEnumField(value: _storage._gender, fieldNumber: 6)
      }
      if _storage._seat != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat, fieldNumber: 7)
      }
      if _storage._lovenum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lovenum, fieldNumber: 8)
      }
      if _storage._allowToSpeak != 0 {
        try visitor.visitSingularInt32Field(value: _storage._allowToSpeak, fieldNumber: 9)
      }
      if _storage._allowToType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._allowToType, fieldNumber: 10)
      }
      if _storage._powerType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._powerType, fieldNumber: 11)
      }
      if _storage._channelPowerType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._channelPowerType, fieldNumber: 12)
      }
      if _storage._robot != 0 {
        try visitor.visitSingularInt32Field(value: _storage._robot, fieldNumber: 13)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 14)
      }
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._honouredGuestCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._equipment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserInSeats, rhs: OSUserInSeats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._seat != rhs_storage._seat {return false}
        if _storage._lovenum != rhs_storage._lovenum {return false}
        if _storage._allowToSpeak != rhs_storage._allowToSpeak {return false}
        if _storage._allowToType != rhs_storage._allowToType {return false}
        if _storage._powerType != rhs_storage._powerType {return false}
        if _storage._channelPowerType != rhs_storage._channelPowerType {return false}
        if _storage._robot != rhs_storage._robot {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        if _storage._honouredGuestCard != rhs_storage._honouredGuestCard {return false}
        if _storage._equipment != rhs_storage._equipment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSInteractionVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InteractionVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "interactiveType"),
    3: .same(proto: "targetUserId"),
    4: .same(proto: "interactiveTargetId"),
    5: .same(proto: "assistTargetId"),
    6: .same(proto: "interactiveContent"),
    7: .same(proto: "userId"),
    8: .same(proto: "avatarUrl"),
    9: .same(proto: "nickname"),
    10: .same(proto: "hasRead"),
    11: .same(proto: "createTimestamp"),
    12: .same(proto: "momentFirstPic"),
    13: .same(proto: "thought"),
    14: .same(proto: "momentType"),
    15: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.interactiveType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetUserID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.interactiveTargetID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.assistTargetID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.interactiveContent) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.hasRead_p) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.createTimestamp) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.momentFirstPic) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.thought) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.momentType) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.interactiveType != 0 {
      try visitor.visitSingularInt32Field(value: self.interactiveType, fieldNumber: 2)
    }
    if !self.targetUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUserID, fieldNumber: 3)
    }
    if self.interactiveTargetID != 0 {
      try visitor.visitSingularInt32Field(value: self.interactiveTargetID, fieldNumber: 4)
    }
    if self.assistTargetID != 0 {
      try visitor.visitSingularInt64Field(value: self.assistTargetID, fieldNumber: 5)
    }
    if !self.interactiveContent.isEmpty {
      try visitor.visitSingularStringField(value: self.interactiveContent, fieldNumber: 6)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 7)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 8)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 9)
    }
    if self.hasRead_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasRead_p, fieldNumber: 10)
    }
    if self.createTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.createTimestamp, fieldNumber: 11)
    }
    if !self.momentFirstPic.isEmpty {
      try visitor.visitSingularStringField(value: self.momentFirstPic, fieldNumber: 12)
    }
    if !self.thought.isEmpty {
      try visitor.visitSingularStringField(value: self.thought, fieldNumber: 13)
    }
    if self.momentType != 0 {
      try visitor.visitSingularInt32Field(value: self.momentType, fieldNumber: 14)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSInteractionVo, rhs: OSInteractionVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.interactiveType != rhs.interactiveType {return false}
    if lhs.targetUserID != rhs.targetUserID {return false}
    if lhs.interactiveTargetID != rhs.interactiveTargetID {return false}
    if lhs.assistTargetID != rhs.assistTargetID {return false}
    if lhs.interactiveContent != rhs.interactiveContent {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.hasRead_p != rhs.hasRead_p {return false}
    if lhs.createTimestamp != rhs.createTimestamp {return false}
    if lhs.momentFirstPic != rhs.momentFirstPic {return false}
    if lhs.thought != rhs.thought {return false}
    if lhs.momentType != rhs.momentType {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChatChannelUserVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatChannelUserVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "gender"),
    6: .same(proto: "seat"),
    7: .same(proto: "powerType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.seat) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.powerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 5)
    }
    if self.seat != 0 {
      try visitor.visitSingularInt32Field(value: self.seat, fieldNumber: 6)
    }
    if self.powerType != .unknown {
      try visitor.visitSingularEnumField(value: self.powerType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChatChannelUserVo, rhs: OSChatChannelUserVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.seat != rhs.seat {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "clubId"),
    6: .same(proto: "channelId"),
    7: .same(proto: "count"),
    8: .same(proto: "badgeName"),
    9: .same(proto: "badgeIcon"),
    10: .same(proto: "badgeLevel"),
    11: .same(proto: "status"),
    12: .same(proto: "targetId"),
    13: .same(proto: "level"),
    14: .same(proto: "intimacyValue"),
    15: .same(proto: "nextLevel"),
    16: .same(proto: "nextLevelValue"),
    17: .same(proto: "currentValue"),
    18: .same(proto: "upperLimitValue"),
    19: .same(proto: "maxLevelValue"),
  ]

  fileprivate class _StorageClass {
    var _userID: String = String()
    var _accountID: Int32 = 0
    var _nickname: String = String()
    var _avatarURL: String = String()
    var _clubID: Int64 = 0
    var _channelID: String = String()
    var _count: Int32 = 0
    var _badgeName: String = String()
    var _badgeIcon: String = String()
    var _badgeLevel: String = String()
    var _status: Int32 = 0
    var _targetID: String = String()
    var _level: Int32 = 0
    var _intimacyValue: Int64 = 0
    var _nextLevel: Int32 = 0
    var _nextLevelValue: Int64 = 0
    var _currentValue: Int32 = 0
    var _upperLimitValue: Int32 = 0
    var _maxLevelValue: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _userID = source._userID
      _accountID = source._accountID
      _nickname = source._nickname
      _avatarURL = source._avatarURL
      _clubID = source._clubID
      _channelID = source._channelID
      _count = source._count
      _badgeName = source._badgeName
      _badgeIcon = source._badgeIcon
      _badgeLevel = source._badgeLevel
      _status = source._status
      _targetID = source._targetID
      _level = source._level
      _intimacyValue = source._intimacyValue
      _nextLevel = source._nextLevel
      _nextLevelValue = source._nextLevelValue
      _currentValue = source._currentValue
      _upperLimitValue = source._upperLimitValue
      _maxLevelValue = source._maxLevelValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._accountID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._clubID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._count) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._badgeName) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._badgeIcon) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._badgeLevel) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._targetID) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._level) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._intimacyValue) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._nextLevel) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._nextLevelValue) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._currentValue) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._upperLimitValue) }()
        case 19: try { try decoder.decodeSingularInt64Field(value: &_storage._maxLevelValue) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 1)
      }
      if _storage._accountID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._accountID, fieldNumber: 2)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if _storage._clubID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._clubID, fieldNumber: 5)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 6)
      }
      if _storage._count != 0 {
        try visitor.visitSingularInt32Field(value: _storage._count, fieldNumber: 7)
      }
      if !_storage._badgeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._badgeName, fieldNumber: 8)
      }
      if !_storage._badgeIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._badgeIcon, fieldNumber: 9)
      }
      if !_storage._badgeLevel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._badgeLevel, fieldNumber: 10)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 11)
      }
      if !_storage._targetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetID, fieldNumber: 12)
      }
      if _storage._level != 0 {
        try visitor.visitSingularInt32Field(value: _storage._level, fieldNumber: 13)
      }
      if _storage._intimacyValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._intimacyValue, fieldNumber: 14)
      }
      if _storage._nextLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nextLevel, fieldNumber: 15)
      }
      if _storage._nextLevelValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nextLevelValue, fieldNumber: 16)
      }
      if _storage._currentValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentValue, fieldNumber: 17)
      }
      if _storage._upperLimitValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._upperLimitValue, fieldNumber: 18)
      }
      if _storage._maxLevelValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxLevelValue, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubVo, rhs: OSFansClubVo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._clubID != rhs_storage._clubID {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._badgeName != rhs_storage._badgeName {return false}
        if _storage._badgeIcon != rhs_storage._badgeIcon {return false}
        if _storage._badgeLevel != rhs_storage._badgeLevel {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._intimacyValue != rhs_storage._intimacyValue {return false}
        if _storage._nextLevel != rhs_storage._nextLevel {return false}
        if _storage._nextLevelValue != rhs_storage._nextLevelValue {return false}
        if _storage._currentValue != rhs_storage._currentValue {return false}
        if _storage._upperLimitValue != rhs_storage._upperLimitValue {return false}
        if _storage._maxLevelValue != rhs_storage._maxLevelValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubGiftVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubGiftVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftId"),
    2: .same(proto: "name"),
    3: .same(proto: "iconUrl"),
    4: .same(proto: "value"),
    5: .same(proto: "effects"),
    6: .same(proto: "cornerIcon"),
    7: .same(proto: "giftNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.effects) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.cornerIcon) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.giftNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 4)
    }
    if !self.effects.isEmpty {
      try visitor.visitSingularStringField(value: self.effects, fieldNumber: 5)
    }
    if !self.cornerIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.cornerIcon, fieldNumber: 6)
    }
    if !self.giftNum.isEmpty {
      try visitor.visitSingularStringField(value: self.giftNum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubGiftVo, rhs: OSFansClubGiftVo) -> Bool {
    if lhs.giftID != rhs.giftID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.value != rhs.value {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.cornerIcon != rhs.cornerIcon {return false}
    if lhs.giftNum != rhs.giftNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSIntimacyVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntimacyVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    17: .same(proto: "currentValue"),
    18: .same(proto: "upperLimitValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 17: try { try decoder.decodeSingularInt32Field(value: &self.currentValue) }()
      case 18: try { try decoder.decodeSingularInt32Field(value: &self.upperLimitValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.currentValue != 0 {
      try visitor.visitSingularInt32Field(value: self.currentValue, fieldNumber: 17)
    }
    if self.upperLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.upperLimitValue, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSIntimacyVo, rhs: OSIntimacyVo) -> Bool {
    if lhs.currentValue != rhs.currentValue {return false}
    if lhs.upperLimitValue != rhs.upperLimitValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubTaskVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubTaskVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "taskId"),
    2: .same(proto: "locationType"),
    3: .same(proto: "name"),
    4: .same(proto: "iconUrl"),
    5: .same(proto: "prizeValue"),
    6: .same(proto: "count"),
    7: .same(proto: "buttonName"),
    8: .same(proto: "giftName"),
    9: .same(proto: "giftIconUrl"),
    10: .same(proto: "condition2"),
    11: .same(proto: "taskStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.taskID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.locationType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.iconURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.prizeValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.buttonName) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.giftName) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.giftIconURL) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.condition2) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.taskStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.taskID != 0 {
      try visitor.visitSingularInt32Field(value: self.taskID, fieldNumber: 1)
    }
    if self.locationType != 0 {
      try visitor.visitSingularInt32Field(value: self.locationType, fieldNumber: 2)
    }
    if self.name != 0 {
      try visitor.visitSingularInt32Field(value: self.name, fieldNumber: 3)
    }
    if self.iconURL != 0 {
      try visitor.visitSingularInt32Field(value: self.iconURL, fieldNumber: 4)
    }
    if self.prizeValue != 0 {
      try visitor.visitSingularInt32Field(value: self.prizeValue, fieldNumber: 5)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 6)
    }
    if self.buttonName != 0 {
      try visitor.visitSingularInt32Field(value: self.buttonName, fieldNumber: 7)
    }
    if self.giftName != 0 {
      try visitor.visitSingularInt32Field(value: self.giftName, fieldNumber: 8)
    }
    if self.giftIconURL != 0 {
      try visitor.visitSingularInt32Field(value: self.giftIconURL, fieldNumber: 9)
    }
    if self.condition2 != 0 {
      try visitor.visitSingularInt32Field(value: self.condition2, fieldNumber: 10)
    }
    if self.taskStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.taskStatus, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubTaskVo, rhs: OSFansClubTaskVo) -> Bool {
    if lhs.taskID != rhs.taskID {return false}
    if lhs.locationType != rhs.locationType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.prizeValue != rhs.prizeValue {return false}
    if lhs.count != rhs.count {return false}
    if lhs.buttonName != rhs.buttonName {return false}
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftIconURL != rhs.giftIconURL {return false}
    if lhs.condition2 != rhs.condition2 {return false}
    if lhs.taskStatus != rhs.taskStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Wallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "diamond_count"),
    2: .standard(proto: "crystal_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.diamondCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.crystalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diamondCount != 0 {
      try visitor.visitSingularInt64Field(value: self.diamondCount, fieldNumber: 1)
    }
    if self.crystalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.crystalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWallet, rhs: OSWallet) -> Bool {
    if lhs.diamondCount != rhs.diamondCount {return false}
    if lhs.crystalCount != rhs.crystalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEquipmentComponent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EquipmentComponent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "body_id"),
    3: .standard(proto: "head_id"),
    4: .standard(proto: "eyes_id"),
    5: .standard(proto: "hair_id"),
    30: .standard(proto: "top_id"),
    31: .standard(proto: "bottom_id"),
    32: .standard(proto: "shoes_id"),
    33: .standard(proto: "coat_id"),
    34: .standard(proto: "hat_id"),
    50: .standard(proto: "dress_id"),
    51: .standard(proto: "doll_dress_id"),
    100: .standard(proto: "bag_id"),
    101: .standard(proto: "necklace_id"),
    102: .standard(proto: "bracelet_id"),
    103: .standard(proto: "earring_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.bodyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.headID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.eyesID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.hairID) }()
      case 30: try { try decoder.decodeSingularInt64Field(value: &self.topID) }()
      case 31: try { try decoder.decodeSingularInt64Field(value: &self.bottomID) }()
      case 32: try { try decoder.decodeSingularInt64Field(value: &self.shoesID) }()
      case 33: try { try decoder.decodeSingularInt64Field(value: &self.coatID) }()
      case 34: try { try decoder.decodeSingularInt64Field(value: &self.hatID) }()
      case 50: try { try decoder.decodeSingularInt64Field(value: &self.dressID) }()
      case 51: try { try decoder.decodeSingularInt64Field(value: &self.dollDressID) }()
      case 100: try { try decoder.decodeSingularInt64Field(value: &self.bagID) }()
      case 101: try { try decoder.decodeSingularInt64Field(value: &self.necklaceID) }()
      case 102: try { try decoder.decodeSingularInt64Field(value: &self.braceletID) }()
      case 103: try { try decoder.decodeSingularInt64Field(value: &self.earringID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.bodyID != 0 {
      try visitor.visitSingularInt64Field(value: self.bodyID, fieldNumber: 2)
    }
    if self.headID != 0 {
      try visitor.visitSingularInt64Field(value: self.headID, fieldNumber: 3)
    }
    if self.eyesID != 0 {
      try visitor.visitSingularInt64Field(value: self.eyesID, fieldNumber: 4)
    }
    if self.hairID != 0 {
      try visitor.visitSingularInt64Field(value: self.hairID, fieldNumber: 5)
    }
    if self.topID != 0 {
      try visitor.visitSingularInt64Field(value: self.topID, fieldNumber: 30)
    }
    if self.bottomID != 0 {
      try visitor.visitSingularInt64Field(value: self.bottomID, fieldNumber: 31)
    }
    if self.shoesID != 0 {
      try visitor.visitSingularInt64Field(value: self.shoesID, fieldNumber: 32)
    }
    if self.coatID != 0 {
      try visitor.visitSingularInt64Field(value: self.coatID, fieldNumber: 33)
    }
    if self.hatID != 0 {
      try visitor.visitSingularInt64Field(value: self.hatID, fieldNumber: 34)
    }
    if self.dressID != 0 {
      try visitor.visitSingularInt64Field(value: self.dressID, fieldNumber: 50)
    }
    if self.dollDressID != 0 {
      try visitor.visitSingularInt64Field(value: self.dollDressID, fieldNumber: 51)
    }
    if self.bagID != 0 {
      try visitor.visitSingularInt64Field(value: self.bagID, fieldNumber: 100)
    }
    if self.necklaceID != 0 {
      try visitor.visitSingularInt64Field(value: self.necklaceID, fieldNumber: 101)
    }
    if self.braceletID != 0 {
      try visitor.visitSingularInt64Field(value: self.braceletID, fieldNumber: 102)
    }
    if self.earringID != 0 {
      try visitor.visitSingularInt64Field(value: self.earringID, fieldNumber: 103)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEquipmentComponent, rhs: OSEquipmentComponent) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.bodyID != rhs.bodyID {return false}
    if lhs.headID != rhs.headID {return false}
    if lhs.eyesID != rhs.eyesID {return false}
    if lhs.hairID != rhs.hairID {return false}
    if lhs.topID != rhs.topID {return false}
    if lhs.bottomID != rhs.bottomID {return false}
    if lhs.shoesID != rhs.shoesID {return false}
    if lhs.coatID != rhs.coatID {return false}
    if lhs.hatID != rhs.hatID {return false}
    if lhs.dressID != rhs.dressID {return false}
    if lhs.dollDressID != rhs.dollDressID {return false}
    if lhs.bagID != rhs.bagID {return false}
    if lhs.necklaceID != rhs.necklaceID {return false}
    if lhs.braceletID != rhs.braceletID {return false}
    if lhs.earringID != rhs.earringID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGoodsPrice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoodsPrice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGoodsPrice, rhs: OSGoodsPrice) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserWishGiftVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWishGiftVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finish"),
    2: .same(proto: "maxLimitValue"),
    3: .same(proto: "progressList"),
    4: .same(proto: "topUser"),
    5: .same(proto: "userCount"),
    6: .same(proto: "wishSwitch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxLimitValue) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.progressList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.topUser) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.userCount) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.wishSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 1)
    }
    if self.maxLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLimitValue, fieldNumber: 2)
    }
    if !self.progressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.progressList, fieldNumber: 3)
    }
    if !self.topUser.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topUser, fieldNumber: 4)
    }
    if self.userCount != 0 {
      try visitor.visitSingularInt32Field(value: self.userCount, fieldNumber: 5)
    }
    if self.wishSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.wishSwitch, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserWishGiftVo, rhs: OSUserWishGiftVo) -> Bool {
    if lhs.finish != rhs.finish {return false}
    if lhs.maxLimitValue != rhs.maxLimitValue {return false}
    if lhs.progressList != rhs.progressList {return false}
    if lhs.topUser != rhs.topUser {return false}
    if lhs.userCount != rhs.userCount {return false}
    if lhs.wishSwitch != rhs.wishSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cornerIcon"),
    2: .same(proto: "effects"),
    3: .same(proto: "finishCount"),
    4: .same(proto: "giftCount"),
    5: .same(proto: "giftId"),
    6: .same(proto: "iconUrl"),
    7: .same(proto: "name"),
    8: .same(proto: "value"),
    9: .same(proto: "timedCornerMark"),
    10: .same(proto: "bannerType"),
    11: .same(proto: "bannerContent"),
    12: .same(proto: "showPop"),
    13: .same(proto: "giftType"),
    14: .same(proto: "giftFlag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cornerIcon) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effects) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.finishCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.timedCornerMark) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.bannerType) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.showPop) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.giftType) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.giftFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cornerIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.cornerIcon, fieldNumber: 1)
    }
    if !self.effects.isEmpty {
      try visitor.visitSingularStringField(value: self.effects, fieldNumber: 2)
    }
    if self.finishCount != 0 {
      try visitor.visitSingularInt32Field(value: self.finishCount, fieldNumber: 3)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 4)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 5)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 8)
    }
    if self.timedCornerMark != 0 {
      try visitor.visitSingularInt32Field(value: self.timedCornerMark, fieldNumber: 9)
    }
    if self.bannerType != 0 {
      try visitor.visitSingularInt32Field(value: self.bannerType, fieldNumber: 10)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 11)
    }
    if self.showPop != 0 {
      try visitor.visitSingularInt32Field(value: self.showPop, fieldNumber: 12)
    }
    if self.giftType != 0 {
      try visitor.visitSingularInt32Field(value: self.giftType, fieldNumber: 13)
    }
    if self.giftFlag != 0 {
      try visitor.visitSingularInt32Field(value: self.giftFlag, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftProgress, rhs: OSWishGiftProgress) -> Bool {
    if lhs.cornerIcon != rhs.cornerIcon {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.finishCount != rhs.finishCount {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.timedCornerMark != rhs.timedCornerMark {return false}
    if lhs.bannerType != rhs.bannerType {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.showPop != rhs.showPop {return false}
    if lhs.giftType != rhs.giftType {return false}
    if lhs.giftFlag != rhs.giftFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGifttopUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGifttopUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGifttopUser, rhs: OSWishGifttopUser) -> Bool {
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectionHallVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectionHallVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configId"),
    2: .same(proto: "name"),
    3: .same(proto: "level"),
    4: .same(proto: "count"),
    5: .same(proto: "totalCount"),
    6: .same(proto: "parentId"),
    7: .same(proto: "brightUrl"),
    8: .same(proto: "greyUrl"),
    9: .same(proto: "giftId"),
    10: .same(proto: "giftName"),
    11: .same(proto: "giftIconUrl"),
    12: .same(proto: "giftLovenum"),
    13: .same(proto: "giftValue"),
    14: .same(proto: "giftEffects"),
    15: .same(proto: "giftType"),
    16: .same(proto: "seriesId"),
    17: .same(proto: "remark"),
    18: .same(proto: "levelName"),
    19: .same(proto: "levelIcon"),
    50: .same(proto: "limited"),
    51: .same(proto: "effectiveTimeTamp"),
    52: .same(proto: "expireTimeTamp"),
    53: .same(proto: "days"),
    54: .same(proto: "prizeIndex"),
  ]

  fileprivate class _StorageClass {
    var _configID: Int32 = 0
    var _name: String = String()
    var _level: Int32 = 0
    var _count: Int32 = 0
    var _totalCount: Int32 = 0
    var _parentID: Int64 = 0
    var _brightURL: String = String()
    var _greyURL: String = String()
    var _giftID: Int32 = 0
    var _giftName: String = String()
    var _giftIconURL: String = String()
    var _giftLovenum: Int32 = 0
    var _giftValue: Int32 = 0
    var _giftEffects: String = String()
    var _giftType: Int32 = 0
    var _seriesID: Int32 = 0
    var _remark: String = String()
    var _levelName: String = String()
    var _levelIcon: String = String()
    var _limited: Int32 = 0
    var _effectiveTimeTamp: Int64 = 0
    var _expireTimeTamp: Int64 = 0
    var _days: Int32 = 0
    var _prizeIndex: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _configID = source._configID
      _name = source._name
      _level = source._level
      _count = source._count
      _totalCount = source._totalCount
      _parentID = source._parentID
      _brightURL = source._brightURL
      _greyURL = source._greyURL
      _giftID = source._giftID
      _giftName = source._giftName
      _giftIconURL = source._giftIconURL
      _giftLovenum = source._giftLovenum
      _giftValue = source._giftValue
      _giftEffects = source._giftEffects
      _giftType = source._giftType
      _seriesID = source._seriesID
      _remark = source._remark
      _levelName = source._levelName
      _levelIcon = source._levelIcon
      _limited = source._limited
      _effectiveTimeTamp = source._effectiveTimeTamp
      _expireTimeTamp = source._expireTimeTamp
      _days = source._days
      _prizeIndex = source._prizeIndex
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._configID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._level) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._count) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._totalCount) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._parentID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._brightURL) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._greyURL) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._giftID) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._giftName) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._giftIconURL) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._giftLovenum) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._giftValue) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._giftEffects) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._giftType) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._seriesID) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._remark) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._levelName) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._levelIcon) }()
        case 50: try { try decoder.decodeSingularInt32Field(value: &_storage._limited) }()
        case 51: try { try decoder.decodeSingularInt64Field(value: &_storage._effectiveTimeTamp) }()
        case 52: try { try decoder.decodeSingularInt64Field(value: &_storage._expireTimeTamp) }()
        case 53: try { try decoder.decodeSingularInt32Field(value: &_storage._days) }()
        case 54: try { try decoder.decodeSingularInt32Field(value: &_storage._prizeIndex) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._configID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._configID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._level != 0 {
        try visitor.visitSingularInt32Field(value: _storage._level, fieldNumber: 3)
      }
      if _storage._count != 0 {
        try visitor.visitSingularInt32Field(value: _storage._count, fieldNumber: 4)
      }
      if _storage._totalCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalCount, fieldNumber: 5)
      }
      if _storage._parentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parentID, fieldNumber: 6)
      }
      if !_storage._brightURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._brightURL, fieldNumber: 7)
      }
      if !_storage._greyURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._greyURL, fieldNumber: 8)
      }
      if _storage._giftID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftID, fieldNumber: 9)
      }
      if !_storage._giftName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._giftName, fieldNumber: 10)
      }
      if !_storage._giftIconURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._giftIconURL, fieldNumber: 11)
      }
      if _storage._giftLovenum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftLovenum, fieldNumber: 12)
      }
      if _storage._giftValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftValue, fieldNumber: 13)
      }
      if !_storage._giftEffects.isEmpty {
        try visitor.visitSingularStringField(value: _storage._giftEffects, fieldNumber: 14)
      }
      if _storage._giftType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftType, fieldNumber: 15)
      }
      if _storage._seriesID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seriesID, fieldNumber: 16)
      }
      if !_storage._remark.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remark, fieldNumber: 17)
      }
      if !_storage._levelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._levelName, fieldNumber: 18)
      }
      if !_storage._levelIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._levelIcon, fieldNumber: 19)
      }
      if _storage._limited != 0 {
        try visitor.visitSingularInt32Field(value: _storage._limited, fieldNumber: 50)
      }
      if _storage._effectiveTimeTamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._effectiveTimeTamp, fieldNumber: 51)
      }
      if _storage._expireTimeTamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expireTimeTamp, fieldNumber: 52)
      }
      if _storage._days != 0 {
        try visitor.visitSingularInt32Field(value: _storage._days, fieldNumber: 53)
      }
      if _storage._prizeIndex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._prizeIndex, fieldNumber: 54)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectionHallVo, rhs: OSCollectionHallVo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._configID != rhs_storage._configID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._totalCount != rhs_storage._totalCount {return false}
        if _storage._parentID != rhs_storage._parentID {return false}
        if _storage._brightURL != rhs_storage._brightURL {return false}
        if _storage._greyURL != rhs_storage._greyURL {return false}
        if _storage._giftID != rhs_storage._giftID {return false}
        if _storage._giftName != rhs_storage._giftName {return false}
        if _storage._giftIconURL != rhs_storage._giftIconURL {return false}
        if _storage._giftLovenum != rhs_storage._giftLovenum {return false}
        if _storage._giftValue != rhs_storage._giftValue {return false}
        if _storage._giftEffects != rhs_storage._giftEffects {return false}
        if _storage._giftType != rhs_storage._giftType {return false}
        if _storage._seriesID != rhs_storage._seriesID {return false}
        if _storage._remark != rhs_storage._remark {return false}
        if _storage._levelName != rhs_storage._levelName {return false}
        if _storage._levelIcon != rhs_storage._levelIcon {return false}
        if _storage._limited != rhs_storage._limited {return false}
        if _storage._effectiveTimeTamp != rhs_storage._effectiveTimeTamp {return false}
        if _storage._expireTimeTamp != rhs_storage._expireTimeTamp {return false}
        if _storage._days != rhs_storage._days {return false}
        if _storage._prizeIndex != rhs_storage._prizeIndex {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
