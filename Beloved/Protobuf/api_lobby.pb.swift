// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_lobby.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 大厅相关请求
public struct OSLobbyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSLobbyRequest.OneOf_Body? = nil

  /// 首页轮播图请求
  public var bannerReq: OSPageReq {
    get {
      if case .bannerReq(let v)? = body {return v}
      return OSPageReq()
    }
    set {body = .bannerReq(newValue)}
  }

  /// 首页房间列表请求
  public var channelListReq: OSPageReq {
    get {
      if case .channelListReq(let v)? = body {return v}
      return OSPageReq()
    }
    set {body = .channelListReq(newValue)}
  }

  /// 排行榜请求
  public var gloryRanksReq: OSGloryRanksReq {
    get {
      if case .gloryRanksReq(let v)? = body {return v}
      return OSGloryRanksReq()
    }
    set {body = .gloryRanksReq(newValue)}
  }

  /// 菜单请求
  public var menuReq: OSMenuReq {
    get {
      if case .menuReq(let v)? = body {return v}
      return OSMenuReq()
    }
    set {body = .menuReq(newValue)}
  }

  /// 获取首页信息请求
  public var lobbyInfoReq: OSLobbyInfoReq {
    get {
      if case .lobbyInfoReq(let v)? = body {return v}
      return OSLobbyInfoReq()
    }
    set {body = .lobbyInfoReq(newValue)}
  }

  /// 优质房间(置顶房间)请求
  public var topChannelListReq: OSTopChannelListReq {
    get {
      if case .topChannelListReq(let v)? = body {return v}
      return OSTopChannelListReq()
    }
    set {body = .topChannelListReq(newValue)}
  }

  /// 首页房间列表请求(IOS用)
  public var channelList2Req: OSPageReq {
    get {
      if case .channelList2Req(let v)? = body {return v}
      return OSPageReq()
    }
    set {body = .channelList2Req(newValue)}
  }

  /// 根据菜单随机获取公开厅房间请求
  public var publicChannelReq: OSPublicChannelReq {
    get {
      if case .publicChannelReq(let v)? = body {return v}
      return OSPublicChannelReq()
    }
    set {body = .publicChannelReq(newValue)}
  }

  /// 首页房间列表请求（最新）
  public var channelList3Req: OSLobbyChannelReq {
    get {
      if case .channelList3Req(let v)? = body {return v}
      return OSLobbyChannelReq()
    }
    set {body = .channelList3Req(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 首页轮播图请求
    case bannerReq(OSPageReq)
    /// 首页房间列表请求
    case channelListReq(OSPageReq)
    /// 排行榜请求
    case gloryRanksReq(OSGloryRanksReq)
    /// 菜单请求
    case menuReq(OSMenuReq)
    /// 获取首页信息请求
    case lobbyInfoReq(OSLobbyInfoReq)
    /// 优质房间(置顶房间)请求
    case topChannelListReq(OSTopChannelListReq)
    /// 首页房间列表请求(IOS用)
    case channelList2Req(OSPageReq)
    /// 根据菜单随机获取公开厅房间请求
    case publicChannelReq(OSPublicChannelReq)
    /// 首页房间列表请求（最新）
    case channelList3Req(OSLobbyChannelReq)

  }

  public init() {}
}

/// 大厅相关响应
public struct OSLobbyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSLobbyResponse.OneOf_Body? = nil

  /// 首页轮播图响应
  public var bannerRes: OSBannerRes {
    get {
      if case .bannerRes(let v)? = body {return v}
      return OSBannerRes()
    }
    set {body = .bannerRes(newValue)}
  }

  /// 首页房间列表响应
  public var channelListRes: OSChannelListRes {
    get {
      if case .channelListRes(let v)? = body {return v}
      return OSChannelListRes()
    }
    set {body = .channelListRes(newValue)}
  }

  /// 排行榜响应
  public var gloryRanksRes: OSGloryRanksRes {
    get {
      if case .gloryRanksRes(let v)? = body {return v}
      return OSGloryRanksRes()
    }
    set {body = .gloryRanksRes(newValue)}
  }

  /// 菜单响应
  public var menuRes: OSMenuRes {
    get {
      if case .menuRes(let v)? = body {return v}
      return OSMenuRes()
    }
    set {body = .menuRes(newValue)}
  }

  /// 获取首页信息响应
  public var lobbyInfoRes: OSLobbyInfoRes {
    get {
      if case .lobbyInfoRes(let v)? = body {return v}
      return OSLobbyInfoRes()
    }
    set {body = .lobbyInfoRes(newValue)}
  }

  /// 优质房间(置顶房间)响应
  public var topChannelListRes: OSTopChannelListRes {
    get {
      if case .topChannelListRes(let v)? = body {return v}
      return OSTopChannelListRes()
    }
    set {body = .topChannelListRes(newValue)}
  }

  /// 首页房间列表响应(IOS用)
  public var channelList2Res: OSChannelList2Res {
    get {
      if case .channelList2Res(let v)? = body {return v}
      return OSChannelList2Res()
    }
    set {body = .channelList2Res(newValue)}
  }

  /// 根据菜单随机获取公开厅房间响应
  public var publicChannelRes: OSPublicChannelRes {
    get {
      if case .publicChannelRes(let v)? = body {return v}
      return OSPublicChannelRes()
    }
    set {body = .publicChannelRes(newValue)}
  }

  /// 首页房间列表请求（最新）
  public var channelList3Res: OSChannelList3Res {
    get {
      if case .channelList3Res(let v)? = body {return v}
      return OSChannelList3Res()
    }
    set {body = .channelList3Res(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 首页轮播图响应
    case bannerRes(OSBannerRes)
    /// 首页房间列表响应
    case channelListRes(OSChannelListRes)
    /// 排行榜响应
    case gloryRanksRes(OSGloryRanksRes)
    /// 菜单响应
    case menuRes(OSMenuRes)
    /// 获取首页信息响应
    case lobbyInfoRes(OSLobbyInfoRes)
    /// 优质房间(置顶房间)响应
    case topChannelListRes(OSTopChannelListRes)
    /// 首页房间列表响应(IOS用)
    case channelList2Res(OSChannelList2Res)
    /// 根据菜单随机获取公开厅房间响应
    case publicChannelRes(OSPublicChannelRes)
    /// 首页房间列表请求（最新）
    case channelList3Res(OSChannelList3Res)

  }

  public init() {}
}

/// 首页轮播图响应
public struct OSBannerRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 轮播图信息
  public var records: [OSBannerRecord] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 轮播图信息
public struct OSBannerRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 轮播图id
  public var id: Int32 = 0

  /// 轮播图名称
  public var barnerTitle: String = String()

  /// 跳转类型,1:房间 2：浏览器 3：荣耀榜
  public var barnerLinkType: Int32 = 0

  /// 跳转内容
  public var barnerLinkValue: String = String()

  /// 图片地址
  public var barnerImgURL: String = String()

  /// 状态
  public var status: Int32 = 0

  /// 排序
  public var sort: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 首页房间列表响应
public struct OSChannelListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 房间列表数据
  public var records: [OSChannelList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间列表数据
public struct OSChannelList: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间号,展示用
  public var channelNo: Int32 {
    get {return _storage._channelNo}
    set {_uniqueStorage()._channelNo = newValue}
  }

  /// 房间id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 房间名称
  public var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  /// 头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 类型
  public var channelType: OSChannelType {
    get {return _storage._channelType}
    set {_uniqueStorage()._channelType = newValue}
  }

  /// 房主id
  public var ownerID: String {
    get {return _storage._ownerID}
    set {_uniqueStorage()._ownerID = newValue}
  }

  /// 在线人数
  public var onlineNumber: Int32 {
    get {return _storage._onlineNumber}
    set {_uniqueStorage()._onlineNumber = newValue}
  }

  /// 是否上锁 0:未上锁 1:已上锁
  public var lockedStatus: Int32 {
    get {return _storage._lockedStatus}
    set {_uniqueStorage()._lockedStatus = newValue}
  }

  /// 房间背景(可为空)
  public var coverURL: String {
    get {return _storage._coverURL}
    set {_uniqueStorage()._coverURL = newValue}
  }

  /// 房间角标(可为空)（过时）
  public var cornerBg: String {
    get {return _storage._cornerBg}
    set {_uniqueStorage()._cornerBg = newValue}
  }

  /// 角标文案(可为空)（过时）
  public var cornerContent: String {
    get {return _storage._cornerContent}
    set {_uniqueStorage()._cornerContent = newValue}
  }

  /// 麦位用户信息
  public var userInSeats: [OSUserInSeats] {
    get {return _storage._userInSeats}
    set {_uniqueStorage()._userInSeats = newValue}
  }

  /// pk状态 0无pk 1正在pk
  public var pkStatus: Int32 {
    get {return _storage._pkStatus}
    set {_uniqueStorage()._pkStatus = newValue}
  }

  /// 标签名
  public var labelName: String {
    get {return _storage._labelName}
    set {_uniqueStorage()._labelName = newValue}
  }

  /// 房间角标背景(可为空)
  public var labelBackgroundImg: String {
    get {return _storage._labelBackgroundImg}
    set {_uniqueStorage()._labelBackgroundImg = newValue}
  }

  ///房主昵称
  public var ownerNickname: String {
    get {return _storage._ownerNickname}
    set {_uniqueStorage()._ownerNickname = newValue}
  }

  /// 房主头像地址
  public var ownerAvatarURL: String {
    get {return _storage._ownerAvatarURL}
    set {_uniqueStorage()._ownerAvatarURL = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct OSLobbyChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 第几页
  public var current: Int32 = 0

  /// 页大小
  public var size: Int32 = 0

  ///菜单id
  public var menuid: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 首页房间列表响应(IOS用)
public struct OSChannelList2Res: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 房间列表数据
  public var records: [OSChannelList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 首页房间列表响应
public struct OSChannelList3Res: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 房间列表数据
  public var records: [OSChannelList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 排行榜请求
public struct OSGloryRanksReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 排行榜类型
  public var searchType: OSLobbyRankType = .charmRank

  /// 时间范围类型
  public var dateRangeType: OSLobbyRankDateRange = .dayRange

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 排行榜响应
public struct OSGloryRanksRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户排行榜列表
  public var ranks: [OSRank] = []

  /// 个人排行榜
  public var myRank: OSRank {
    get {return _myRank ?? OSRank()}
    set {_myRank = newValue}
  }
  /// Returns true if `myRank` has been explicitly set.
  public var hasMyRank: Bool {return self._myRank != nil}
  /// Clears the value of `myRank`. Subsequent reads from it will return its default value.
  public mutating func clearMyRank() {self._myRank = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _myRank: OSRank? = nil
}

/// 用户排名信息
public struct OSRank: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 排名
  public var rank: Int32 = 0

  /// 用户昵称、房间昵称
  public var name: String = String()

  /// 房间id
  public var channelID: String = String()

  /// 用户Id
  public var userID: String = String()

  /// yoni号，魅力、财富榜返回
  public var accountID: Int32 = 0

  /// 用户头像地址、房间头像地址
  public var avatarURL: String = String()

  /// 魅力值/财富值
  public var gloryValue: Int64 = 0

  /// 个人排名
  public var selfRank: String = String()

  /// 房间密码
  public var channelPwd: String = String()

  /// 是否是密码房(0:不是 1:是)
  public var lockedStatus: Int32 = 0

  /// 钻石数量
  public var diamondValue: Int32 = 0

  /// 计算日期
  public var computeTime: String = String()

  /// 是否显示个人排名 0：不显示 1：显示
  public var display: Int32 = 0

  /// 是否上榜，0：未上榜，1：上榜 用来区分魅力值文案
  public var onList: Int32 = 0

  /// 与上一名相差多少/距上榜还差多少,用户自己排名时才返回
  public var gapGloryValue: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 菜单请求
public struct OSMenuReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 菜单响应
public struct OSMenuRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 父菜单列表
  public var menuList: [OSMenu] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 菜单信息
public struct OSMenu: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 菜单id
  public var menuID: Int32 = 0

  /// 菜单名称
  public var name: String = String()

  /// 图标
  public var iconURL: String = String()

  /// 房间模式
  public var menuClass: OSChannelType = .unkown

  /// 描述
  public var description_p: String = String()

  /// 子菜单列表
  public var children: [OSMenu] = []

  /// 图标2
  public var iconURL2: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取首页信息请求
public struct OSLobbyInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取首页信息响应
public struct OSLobbyInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 菜单列表
  public var lobbyMenu: [OSLobbyMenu] = []

  /// 排行榜列表
  public var wealthRanks: [OSGloryRank] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 菜单信息
public struct OSLobbyMenu: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 菜单id
  public var menuid: Int32 = 0

  /// 模式
  public var menuclass: String = String()

  /// 菜单名称
  public var menudesc: String = String()

  /// 图标
  public var iconURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 排行榜信息
public struct OSGloryRank: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户账号
  public var accountID: Int32 = 0

  /// 用户昵称
  public var name: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 排名
  public var rank: Int32 = 0

  /// 财富值/魅力值
  public var gloryValue: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 置顶房间请求
public struct OSTopChannelListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 置顶房间响应
public struct OSTopChannelListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间列表
  public var channelList: [OSChannelList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 根据菜单随机获取公开厅房间请求
public struct OSPublicChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 菜单id
  public var menuID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 根据菜单随机获取公开厅房间响应
public struct OSPublicChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSLobbyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bannerReq"),
    2: .same(proto: "channelListReq"),
    3: .same(proto: "gloryRanksReq"),
    4: .same(proto: "menuReq"),
    5: .same(proto: "lobbyInfoReq"),
    6: .same(proto: "topChannelListReq"),
    7: .same(proto: "channelList2Req"),
    8: .same(proto: "publicChannelReq"),
    9: .same(proto: "channelList3Req"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSPageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .bannerReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .bannerReq(v)
        }
      }()
      case 2: try {
        var v: OSPageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelListReq(v)
        }
      }()
      case 3: try {
        var v: OSGloryRanksReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .gloryRanksReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .gloryRanksReq(v)
        }
      }()
      case 4: try {
        var v: OSMenuReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .menuReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .menuReq(v)
        }
      }()
      case 5: try {
        var v: OSLobbyInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lobbyInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lobbyInfoReq(v)
        }
      }()
      case 6: try {
        var v: OSTopChannelListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .topChannelListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .topChannelListReq(v)
        }
      }()
      case 7: try {
        var v: OSPageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelList2Req(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelList2Req(v)
        }
      }()
      case 8: try {
        var v: OSPublicChannelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .publicChannelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .publicChannelReq(v)
        }
      }()
      case 9: try {
        var v: OSLobbyChannelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelList3Req(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelList3Req(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .bannerReq?: try {
      guard case .bannerReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .channelListReq?: try {
      guard case .channelListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .gloryRanksReq?: try {
      guard case .gloryRanksReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .menuReq?: try {
      guard case .menuReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .lobbyInfoReq?: try {
      guard case .lobbyInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .topChannelListReq?: try {
      guard case .topChannelListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .channelList2Req?: try {
      guard case .channelList2Req(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .publicChannelReq?: try {
      guard case .publicChannelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .channelList3Req?: try {
      guard case .channelList3Req(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyRequest, rhs: OSLobbyRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLobbyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bannerRes"),
    2: .same(proto: "channelListRes"),
    3: .same(proto: "gloryRanksRes"),
    4: .same(proto: "menuRes"),
    5: .same(proto: "lobbyInfoRes"),
    6: .same(proto: "TopChannelListRes"),
    7: .same(proto: "channelList2Res"),
    8: .same(proto: "publicChannelRes"),
    9: .same(proto: "channelList3Res"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSBannerRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .bannerRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .bannerRes(v)
        }
      }()
      case 2: try {
        var v: OSChannelListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelListRes(v)
        }
      }()
      case 3: try {
        var v: OSGloryRanksRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .gloryRanksRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .gloryRanksRes(v)
        }
      }()
      case 4: try {
        var v: OSMenuRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .menuRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .menuRes(v)
        }
      }()
      case 5: try {
        var v: OSLobbyInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lobbyInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lobbyInfoRes(v)
        }
      }()
      case 6: try {
        var v: OSTopChannelListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .topChannelListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .topChannelListRes(v)
        }
      }()
      case 7: try {
        var v: OSChannelList2Res?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelList2Res(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelList2Res(v)
        }
      }()
      case 8: try {
        var v: OSPublicChannelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .publicChannelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .publicChannelRes(v)
        }
      }()
      case 9: try {
        var v: OSChannelList3Res?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelList3Res(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelList3Res(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .bannerRes?: try {
      guard case .bannerRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .channelListRes?: try {
      guard case .channelListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .gloryRanksRes?: try {
      guard case .gloryRanksRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .menuRes?: try {
      guard case .menuRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .lobbyInfoRes?: try {
      guard case .lobbyInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .topChannelListRes?: try {
      guard case .topChannelListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .channelList2Res?: try {
      guard case .channelList2Res(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .publicChannelRes?: try {
      guard case .publicChannelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .channelList3Res?: try {
      guard case .channelList3Res(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyResponse, rhs: OSLobbyResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBannerRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BannerRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBannerRes, rhs: OSBannerRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBannerRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BannerRecord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "barnerTitle"),
    3: .same(proto: "barnerLinkType"),
    4: .same(proto: "barnerLinkValue"),
    5: .same(proto: "barnerImgUrl"),
    6: .same(proto: "status"),
    7: .same(proto: "sort"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.barnerTitle) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.barnerLinkType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.barnerLinkValue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.barnerImgURL) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.sort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.barnerTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.barnerTitle, fieldNumber: 2)
    }
    if self.barnerLinkType != 0 {
      try visitor.visitSingularInt32Field(value: self.barnerLinkType, fieldNumber: 3)
    }
    if !self.barnerLinkValue.isEmpty {
      try visitor.visitSingularStringField(value: self.barnerLinkValue, fieldNumber: 4)
    }
    if !self.barnerImgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.barnerImgURL, fieldNumber: 5)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 6)
    }
    if self.sort != 0 {
      try visitor.visitSingularInt32Field(value: self.sort, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBannerRecord, rhs: OSBannerRecord) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.barnerTitle != rhs.barnerTitle {return false}
    if lhs.barnerLinkType != rhs.barnerLinkType {return false}
    if lhs.barnerLinkValue != rhs.barnerLinkValue {return false}
    if lhs.barnerImgURL != rhs.barnerImgURL {return false}
    if lhs.status != rhs.status {return false}
    if lhs.sort != rhs.sort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelListRes, rhs: OSChannelListRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelNo"),
    2: .same(proto: "channelId"),
    3: .same(proto: "channelName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "channelType"),
    6: .same(proto: "ownerId"),
    7: .same(proto: "onlineNumber"),
    8: .same(proto: "lockedStatus"),
    10: .same(proto: "coverUrl"),
    11: .same(proto: "cornerBg"),
    13: .same(proto: "cornerContent"),
    12: .same(proto: "userInSeats"),
    14: .same(proto: "pkStatus"),
    9: .same(proto: "labelName"),
    15: .same(proto: "labelBackgroundImg"),
    16: .same(proto: "ownerNickname"),
    17: .same(proto: "ownerAvatarUrl"),
  ]

  fileprivate class _StorageClass {
    var _channelNo: Int32 = 0
    var _channelID: String = String()
    var _channelName: String = String()
    var _avatarURL: String = String()
    var _channelType: OSChannelType = .unkown
    var _ownerID: String = String()
    var _onlineNumber: Int32 = 0
    var _lockedStatus: Int32 = 0
    var _coverURL: String = String()
    var _cornerBg: String = String()
    var _cornerContent: String = String()
    var _userInSeats: [OSUserInSeats] = []
    var _pkStatus: Int32 = 0
    var _labelName: String = String()
    var _labelBackgroundImg: String = String()
    var _ownerNickname: String = String()
    var _ownerAvatarURL: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _channelNo = source._channelNo
      _channelID = source._channelID
      _channelName = source._channelName
      _avatarURL = source._avatarURL
      _channelType = source._channelType
      _ownerID = source._ownerID
      _onlineNumber = source._onlineNumber
      _lockedStatus = source._lockedStatus
      _coverURL = source._coverURL
      _cornerBg = source._cornerBg
      _cornerContent = source._cornerContent
      _userInSeats = source._userInSeats
      _pkStatus = source._pkStatus
      _labelName = source._labelName
      _labelBackgroundImg = source._labelBackgroundImg
      _ownerNickname = source._ownerNickname
      _ownerAvatarURL = source._ownerAvatarURL
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._channelNo) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._channelName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._channelType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._ownerID) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._onlineNumber) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._lockedStatus) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._labelName) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._coverURL) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._cornerBg) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._userInSeats) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._cornerContent) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._pkStatus) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._labelBackgroundImg) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._ownerNickname) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._ownerAvatarURL) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._channelNo != 0 {
        try visitor.visitSingularInt32Field(value: _storage._channelNo, fieldNumber: 1)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 2)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if _storage._channelType != .unkown {
        try visitor.visitSingularEnumField(value: _storage._channelType, fieldNumber: 5)
      }
      if !_storage._ownerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerID, fieldNumber: 6)
      }
      if _storage._onlineNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._onlineNumber, fieldNumber: 7)
      }
      if _storage._lockedStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lockedStatus, fieldNumber: 8)
      }
      if !_storage._labelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelName, fieldNumber: 9)
      }
      if !_storage._coverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._coverURL, fieldNumber: 10)
      }
      if !_storage._cornerBg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cornerBg, fieldNumber: 11)
      }
      if !_storage._userInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userInSeats, fieldNumber: 12)
      }
      if !_storage._cornerContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cornerContent, fieldNumber: 13)
      }
      if _storage._pkStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pkStatus, fieldNumber: 14)
      }
      if !_storage._labelBackgroundImg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelBackgroundImg, fieldNumber: 15)
      }
      if !_storage._ownerNickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerNickname, fieldNumber: 16)
      }
      if !_storage._ownerAvatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ownerAvatarURL, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelList, rhs: OSChannelList) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelNo != rhs_storage._channelNo {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._channelName != rhs_storage._channelName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._channelType != rhs_storage._channelType {return false}
        if _storage._ownerID != rhs_storage._ownerID {return false}
        if _storage._onlineNumber != rhs_storage._onlineNumber {return false}
        if _storage._lockedStatus != rhs_storage._lockedStatus {return false}
        if _storage._coverURL != rhs_storage._coverURL {return false}
        if _storage._cornerBg != rhs_storage._cornerBg {return false}
        if _storage._cornerContent != rhs_storage._cornerContent {return false}
        if _storage._userInSeats != rhs_storage._userInSeats {return false}
        if _storage._pkStatus != rhs_storage._pkStatus {return false}
        if _storage._labelName != rhs_storage._labelName {return false}
        if _storage._labelBackgroundImg != rhs_storage._labelBackgroundImg {return false}
        if _storage._ownerNickname != rhs_storage._ownerNickname {return false}
        if _storage._ownerAvatarURL != rhs_storage._ownerAvatarURL {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLobbyChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "menuid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.menuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.menuid != 0 {
      try visitor.visitSingularInt32Field(value: self.menuid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyChannelReq, rhs: OSLobbyChannelReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.menuid != rhs.menuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelList2Res: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelList2Res"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelList2Res, rhs: OSChannelList2Res) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelList3Res: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelList3Res"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelList3Res, rhs: OSChannelList3Res) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGloryRanksReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GloryRanksReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "searchType"),
    2: .same(proto: "dateRangeType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.searchType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dateRangeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.searchType != .charmRank {
      try visitor.visitSingularEnumField(value: self.searchType, fieldNumber: 1)
    }
    if self.dateRangeType != .dayRange {
      try visitor.visitSingularEnumField(value: self.dateRangeType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGloryRanksReq, rhs: OSGloryRanksReq) -> Bool {
    if lhs.searchType != rhs.searchType {return false}
    if lhs.dateRangeType != rhs.dateRangeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGloryRanksRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GloryRanksRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ranks"),
    2: .same(proto: "myRank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._myRank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ranks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranks, fieldNumber: 1)
    }
    try { if let v = self._myRank {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGloryRanksRes, rhs: OSGloryRanksRes) -> Bool {
    if lhs.ranks != rhs.ranks {return false}
    if lhs._myRank != rhs._myRank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRank: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rank"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rank"),
    2: .same(proto: "name"),
    3: .same(proto: "channelId"),
    4: .same(proto: "userId"),
    5: .same(proto: "accountId"),
    6: .same(proto: "avatarUrl"),
    7: .same(proto: "gloryValue"),
    8: .same(proto: "selfRank"),
    9: .same(proto: "channelPwd"),
    10: .same(proto: "lockedStatus"),
    11: .same(proto: "diamondValue"),
    12: .same(proto: "computeTime"),
    13: .same(proto: "display"),
    14: .same(proto: "onList"),
    15: .same(proto: "gapGloryValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.gloryValue) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.selfRank) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.channelPwd) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.diamondValue) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.computeTime) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.display) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.onList) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.gapGloryValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rank != 0 {
      try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    if self.gloryValue != 0 {
      try visitor.visitSingularInt64Field(value: self.gloryValue, fieldNumber: 7)
    }
    if !self.selfRank.isEmpty {
      try visitor.visitSingularStringField(value: self.selfRank, fieldNumber: 8)
    }
    if !self.channelPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPwd, fieldNumber: 9)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 10)
    }
    if self.diamondValue != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondValue, fieldNumber: 11)
    }
    if !self.computeTime.isEmpty {
      try visitor.visitSingularStringField(value: self.computeTime, fieldNumber: 12)
    }
    if self.display != 0 {
      try visitor.visitSingularInt32Field(value: self.display, fieldNumber: 13)
    }
    if self.onList != 0 {
      try visitor.visitSingularInt32Field(value: self.onList, fieldNumber: 14)
    }
    if self.gapGloryValue != 0 {
      try visitor.visitSingularInt64Field(value: self.gapGloryValue, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRank, rhs: OSRank) -> Bool {
    if lhs.rank != rhs.rank {return false}
    if lhs.name != rhs.name {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gloryValue != rhs.gloryValue {return false}
    if lhs.selfRank != rhs.selfRank {return false}
    if lhs.channelPwd != rhs.channelPwd {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.diamondValue != rhs.diamondValue {return false}
    if lhs.computeTime != rhs.computeTime {return false}
    if lhs.display != rhs.display {return false}
    if lhs.onList != rhs.onList {return false}
    if lhs.gapGloryValue != rhs.gapGloryValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMenuReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMenuReq, rhs: OSMenuReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMenuRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.menuList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.menuList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.menuList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMenuRes, rhs: OSMenuRes) -> Bool {
    if lhs.menuList != rhs.menuList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMenu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Menu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuId"),
    2: .same(proto: "name"),
    3: .same(proto: "iconUrl"),
    4: .same(proto: "menuClass"),
    5: .same(proto: "description"),
    6: .same(proto: "children"),
    7: .same(proto: "iconUrl2"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.menuClass) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.children) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.iconURL2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuID != 0 {
      try visitor.visitSingularInt32Field(value: self.menuID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 3)
    }
    if self.menuClass != .unkown {
      try visitor.visitSingularEnumField(value: self.menuClass, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.children.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.children, fieldNumber: 6)
    }
    if !self.iconURL2.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL2, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMenu, rhs: OSMenu) -> Bool {
    if lhs.menuID != rhs.menuID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.menuClass != rhs.menuClass {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.children != rhs.children {return false}
    if lhs.iconURL2 != rhs.iconURL2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLobbyInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyInfoReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyInfoReq, rhs: OSLobbyInfoReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLobbyInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lobbyMenu"),
    2: .same(proto: "wealthRanks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.lobbyMenu) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.wealthRanks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lobbyMenu.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lobbyMenu, fieldNumber: 1)
    }
    if !self.wealthRanks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.wealthRanks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyInfoRes, rhs: OSLobbyInfoRes) -> Bool {
    if lhs.lobbyMenu != rhs.lobbyMenu {return false}
    if lhs.wealthRanks != rhs.wealthRanks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLobbyMenu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyMenu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuid"),
    2: .same(proto: "menuclass"),
    3: .same(proto: "menudesc"),
    4: .same(proto: "iconUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.menuclass) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.menudesc) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuid != 0 {
      try visitor.visitSingularInt32Field(value: self.menuid, fieldNumber: 1)
    }
    if !self.menuclass.isEmpty {
      try visitor.visitSingularStringField(value: self.menuclass, fieldNumber: 2)
    }
    if !self.menudesc.isEmpty {
      try visitor.visitSingularStringField(value: self.menudesc, fieldNumber: 3)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyMenu, rhs: OSLobbyMenu) -> Bool {
    if lhs.menuid != rhs.menuid {return false}
    if lhs.menuclass != rhs.menuclass {return false}
    if lhs.menudesc != rhs.menudesc {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGloryRank: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GloryRank"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "name"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "rank"),
    6: .same(proto: "gloryValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.gloryValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 5)
    }
    if self.gloryValue != 0 {
      try visitor.visitSingularInt32Field(value: self.gloryValue, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGloryRank, rhs: OSGloryRank) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.gloryValue != rhs.gloryValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTopChannelListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopChannelListReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTopChannelListReq, rhs: OSTopChannelListReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTopChannelListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopChannelListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channelList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTopChannelListRes, rhs: OSTopChannelListRes) -> Bool {
    if lhs.channelList != rhs.channelList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPublicChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuID != 0 {
      try visitor.visitSingularInt32Field(value: self.menuID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPublicChannelReq, rhs: OSPublicChannelReq) -> Bool {
    if lhs.menuID != rhs.menuID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPublicChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicChannelRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPublicChannelRes, rhs: OSPublicChannelRes) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
