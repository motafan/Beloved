// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_channel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 房间相关请求
public struct OSChannelRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSChannelRequest.OneOf_Body? = nil

  /// 创建房间请求
  public var createReq: OSCreateReq {
    get {
      if case .createReq(let v)? = body {return v}
      return OSCreateReq()
    }
    set {body = .createReq(newValue)}
  }

  /// 加入房间请求
  public var joinReq: OSJoinReq {
    get {
      if case .joinReq(let v)? = body {return v}
      return OSJoinReq()
    }
    set {body = .joinReq(newValue)}
  }

  /// 回到房间请求
  public var backReq: OSBackReq {
    get {
      if case .backReq(let v)? = body {return v}
      return OSBackReq()
    }
    set {body = .backReq(newValue)}
  }

  /// 退出房间请求
  public var exitReq: OSExitReq {
    get {
      if case .exitReq(let v)? = body {return v}
      return OSExitReq()
    }
    set {body = .exitReq(newValue)}
  }

  /// 房间实时信息请求(房间每5秒轮询)
  public var realTimeInfoReq: OSRealTimeInfoReq {
    get {
      if case .realTimeInfoReq(let v)? = body {return v}
      return OSRealTimeInfoReq()
    }
    set {body = .realTimeInfoReq(newValue)}
  }

  /// 心跳请求(房间每20秒轮询)
  public var onlineReportReq: OSOnlineReportReq {
    get {
      if case .onlineReportReq(let v)? = body {return v}
      return OSOnlineReportReq()
    }
    set {body = .onlineReportReq(newValue)}
  }

  /// 房间详情请求
  public var detailReq: OSDetailReq {
    get {
      if case .detailReq(let v)? = body {return v}
      return OSDetailReq()
    }
    set {body = .detailReq(newValue)}
  }

  /// 编辑房间信息请求
  public var editChannelReq: OSEditChannelReq {
    get {
      if case .editChannelReq(let v)? = body {return v}
      return OSEditChannelReq()
    }
    set {body = .editChannelReq(newValue)}
  }

  /// 礼物栏标签列表请求
  public var tagsReq: OSTagsReq {
    get {
      if case .tagsReq(let v)? = body {return v}
      return OSTagsReq()
    }
    set {body = .tagsReq(newValue)}
  }

  /// 礼物/福袋/背包列表请求
  public var giftListReq: OSGiftListReq {
    get {
      if case .giftListReq(let v)? = body {return v}
      return OSGiftListReq()
    }
    set {body = .giftListReq(newValue)}
  }

  /// 房间内查看用户信息请求
  public var viewInfoReq: OSViewInfoReq {
    get {
      if case .viewInfoReq(let v)? = body {return v}
      return OSViewInfoReq()
    }
    set {body = .viewInfoReq(newValue)}
  }

  /// 上麦请求
  public var pickUpMicroPhoneReq: OSPickUpMicroPhoneReq {
    get {
      if case .pickUpMicroPhoneReq(let v)? = body {return v}
      return OSPickUpMicroPhoneReq()
    }
    set {body = .pickUpMicroPhoneReq(newValue)}
  }

  /// 强制上麦请求
  public var pickUpMicroPhoneCompelReq: OSPickUpMicroPhoneCompelReq {
    get {
      if case .pickUpMicroPhoneCompelReq(let v)? = body {return v}
      return OSPickUpMicroPhoneCompelReq()
    }
    set {body = .pickUpMicroPhoneCompelReq(newValue)}
  }

  /// 下麦请求
  public var putDownMicroPhoneReq: OSPutDownMicroPhoneReq {
    get {
      if case .putDownMicroPhoneReq(let v)? = body {return v}
      return OSPutDownMicroPhoneReq()
    }
    set {body = .putDownMicroPhoneReq(newValue)}
  }

  /// 换麦请求
  public var exchangeMicroPhoneReq: OSExchangeMicroPhoneReq {
    get {
      if case .exchangeMicroPhoneReq(let v)? = body {return v}
      return OSExchangeMicroPhoneReq()
    }
    set {body = .exchangeMicroPhoneReq(newValue)}
  }

  /// 禁言(不能发公屏)请求
  public var wordsNotAllowedReq: OSWordsNotAllowedReq {
    get {
      if case .wordsNotAllowedReq(let v)? = body {return v}
      return OSWordsNotAllowedReq()
    }
    set {body = .wordsNotAllowedReq(newValue)}
  }

  /// 解除禁言(允许发公屏)请求
  public var wordsAllowedReq: OSWordsAllowedReq {
    get {
      if case .wordsAllowedReq(let v)? = body {return v}
      return OSWordsAllowedReq()
    }
    set {body = .wordsAllowedReq(newValue)}
  }

  /// 麦位锁状态相关
  public var lockMicroPhoneReq: OSLockMicroPhoneReq {
    get {
      if case .lockMicroPhoneReq(let v)? = body {return v}
      return OSLockMicroPhoneReq()
    }
    set {body = .lockMicroPhoneReq(newValue)}
  }

  /// 麦位状态相关1------解锁麦位请求
  public var unLockMicrophoneReq: OSUnLockMicrophoneReq {
    get {
      if case .unLockMicrophoneReq(let v)? = body {return v}
      return OSUnLockMicrophoneReq()
    }
    set {body = .unLockMicrophoneReq(newValue)}
  }

  /// 麦位状态相关0------锁定全部麦位请求(一键锁麦)
  public var lockAllMicrophoneReq: OSLockAllMicrophoneReq {
    get {
      if case .lockAllMicrophoneReq(let v)? = body {return v}
      return OSLockAllMicrophoneReq()
    }
    set {body = .lockAllMicrophoneReq(newValue)}
  }

  /// 麦位状态相关1------解锁全部麦位请求(一键解麦)
  public var unLockAllMicrophoneReq: OSUnLockAllMicrophoneReq {
    get {
      if case .unLockAllMicrophoneReq(let v)? = body {return v}
      return OSUnLockAllMicrophoneReq()
    }
    set {body = .unLockAllMicrophoneReq(newValue)}
  }

  /// 麦位状态相关3------闭麦请求
  public var lockSeatVoiceReq: OSLockSeatVoiceReq {
    get {
      if case .lockSeatVoiceReq(let v)? = body {return v}
      return OSLockSeatVoiceReq()
    }
    set {body = .lockSeatVoiceReq(newValue)}
  }

  /// 麦位状态相关1------解除闭麦请求
  public var unLockSeatVoiceReq: OSUnLockSeatVoiceReq {
    get {
      if case .unLockSeatVoiceReq(let v)? = body {return v}
      return OSUnLockSeatVoiceReq()
    }
    set {body = .unLockSeatVoiceReq(newValue)}
  }

  /// 抱麦请求
  public var holdOnMicroPhoneReq: OSHoldOnMicroPhoneReq {
    get {
      if case .holdOnMicroPhoneReq(let v)? = body {return v}
      return OSHoldOnMicroPhoneReq()
    }
    set {body = .holdOnMicroPhoneReq(newValue)}
  }

  /// 踢出房间请求
  public var kickYouOutReq: OSKickYouOutReq {
    get {
      if case .kickYouOutReq(let v)? = body {return v}
      return OSKickYouOutReq()
    }
    set {body = .kickYouOutReq(newValue)}
  }

  /// 设置为超级管理员请求
  public var setSuperAdminReq: OSSetSuperAdminReq {
    get {
      if case .setSuperAdminReq(let v)? = body {return v}
      return OSSetSuperAdminReq()
    }
    set {body = .setSuperAdminReq(newValue)}
  }

  /// 取消超级管理员请求
  public var cancelSuperAdminReq: OSCancelSuperAdminReq {
    get {
      if case .cancelSuperAdminReq(let v)? = body {return v}
      return OSCancelSuperAdminReq()
    }
    set {body = .cancelSuperAdminReq(newValue)}
  }

  /// 设置为管理员请求
  public var setAdminReq: OSSetAdminReq {
    get {
      if case .setAdminReq(let v)? = body {return v}
      return OSSetAdminReq()
    }
    set {body = .setAdminReq(newValue)}
  }

  /// 取消管理员请求
  public var cancelAdminReq: OSCancelAdminReq {
    get {
      if case .cancelAdminReq(let v)? = body {return v}
      return OSCancelAdminReq()
    }
    set {body = .cancelAdminReq(newValue)}
  }

  /// 切换麦位布局请求
  public var exchangeSeatLayoutReq: OSExchangeSeatLayoutReq {
    get {
      if case .exchangeSeatLayoutReq(let v)? = body {return v}
      return OSExchangeSeatLayoutReq()
    }
    set {body = .exchangeSeatLayoutReq(newValue)}
  }

  /// 关闭公屏请求
  public var wordsNotAllowedAllReq: OSWordsNotAllowedAllReq {
    get {
      if case .wordsNotAllowedAllReq(let v)? = body {return v}
      return OSWordsNotAllowedAllReq()
    }
    set {body = .wordsNotAllowedAllReq(newValue)}
  }

  /// 开启公屏请求
  public var wordsAllowedAllReq: OSWordsAllowedAllReq {
    get {
      if case .wordsAllowedAllReq(let v)? = body {return v}
      return OSWordsAllowedAllReq()
    }
    set {body = .wordsAllowedAllReq(newValue)}
  }

  /// 送礼物请求
  public var givePresentsReq: OSGivePresentsReq {
    get {
      if case .givePresentsReq(let v)? = body {return v}
      return OSGivePresentsReq()
    }
    set {body = .givePresentsReq(newValue)}
  }

  /// 送福袋请求
  public var giveLuckyBagPresentReq: OSGiveLuckyBagPresentReq {
    get {
      if case .giveLuckyBagPresentReq(let v)? = body {return v}
      return OSGiveLuckyBagPresentReq()
    }
    set {body = .giveLuckyBagPresentReq(newValue)}
  }

  /// 送背包请求
  public var givePresentsUseBackpackReq: OSGivePresentsUseBackpackReq {
    get {
      if case .givePresentsUseBackpackReq(let v)? = body {return v}
      return OSGivePresentsUseBackpackReq()
    }
    set {body = .givePresentsUseBackpackReq(newValue)}
  }

  /// 特权卡列表请求
  public var privilegeCardsReq: OSPrivilegeCardsReq {
    get {
      if case .privilegeCardsReq(let v)? = body {return v}
      return OSPrivilegeCardsReq()
    }
    set {body = .privilegeCardsReq(newValue)}
  }

  /// 使用特权卡请求
  public var usePrivilegeCardReq: OSUsePrivilegeCardReq {
    get {
      if case .usePrivilegeCardReq(let v)? = body {return v}
      return OSUsePrivilegeCardReq()
    }
    set {body = .usePrivilegeCardReq(newValue)}
  }

  /// 开启心动值请求
  public var openLoveNumReq: OSOpenLoveNumReq {
    get {
      if case .openLoveNumReq(let v)? = body {return v}
      return OSOpenLoveNumReq()
    }
    set {body = .openLoveNumReq(newValue)}
  }

  /// 关闭心动值请求
  public var closeLoveNumReq: OSCloseLoveNumReq {
    get {
      if case .closeLoveNumReq(let v)? = body {return v}
      return OSCloseLoveNumReq()
    }
    set {body = .closeLoveNumReq(newValue)}
  }

  /// 房间排行榜请求
  public var channelRankingsReq: OSChannelRankingsReq {
    get {
      if case .channelRankingsReq(let v)? = body {return v}
      return OSChannelRankingsReq()
    }
    set {body = .channelRankingsReq(newValue)}
  }

  /// 设置公告请求
  public var announcementSettingReq: OSAnnouncementSettingReq {
    get {
      if case .announcementSettingReq(let v)? = body {return v}
      return OSAnnouncementSettingReq()
    }
    set {body = .announcementSettingReq(newValue)}
  }

  /// 在线用户列表请求
  public var onlineUserReq: OSOnlineUserReq {
    get {
      if case .onlineUserReq(let v)? = body {return v}
      return OSOnlineUserReq()
    }
    set {body = .onlineUserReq(newValue)}
  }

  /// PK话题列表请求
  public var pkTopicsReq: OSPkTopicsReq {
    get {
      if case .pkTopicsReq(let v)? = body {return v}
      return OSPkTopicsReq()
    }
    set {body = .pkTopicsReq(newValue)}
  }

  /// 创建PK请求
  public var createPkGameReq: OSCreatePkGameReq {
    get {
      if case .createPkGameReq(let v)? = body {return v}
      return OSCreatePkGameReq()
    }
    set {body = .createPkGameReq(newValue)}
  }

  /// 搜索PK房间请求
  public var searchPkChannelReq: OSSearchPkChannelReq {
    get {
      if case .searchPkChannelReq(let v)? = body {return v}
      return OSSearchPkChannelReq()
    }
    set {body = .searchPkChannelReq(newValue)}
  }

  /// 发起跨厅PK请求
  public var askChannelPkReq: OSAskChannelPkReq {
    get {
      if case .askChannelPkReq(let v)? = body {return v}
      return OSAskChannelPkReq()
    }
    set {body = .askChannelPkReq(newValue)}
  }

  /// 接受跨厅PK请求
  public var acceptChannelPkReq: OSAcceptChannelPkReq {
    get {
      if case .acceptChannelPkReq(let v)? = body {return v}
      return OSAcceptChannelPkReq()
    }
    set {body = .acceptChannelPkReq(newValue)}
  }

  /// 拒绝跨厅PK请求
  public var refuseChannelPkReq: OSRefuseChannelPkReq {
    get {
      if case .refuseChannelPkReq(let v)? = body {return v}
      return OSRefuseChannelPkReq()
    }
    set {body = .refuseChannelPkReq(newValue)}
  }

  /// 停止PK请求
  public var stopPkGameReq: OSStopPkGameReq {
    get {
      if case .stopPkGameReq(let v)? = body {return v}
      return OSStopPkGameReq()
    }
    set {body = .stopPkGameReq(newValue)}
  }

  /// PK记录请求
  public var pkLogReq: OSPkLogReq {
    get {
      if case .pkLogReq(let v)? = body {return v}
      return OSPkLogReq()
    }
    set {body = .pkLogReq(newValue)}
  }

  /// 随机房间名称请求
  public var randomChannelNameReq: OSRandomChannelNameReq {
    get {
      if case .randomChannelNameReq(let v)? = body {return v}
      return OSRandomChannelNameReq()
    }
    set {body = .randomChannelNameReq(newValue)}
  }

  /// 房间礼物墙请求
  public var channelGiftWallReq: OSChannelGiftWallReq {
    get {
      if case .channelGiftWallReq(let v)? = body {return v}
      return OSChannelGiftWallReq()
    }
    set {body = .channelGiftWallReq(newValue)}
  }

  /// 加入房间黑名单请求
  public var joinChannelBlackListReq: OSJoinChannelBlackListReq {
    get {
      if case .joinChannelBlackListReq(let v)? = body {return v}
      return OSJoinChannelBlackListReq()
    }
    set {body = .joinChannelBlackListReq(newValue)}
  }

  /// 取消房间黑名单请求
  public var removeChannelBlackListReq: OSRemoveChannelBlackListReq {
    get {
      if case .removeChannelBlackListReq(let v)? = body {return v}
      return OSRemoveChannelBlackListReq()
    }
    set {body = .removeChannelBlackListReq(newValue)}
  }

  /// 房间管理员列表请求
  public var channelAdminListReq: OSChannelAdminListReq {
    get {
      if case .channelAdminListReq(let v)? = body {return v}
      return OSChannelAdminListReq()
    }
    set {body = .channelAdminListReq(newValue)}
  }

  /// 房间黑名单用户列表请求
  public var channelBlackListReq: OSChannelBlackListReq {
    get {
      if case .channelBlackListReq(let v)? = body {return v}
      return OSChannelBlackListReq()
    }
    set {body = .channelBlackListReq(newValue)}
  }

  /// 麦位锁状态相关
  public var turnOntheMicrophoneReq: OSTurnOntheMicrophoneReq {
    get {
      if case .turnOntheMicrophoneReq(let v)? = body {return v}
      return OSTurnOntheMicrophoneReq()
    }
    set {body = .turnOntheMicrophoneReq(newValue)}
  }

  /// 麦位状态相关1------开麦（解锁麦并开麦）
  public var turnOfftheMicrophoneReq: OSTurnOfftheMicrophoneReq {
    get {
      if case .turnOfftheMicrophoneReq(let v)? = body {return v}
      return OSTurnOfftheMicrophoneReq()
    }
    set {body = .turnOfftheMicrophoneReq(newValue)}
  }

  /// 加入房间之后请求
  public var afterJoinReq: OSAfterJoinReq {
    get {
      if case .afterJoinReq(let v)? = body {return v}
      return OSAfterJoinReq()
    }
    set {body = .afterJoinReq(newValue)}
  }

  /// 房间禁言用户列表请求
  public var channelProhibitListReq: OSChannelProhibitListReq {
    get {
      if case .channelProhibitListReq(let v)? = body {return v}
      return OSChannelProhibitListReq()
    }
    set {body = .channelProhibitListReq(newValue)}
  }

  /// 送粉丝团礼物请求
  public var givePresentsFansClubReq: OSGivePresentsFansClubReq {
    get {
      if case .givePresentsFansClubReq(let v)? = body {return v}
      return OSGivePresentsFansClubReq()
    }
    set {body = .givePresentsFansClubReq(newValue)}
  }

  /// 清空心动值请求
  public var emptyLoveNumReq: OSEmptyLoveNumReq {
    get {
      if case .emptyLoveNumReq(let v)? = body {return v}
      return OSEmptyLoveNumReq()
    }
    set {body = .emptyLoveNumReq(newValue)}
  }

  /// 购买动作表情
  public var buyExpressionReq: OSBuyExpressionReq {
    get {
      if case .buyExpressionReq(let v)? = body {return v}
      return OSBuyExpressionReq()
    }
    set {body = .buyExpressionReq(newValue)}
  }

  ///做动作表情
  public var commitExpressionReq: OSCommitExpressionReq {
    get {
      if case .commitExpressionReq(let v)? = body {return v}
      return OSCommitExpressionReq()
    }
    set {body = .commitExpressionReq(newValue)}
  }

  ///加载火箭数据
  public var loadRocketInfoReq: OSLoadRocketInfoReq {
    get {
      if case .loadRocketInfoReq(let v)? = body {return v}
      return OSLoadRocketInfoReq()
    }
    set {body = .loadRocketInfoReq(newValue)}
  }

  ///小时榜数据
  public var hoursListReq: OSHoursListReq {
    get {
      if case .hoursListReq(let v)? = body {return v}
      return OSHoursListReq()
    }
    set {body = .hoursListReq(newValue)}
  }

  ///我的/Ta粉丝团信息请求
  public var myClubReq: OSMyClubReq {
    get {
      if case .myClubReq(let v)? = body {return v}
      return OSMyClubReq()
    }
    set {body = .myClubReq(newValue)}
  }

  ///加入粉丝团请求
  public var joinClubReq: OSJoinClubReq {
    get {
      if case .joinClubReq(let v)? = body {return v}
      return OSJoinClubReq()
    }
    set {body = .joinClubReq(newValue)}
  }

  ///加载动作表情
  public var loadExpressionReq: OSLoadExpressionReq {
    get {
      if case .loadExpressionReq(let v)? = body {return v}
      return OSLoadExpressionReq()
    }
    set {body = .loadExpressionReq(newValue)}
  }

  ///个播房间信息请求
  public var personalChannelInfoReq: OSPersonalChannelInfoReq {
    get {
      if case .personalChannelInfoReq(let v)? = body {return v}
      return OSPersonalChannelInfoReq()
    }
    set {body = .personalChannelInfoReq(newValue)}
  }

  ///设置个播模式观众席状态请求
  public var personalSeatsConfigReq: OSPersonalSeatsConfigReq {
    get {
      if case .personalSeatsConfigReq(let v)? = body {return v}
      return OSPersonalSeatsConfigReq()
    }
    set {body = .personalSeatsConfigReq(newValue)}
  }

  ///设置个播模式直播状态请求
  public var personalLiveConfigReq: OSPersonalLiveConfigReq {
    get {
      if case .personalLiveConfigReq(let v)? = body {return v}
      return OSPersonalLiveConfigReq()
    }
    set {body = .personalLiveConfigReq(newValue)}
  }

  ///获得心愿礼物（查询任务进度)请求
  public var wishGiftInfoReq: OSWishGiftInfoReq {
    get {
      if case .wishGiftInfoReq(let v)? = body {return v}
      return OSWishGiftInfoReq()
    }
    set {body = .wishGiftInfoReq(newValue)}
  }

  ///设置心愿礼物请求
  public var wishGiftConfigReq: OSWishGiftConfigReq {
    get {
      if case .wishGiftConfigReq(let v)? = body {return v}
      return OSWishGiftConfigReq()
    }
    set {body = .wishGiftConfigReq(newValue)}
  }

  ///重启心愿礼物请求
  public var wishGiftRestartReq: OSWishGiftRestartReq {
    get {
      if case .wishGiftRestartReq(let v)? = body {return v}
      return OSWishGiftRestartReq()
    }
    set {body = .wishGiftRestartReq(newValue)}
  }

  ///删除心愿礼物请求
  public var wishGiftDelReq: OSWishGiftDelReq {
    get {
      if case .wishGiftDelReq(let v)? = body {return v}
      return OSWishGiftDelReq()
    }
    set {body = .wishGiftDelReq(newValue)}
  }

  ///获取用户娱乐玩法相关信息请求
  public var userPlayInfoReq: OSUserPlayInfoReq {
    get {
      if case .userPlayInfoReq(let v)? = body {return v}
      return OSUserPlayInfoReq()
    }
    set {body = .userPlayInfoReq(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 创建房间请求
    case createReq(OSCreateReq)
    /// 加入房间请求
    case joinReq(OSJoinReq)
    /// 回到房间请求
    case backReq(OSBackReq)
    /// 退出房间请求
    case exitReq(OSExitReq)
    /// 房间实时信息请求(房间每5秒轮询)
    case realTimeInfoReq(OSRealTimeInfoReq)
    /// 心跳请求(房间每20秒轮询)
    case onlineReportReq(OSOnlineReportReq)
    /// 房间详情请求
    case detailReq(OSDetailReq)
    /// 编辑房间信息请求
    case editChannelReq(OSEditChannelReq)
    /// 礼物栏标签列表请求
    case tagsReq(OSTagsReq)
    /// 礼物/福袋/背包列表请求
    case giftListReq(OSGiftListReq)
    /// 房间内查看用户信息请求
    case viewInfoReq(OSViewInfoReq)
    /// 上麦请求
    case pickUpMicroPhoneReq(OSPickUpMicroPhoneReq)
    /// 强制上麦请求
    case pickUpMicroPhoneCompelReq(OSPickUpMicroPhoneCompelReq)
    /// 下麦请求
    case putDownMicroPhoneReq(OSPutDownMicroPhoneReq)
    /// 换麦请求
    case exchangeMicroPhoneReq(OSExchangeMicroPhoneReq)
    /// 禁言(不能发公屏)请求
    case wordsNotAllowedReq(OSWordsNotAllowedReq)
    /// 解除禁言(允许发公屏)请求
    case wordsAllowedReq(OSWordsAllowedReq)
    /// 麦位锁状态相关
    case lockMicroPhoneReq(OSLockMicroPhoneReq)
    /// 麦位状态相关1------解锁麦位请求
    case unLockMicrophoneReq(OSUnLockMicrophoneReq)
    /// 麦位状态相关0------锁定全部麦位请求(一键锁麦)
    case lockAllMicrophoneReq(OSLockAllMicrophoneReq)
    /// 麦位状态相关1------解锁全部麦位请求(一键解麦)
    case unLockAllMicrophoneReq(OSUnLockAllMicrophoneReq)
    /// 麦位状态相关3------闭麦请求
    case lockSeatVoiceReq(OSLockSeatVoiceReq)
    /// 麦位状态相关1------解除闭麦请求
    case unLockSeatVoiceReq(OSUnLockSeatVoiceReq)
    /// 抱麦请求
    case holdOnMicroPhoneReq(OSHoldOnMicroPhoneReq)
    /// 踢出房间请求
    case kickYouOutReq(OSKickYouOutReq)
    /// 设置为超级管理员请求
    case setSuperAdminReq(OSSetSuperAdminReq)
    /// 取消超级管理员请求
    case cancelSuperAdminReq(OSCancelSuperAdminReq)
    /// 设置为管理员请求
    case setAdminReq(OSSetAdminReq)
    /// 取消管理员请求
    case cancelAdminReq(OSCancelAdminReq)
    /// 切换麦位布局请求
    case exchangeSeatLayoutReq(OSExchangeSeatLayoutReq)
    /// 关闭公屏请求
    case wordsNotAllowedAllReq(OSWordsNotAllowedAllReq)
    /// 开启公屏请求
    case wordsAllowedAllReq(OSWordsAllowedAllReq)
    /// 送礼物请求
    case givePresentsReq(OSGivePresentsReq)
    /// 送福袋请求
    case giveLuckyBagPresentReq(OSGiveLuckyBagPresentReq)
    /// 送背包请求
    case givePresentsUseBackpackReq(OSGivePresentsUseBackpackReq)
    /// 特权卡列表请求
    case privilegeCardsReq(OSPrivilegeCardsReq)
    /// 使用特权卡请求
    case usePrivilegeCardReq(OSUsePrivilegeCardReq)
    /// 开启心动值请求
    case openLoveNumReq(OSOpenLoveNumReq)
    /// 关闭心动值请求
    case closeLoveNumReq(OSCloseLoveNumReq)
    /// 房间排行榜请求
    case channelRankingsReq(OSChannelRankingsReq)
    /// 设置公告请求
    case announcementSettingReq(OSAnnouncementSettingReq)
    /// 在线用户列表请求
    case onlineUserReq(OSOnlineUserReq)
    /// PK话题列表请求
    case pkTopicsReq(OSPkTopicsReq)
    /// 创建PK请求
    case createPkGameReq(OSCreatePkGameReq)
    /// 搜索PK房间请求
    case searchPkChannelReq(OSSearchPkChannelReq)
    /// 发起跨厅PK请求
    case askChannelPkReq(OSAskChannelPkReq)
    /// 接受跨厅PK请求
    case acceptChannelPkReq(OSAcceptChannelPkReq)
    /// 拒绝跨厅PK请求
    case refuseChannelPkReq(OSRefuseChannelPkReq)
    /// 停止PK请求
    case stopPkGameReq(OSStopPkGameReq)
    /// PK记录请求
    case pkLogReq(OSPkLogReq)
    /// 随机房间名称请求
    case randomChannelNameReq(OSRandomChannelNameReq)
    /// 房间礼物墙请求
    case channelGiftWallReq(OSChannelGiftWallReq)
    /// 加入房间黑名单请求
    case joinChannelBlackListReq(OSJoinChannelBlackListReq)
    /// 取消房间黑名单请求
    case removeChannelBlackListReq(OSRemoveChannelBlackListReq)
    /// 房间管理员列表请求
    case channelAdminListReq(OSChannelAdminListReq)
    /// 房间黑名单用户列表请求
    case channelBlackListReq(OSChannelBlackListReq)
    /// 麦位锁状态相关
    case turnOntheMicrophoneReq(OSTurnOntheMicrophoneReq)
    /// 麦位状态相关1------开麦（解锁麦并开麦）
    case turnOfftheMicrophoneReq(OSTurnOfftheMicrophoneReq)
    /// 加入房间之后请求
    case afterJoinReq(OSAfterJoinReq)
    /// 房间禁言用户列表请求
    case channelProhibitListReq(OSChannelProhibitListReq)
    /// 送粉丝团礼物请求
    case givePresentsFansClubReq(OSGivePresentsFansClubReq)
    /// 清空心动值请求
    case emptyLoveNumReq(OSEmptyLoveNumReq)
    /// 购买动作表情
    case buyExpressionReq(OSBuyExpressionReq)
    ///做动作表情
    case commitExpressionReq(OSCommitExpressionReq)
    ///加载火箭数据
    case loadRocketInfoReq(OSLoadRocketInfoReq)
    ///小时榜数据
    case hoursListReq(OSHoursListReq)
    ///我的/Ta粉丝团信息请求
    case myClubReq(OSMyClubReq)
    ///加入粉丝团请求
    case joinClubReq(OSJoinClubReq)
    ///加载动作表情
    case loadExpressionReq(OSLoadExpressionReq)
    ///个播房间信息请求
    case personalChannelInfoReq(OSPersonalChannelInfoReq)
    ///设置个播模式观众席状态请求
    case personalSeatsConfigReq(OSPersonalSeatsConfigReq)
    ///设置个播模式直播状态请求
    case personalLiveConfigReq(OSPersonalLiveConfigReq)
    ///获得心愿礼物（查询任务进度)请求
    case wishGiftInfoReq(OSWishGiftInfoReq)
    ///设置心愿礼物请求
    case wishGiftConfigReq(OSWishGiftConfigReq)
    ///重启心愿礼物请求
    case wishGiftRestartReq(OSWishGiftRestartReq)
    ///删除心愿礼物请求
    case wishGiftDelReq(OSWishGiftDelReq)
    ///获取用户娱乐玩法相关信息请求
    case userPlayInfoReq(OSUserPlayInfoReq)

  }

  public init() {}
}

/// 房间相关响应
public struct OSChannelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSChannelResponse.OneOf_Body? = nil

  /// 创建房间响应
  public var createRes: OSCreateRes {
    get {
      if case .createRes(let v)? = body {return v}
      return OSCreateRes()
    }
    set {body = .createRes(newValue)}
  }

  /// 加入房间响应
  public var joinRes: OSJoinRes {
    get {
      if case .joinRes(let v)? = body {return v}
      return OSJoinRes()
    }
    set {body = .joinRes(newValue)}
  }

  /// 回到房间响应
  public var backRes: OSBackRes {
    get {
      if case .backRes(let v)? = body {return v}
      return OSBackRes()
    }
    set {body = .backRes(newValue)}
  }

  /// 退出房间响应
  public var exitRes: OSExitRes {
    get {
      if case .exitRes(let v)? = body {return v}
      return OSExitRes()
    }
    set {body = .exitRes(newValue)}
  }

  /// 房间实时信息响应(房间每5秒轮询)
  public var realTimeInfoRes: OSRealTimeInfoRes {
    get {
      if case .realTimeInfoRes(let v)? = body {return v}
      return OSRealTimeInfoRes()
    }
    set {body = .realTimeInfoRes(newValue)}
  }

  /// 心跳响应(房间每2分钟轮询)
  public var onlineReportRes: OSOnlineReportRes {
    get {
      if case .onlineReportRes(let v)? = body {return v}
      return OSOnlineReportRes()
    }
    set {body = .onlineReportRes(newValue)}
  }

  /// 房间详情响应
  public var detailRes: OSDetailRes {
    get {
      if case .detailRes(let v)? = body {return v}
      return OSDetailRes()
    }
    set {body = .detailRes(newValue)}
  }

  /// 编辑房间信息响应
  public var editChannelRes: OSEditChannelRes {
    get {
      if case .editChannelRes(let v)? = body {return v}
      return OSEditChannelRes()
    }
    set {body = .editChannelRes(newValue)}
  }

  /// 礼物栏标签列表响应
  public var tagsRes: OSTagsRes {
    get {
      if case .tagsRes(let v)? = body {return v}
      return OSTagsRes()
    }
    set {body = .tagsRes(newValue)}
  }

  /// 礼物/福袋/背包列表响应
  public var giftListRes: OSGiftListRes {
    get {
      if case .giftListRes(let v)? = body {return v}
      return OSGiftListRes()
    }
    set {body = .giftListRes(newValue)}
  }

  /// 房间内查看用户信息响应
  public var viewInfoRes: OSViewInfoRes {
    get {
      if case .viewInfoRes(let v)? = body {return v}
      return OSViewInfoRes()
    }
    set {body = .viewInfoRes(newValue)}
  }

  /// 上麦响应
  public var pickUpMicroPhoneRes: OSPickUpMicroPhoneRes {
    get {
      if case .pickUpMicroPhoneRes(let v)? = body {return v}
      return OSPickUpMicroPhoneRes()
    }
    set {body = .pickUpMicroPhoneRes(newValue)}
  }

  /// 强制上麦响应
  public var pickUpMicroPhoneCompelRes: OSPickUpMicroPhoneCompelRes {
    get {
      if case .pickUpMicroPhoneCompelRes(let v)? = body {return v}
      return OSPickUpMicroPhoneCompelRes()
    }
    set {body = .pickUpMicroPhoneCompelRes(newValue)}
  }

  /// 下麦响应
  public var putDownMicroPhoneRes: OSPutDownMicroPhoneRes {
    get {
      if case .putDownMicroPhoneRes(let v)? = body {return v}
      return OSPutDownMicroPhoneRes()
    }
    set {body = .putDownMicroPhoneRes(newValue)}
  }

  /// 换麦响应
  public var exchangeMicroPhoneRes: OSExchangeMicroPhoneRes {
    get {
      if case .exchangeMicroPhoneRes(let v)? = body {return v}
      return OSExchangeMicroPhoneRes()
    }
    set {body = .exchangeMicroPhoneRes(newValue)}
  }

  /// 禁止发言(不能发公屏)响应
  public var wordsNotAllowedRes: OSWordsNotAllowedRes {
    get {
      if case .wordsNotAllowedRes(let v)? = body {return v}
      return OSWordsNotAllowedRes()
    }
    set {body = .wordsNotAllowedRes(newValue)}
  }

  /// 解除禁言(允许发公屏)响应
  public var wordsAllowedRes: OSWordsAllowedRes {
    get {
      if case .wordsAllowedRes(let v)? = body {return v}
      return OSWordsAllowedRes()
    }
    set {body = .wordsAllowedRes(newValue)}
  }

  /// 麦位锁状态相关
  public var lockMicroPhoneRes: OSLockMicroPhoneRes {
    get {
      if case .lockMicroPhoneRes(let v)? = body {return v}
      return OSLockMicroPhoneRes()
    }
    set {body = .lockMicroPhoneRes(newValue)}
  }

  /// 解锁麦位响应
  public var unLockMicrophoneRes: OSUnLockMicrophoneRes {
    get {
      if case .unLockMicrophoneRes(let v)? = body {return v}
      return OSUnLockMicrophoneRes()
    }
    set {body = .unLockMicrophoneRes(newValue)}
  }

  /// 锁定全部麦位响应
  public var lockAllMicrophoneRes: OSLockAllMicrophoneRes {
    get {
      if case .lockAllMicrophoneRes(let v)? = body {return v}
      return OSLockAllMicrophoneRes()
    }
    set {body = .lockAllMicrophoneRes(newValue)}
  }

  /// 解锁全部麦位响应
  public var unLockAllMicrophoneRes: OSUnLockAllMicrophoneRes {
    get {
      if case .unLockAllMicrophoneRes(let v)? = body {return v}
      return OSUnLockAllMicrophoneRes()
    }
    set {body = .unLockAllMicrophoneRes(newValue)}
  }

  /// 闭麦响应
  public var lockSeatVoiceRes: OSLockSeatVoiceRes {
    get {
      if case .lockSeatVoiceRes(let v)? = body {return v}
      return OSLockSeatVoiceRes()
    }
    set {body = .lockSeatVoiceRes(newValue)}
  }

  /// 解除闭麦响应
  public var unLockSeatVoiceRes: OSUnLockSeatVoiceRes {
    get {
      if case .unLockSeatVoiceRes(let v)? = body {return v}
      return OSUnLockSeatVoiceRes()
    }
    set {body = .unLockSeatVoiceRes(newValue)}
  }

  /// 抱麦响应
  public var holdOnMicroPhoneRes: OSHoldOnMicroPhoneRes {
    get {
      if case .holdOnMicroPhoneRes(let v)? = body {return v}
      return OSHoldOnMicroPhoneRes()
    }
    set {body = .holdOnMicroPhoneRes(newValue)}
  }

  /// 踢出房间响应
  public var kickYouOutRes: OSKickYouOutRes {
    get {
      if case .kickYouOutRes(let v)? = body {return v}
      return OSKickYouOutRes()
    }
    set {body = .kickYouOutRes(newValue)}
  }

  /// 设置为超级管理员响应
  public var setSuperAdminRes: OSSetSuperAdminRes {
    get {
      if case .setSuperAdminRes(let v)? = body {return v}
      return OSSetSuperAdminRes()
    }
    set {body = .setSuperAdminRes(newValue)}
  }

  /// 取消超级管理员响应
  public var cancelSuperAdminRes: OSCancelSuperAdminRes {
    get {
      if case .cancelSuperAdminRes(let v)? = body {return v}
      return OSCancelSuperAdminRes()
    }
    set {body = .cancelSuperAdminRes(newValue)}
  }

  /// 设置为管理员响应
  public var setAdminRes: OSSetAdminRes {
    get {
      if case .setAdminRes(let v)? = body {return v}
      return OSSetAdminRes()
    }
    set {body = .setAdminRes(newValue)}
  }

  /// 取消管理员响应
  public var cancelAdminRes: OSCancelAdminRes {
    get {
      if case .cancelAdminRes(let v)? = body {return v}
      return OSCancelAdminRes()
    }
    set {body = .cancelAdminRes(newValue)}
  }

  /// 切换麦位布局响应
  public var exchangeSeatLayoutRes: OSExchangeSeatLayoutRes {
    get {
      if case .exchangeSeatLayoutRes(let v)? = body {return v}
      return OSExchangeSeatLayoutRes()
    }
    set {body = .exchangeSeatLayoutRes(newValue)}
  }

  /// 关闭公屏响应
  public var wordsNotAllowedAllRes: OSWordsNotAllowedAllRes {
    get {
      if case .wordsNotAllowedAllRes(let v)? = body {return v}
      return OSWordsNotAllowedAllRes()
    }
    set {body = .wordsNotAllowedAllRes(newValue)}
  }

  /// 开启公屏响应
  public var wordsAllowedAllRes: OSWordsAllowedAllRes {
    get {
      if case .wordsAllowedAllRes(let v)? = body {return v}
      return OSWordsAllowedAllRes()
    }
    set {body = .wordsAllowedAllRes(newValue)}
  }

  /// 送礼物响应
  public var givePresentsRes: OSGivePresentsRes {
    get {
      if case .givePresentsRes(let v)? = body {return v}
      return OSGivePresentsRes()
    }
    set {body = .givePresentsRes(newValue)}
  }

  /// 送福袋响应
  public var giveLuckyBagPresentRes: OSGiveLuckyBagPresentRes {
    get {
      if case .giveLuckyBagPresentRes(let v)? = body {return v}
      return OSGiveLuckyBagPresentRes()
    }
    set {body = .giveLuckyBagPresentRes(newValue)}
  }

  /// 送背包响应
  public var givePresentsUseBackpackRes: OSGivePresentsUseBackpackRes {
    get {
      if case .givePresentsUseBackpackRes(let v)? = body {return v}
      return OSGivePresentsUseBackpackRes()
    }
    set {body = .givePresentsUseBackpackRes(newValue)}
  }

  /// 特权卡列表响应
  public var privilegeCardsRes: OSPrivilegeCardsRes {
    get {
      if case .privilegeCardsRes(let v)? = body {return v}
      return OSPrivilegeCardsRes()
    }
    set {body = .privilegeCardsRes(newValue)}
  }

  /// 使用特权卡响应
  public var usePrivilegeCardRes: OSUsePrivilegeCardRes {
    get {
      if case .usePrivilegeCardRes(let v)? = body {return v}
      return OSUsePrivilegeCardRes()
    }
    set {body = .usePrivilegeCardRes(newValue)}
  }

  /// 开启心动值响应
  public var openLoveNumRes: OSOpenLoveNumRes {
    get {
      if case .openLoveNumRes(let v)? = body {return v}
      return OSOpenLoveNumRes()
    }
    set {body = .openLoveNumRes(newValue)}
  }

  /// 关闭心动值响应
  public var closeLoveNumRes: OSCloseLoveNumRes {
    get {
      if case .closeLoveNumRes(let v)? = body {return v}
      return OSCloseLoveNumRes()
    }
    set {body = .closeLoveNumRes(newValue)}
  }

  /// 房间排行榜响应
  public var channelRankingsRes: OSChannelRankingsRes {
    get {
      if case .channelRankingsRes(let v)? = body {return v}
      return OSChannelRankingsRes()
    }
    set {body = .channelRankingsRes(newValue)}
  }

  /// 设置公告响应
  public var announcementSettingRes: OSAnnouncementSettingRes {
    get {
      if case .announcementSettingRes(let v)? = body {return v}
      return OSAnnouncementSettingRes()
    }
    set {body = .announcementSettingRes(newValue)}
  }

  /// 在线用户列表响应
  public var onlineUserRes: OSOnlineUserRes {
    get {
      if case .onlineUserRes(let v)? = body {return v}
      return OSOnlineUserRes()
    }
    set {body = .onlineUserRes(newValue)}
  }

  /// PK话题列表响应
  public var pkTopicsRes: OSPkTopicsRes {
    get {
      if case .pkTopicsRes(let v)? = body {return v}
      return OSPkTopicsRes()
    }
    set {body = .pkTopicsRes(newValue)}
  }

  /// 创建PK响应
  public var createPkGameRes: OSCreatePkGameRes {
    get {
      if case .createPkGameRes(let v)? = body {return v}
      return OSCreatePkGameRes()
    }
    set {body = .createPkGameRes(newValue)}
  }

  /// 搜索Pk房间响应
  public var searchPkChannelRes: OSSearchPkChannelRes {
    get {
      if case .searchPkChannelRes(let v)? = body {return v}
      return OSSearchPkChannelRes()
    }
    set {body = .searchPkChannelRes(newValue)}
  }

  /// 发起跨厅PK响应
  public var askChannelPkRes: OSAskChannelPkRes {
    get {
      if case .askChannelPkRes(let v)? = body {return v}
      return OSAskChannelPkRes()
    }
    set {body = .askChannelPkRes(newValue)}
  }

  /// 接受跨厅PK响应
  public var acceptChannelPkRes: OSAcceptChannelPkRes {
    get {
      if case .acceptChannelPkRes(let v)? = body {return v}
      return OSAcceptChannelPkRes()
    }
    set {body = .acceptChannelPkRes(newValue)}
  }

  /// 拒绝跨厅PK响应
  public var refuseChannelPkRes: OSRefuseChannelPkRes {
    get {
      if case .refuseChannelPkRes(let v)? = body {return v}
      return OSRefuseChannelPkRes()
    }
    set {body = .refuseChannelPkRes(newValue)}
  }

  /// 停止PK请求
  public var stopPkGameRes: OSStopPkGameRes {
    get {
      if case .stopPkGameRes(let v)? = body {return v}
      return OSStopPkGameRes()
    }
    set {body = .stopPkGameRes(newValue)}
  }

  /// PK记录响应
  public var pkLogReqs: OSPkLogRes {
    get {
      if case .pkLogReqs(let v)? = body {return v}
      return OSPkLogRes()
    }
    set {body = .pkLogReqs(newValue)}
  }

  /// 随机房间名称响应
  public var randomChannelNameRes: OSRandomChannelNameRes {
    get {
      if case .randomChannelNameRes(let v)? = body {return v}
      return OSRandomChannelNameRes()
    }
    set {body = .randomChannelNameRes(newValue)}
  }

  /// 房间礼物墙响应
  public var channelGiftWallRes: OSChannelGiftWallRes {
    get {
      if case .channelGiftWallRes(let v)? = body {return v}
      return OSChannelGiftWallRes()
    }
    set {body = .channelGiftWallRes(newValue)}
  }

  /// 加入房间黑名单响应
  public var joinChannelBlackListRes: OSJoinChannelBlackListRes {
    get {
      if case .joinChannelBlackListRes(let v)? = body {return v}
      return OSJoinChannelBlackListRes()
    }
    set {body = .joinChannelBlackListRes(newValue)}
  }

  /// 取消房间黑名单响应
  public var removeChannelBlackListRes: OSRemoveChannelBlackListRes {
    get {
      if case .removeChannelBlackListRes(let v)? = body {return v}
      return OSRemoveChannelBlackListRes()
    }
    set {body = .removeChannelBlackListRes(newValue)}
  }

  /// 房间管理员列表响应
  public var channelAdminListRes: OSChannelAdminListRes {
    get {
      if case .channelAdminListRes(let v)? = body {return v}
      return OSChannelAdminListRes()
    }
    set {body = .channelAdminListRes(newValue)}
  }

  /// 房间黑名单用户列表响应
  public var channelBlackListRes: OSChannelBlackListRes {
    get {
      if case .channelBlackListRes(let v)? = body {return v}
      return OSChannelBlackListRes()
    }
    set {body = .channelBlackListRes(newValue)}
  }

  /// 麦位锁状态相关
  public var turnOntheMicrophoneRes: OSTurnOntheMicrophoneRes {
    get {
      if case .turnOntheMicrophoneRes(let v)? = body {return v}
      return OSTurnOntheMicrophoneRes()
    }
    set {body = .turnOntheMicrophoneRes(newValue)}
  }

  /// 麦位状态相关1------禁麦（解锁麦并开麦）
  public var turnOfftheMicrophoneRes: OSTurnOfftheMicrophoneRes {
    get {
      if case .turnOfftheMicrophoneRes(let v)? = body {return v}
      return OSTurnOfftheMicrophoneRes()
    }
    set {body = .turnOfftheMicrophoneRes(newValue)}
  }

  /// 加入房间之后请求
  public var afterJoinRes: OSAfterJoinRes {
    get {
      if case .afterJoinRes(let v)? = body {return v}
      return OSAfterJoinRes()
    }
    set {body = .afterJoinRes(newValue)}
  }

  /// 房间禁言用户列表响应
  public var channelProhibitListRes: OSChannelProhibitListRes {
    get {
      if case .channelProhibitListRes(let v)? = body {return v}
      return OSChannelProhibitListRes()
    }
    set {body = .channelProhibitListRes(newValue)}
  }

  /// 送粉丝团礼物响应
  public var givePresentsFansClubRes: OSGivePresentsFansClubRes {
    get {
      if case .givePresentsFansClubRes(let v)? = body {return v}
      return OSGivePresentsFansClubRes()
    }
    set {body = .givePresentsFansClubRes(newValue)}
  }

  /// 清空心动值响应
  public var emptyLoveNumRes: OSEmptyLoveNumRes {
    get {
      if case .emptyLoveNumRes(let v)? = body {return v}
      return OSEmptyLoveNumRes()
    }
    set {body = .emptyLoveNumRes(newValue)}
  }

  /// 购买动作表情
  public var buyExpressionRes: OSBuyExpressionRes {
    get {
      if case .buyExpressionRes(let v)? = body {return v}
      return OSBuyExpressionRes()
    }
    set {body = .buyExpressionRes(newValue)}
  }

  ///做动作表情
  public var commitExpressionRes: OSCommitExpressionRes {
    get {
      if case .commitExpressionRes(let v)? = body {return v}
      return OSCommitExpressionRes()
    }
    set {body = .commitExpressionRes(newValue)}
  }

  ///加载火箭数据
  public var loadRocketInfoRes: OSLoadRocketInfoRes {
    get {
      if case .loadRocketInfoRes(let v)? = body {return v}
      return OSLoadRocketInfoRes()
    }
    set {body = .loadRocketInfoRes(newValue)}
  }

  ///小时榜数据
  public var hoursListRes: OSHoursListRes {
    get {
      if case .hoursListRes(let v)? = body {return v}
      return OSHoursListRes()
    }
    set {body = .hoursListRes(newValue)}
  }

  ///我的/Ta粉丝团信息响应
  public var myClubRes: OSMyClubRes {
    get {
      if case .myClubRes(let v)? = body {return v}
      return OSMyClubRes()
    }
    set {body = .myClubRes(newValue)}
  }

  ///加入粉丝团响应
  public var joinClubRes: OSJoinClubRes {
    get {
      if case .joinClubRes(let v)? = body {return v}
      return OSJoinClubRes()
    }
    set {body = .joinClubRes(newValue)}
  }

  ///加载动作表情
  public var loadExpressionRes: OSLoadExpressionRes {
    get {
      if case .loadExpressionRes(let v)? = body {return v}
      return OSLoadExpressionRes()
    }
    set {body = .loadExpressionRes(newValue)}
  }

  ///个播房间信息响应
  public var personalChannelInfoRes: OSPersonalChannelInfoRes {
    get {
      if case .personalChannelInfoRes(let v)? = body {return v}
      return OSPersonalChannelInfoRes()
    }
    set {body = .personalChannelInfoRes(newValue)}
  }

  ///设置个播模式观众席状态响应
  public var personalSeatsConfigRes: OSPersonalSeatsConfigRes {
    get {
      if case .personalSeatsConfigRes(let v)? = body {return v}
      return OSPersonalSeatsConfigRes()
    }
    set {body = .personalSeatsConfigRes(newValue)}
  }

  ///设置个播模式直播状态响应
  public var personalLiveConfigRess: OSPersonalLiveConfigRes {
    get {
      if case .personalLiveConfigRess(let v)? = body {return v}
      return OSPersonalLiveConfigRes()
    }
    set {body = .personalLiveConfigRess(newValue)}
  }

  ///获得心愿礼物（查询任务进度)响应
  public var wishGiftInfoRes: OSWishGiftInfoRes {
    get {
      if case .wishGiftInfoRes(let v)? = body {return v}
      return OSWishGiftInfoRes()
    }
    set {body = .wishGiftInfoRes(newValue)}
  }

  ///设置心愿礼物响应
  public var wishGiftConfigRes: OSWishGiftConfigRes {
    get {
      if case .wishGiftConfigRes(let v)? = body {return v}
      return OSWishGiftConfigRes()
    }
    set {body = .wishGiftConfigRes(newValue)}
  }

  ///重启心愿礼物响应
  public var wishGiftRestartRes: OSWishGiftRestartRes {
    get {
      if case .wishGiftRestartRes(let v)? = body {return v}
      return OSWishGiftRestartRes()
    }
    set {body = .wishGiftRestartRes(newValue)}
  }

  ///删除心愿礼物响应
  public var wishGiftDelRes: OSWishGiftDelRes {
    get {
      if case .wishGiftDelRes(let v)? = body {return v}
      return OSWishGiftDelRes()
    }
    set {body = .wishGiftDelRes(newValue)}
  }

  ///获取用户娱乐玩法相关信息响应
  public var userPlayInfoRes: OSUserPlayInfoRes {
    get {
      if case .userPlayInfoRes(let v)? = body {return v}
      return OSUserPlayInfoRes()
    }
    set {body = .userPlayInfoRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 创建房间响应
    case createRes(OSCreateRes)
    /// 加入房间响应
    case joinRes(OSJoinRes)
    /// 回到房间响应
    case backRes(OSBackRes)
    /// 退出房间响应
    case exitRes(OSExitRes)
    /// 房间实时信息响应(房间每5秒轮询)
    case realTimeInfoRes(OSRealTimeInfoRes)
    /// 心跳响应(房间每2分钟轮询)
    case onlineReportRes(OSOnlineReportRes)
    /// 房间详情响应
    case detailRes(OSDetailRes)
    /// 编辑房间信息响应
    case editChannelRes(OSEditChannelRes)
    /// 礼物栏标签列表响应
    case tagsRes(OSTagsRes)
    /// 礼物/福袋/背包列表响应
    case giftListRes(OSGiftListRes)
    /// 房间内查看用户信息响应
    case viewInfoRes(OSViewInfoRes)
    /// 上麦响应
    case pickUpMicroPhoneRes(OSPickUpMicroPhoneRes)
    /// 强制上麦响应
    case pickUpMicroPhoneCompelRes(OSPickUpMicroPhoneCompelRes)
    /// 下麦响应
    case putDownMicroPhoneRes(OSPutDownMicroPhoneRes)
    /// 换麦响应
    case exchangeMicroPhoneRes(OSExchangeMicroPhoneRes)
    /// 禁止发言(不能发公屏)响应
    case wordsNotAllowedRes(OSWordsNotAllowedRes)
    /// 解除禁言(允许发公屏)响应
    case wordsAllowedRes(OSWordsAllowedRes)
    /// 麦位锁状态相关
    case lockMicroPhoneRes(OSLockMicroPhoneRes)
    /// 解锁麦位响应
    case unLockMicrophoneRes(OSUnLockMicrophoneRes)
    /// 锁定全部麦位响应
    case lockAllMicrophoneRes(OSLockAllMicrophoneRes)
    /// 解锁全部麦位响应
    case unLockAllMicrophoneRes(OSUnLockAllMicrophoneRes)
    /// 闭麦响应
    case lockSeatVoiceRes(OSLockSeatVoiceRes)
    /// 解除闭麦响应
    case unLockSeatVoiceRes(OSUnLockSeatVoiceRes)
    /// 抱麦响应
    case holdOnMicroPhoneRes(OSHoldOnMicroPhoneRes)
    /// 踢出房间响应
    case kickYouOutRes(OSKickYouOutRes)
    /// 设置为超级管理员响应
    case setSuperAdminRes(OSSetSuperAdminRes)
    /// 取消超级管理员响应
    case cancelSuperAdminRes(OSCancelSuperAdminRes)
    /// 设置为管理员响应
    case setAdminRes(OSSetAdminRes)
    /// 取消管理员响应
    case cancelAdminRes(OSCancelAdminRes)
    /// 切换麦位布局响应
    case exchangeSeatLayoutRes(OSExchangeSeatLayoutRes)
    /// 关闭公屏响应
    case wordsNotAllowedAllRes(OSWordsNotAllowedAllRes)
    /// 开启公屏响应
    case wordsAllowedAllRes(OSWordsAllowedAllRes)
    /// 送礼物响应
    case givePresentsRes(OSGivePresentsRes)
    /// 送福袋响应
    case giveLuckyBagPresentRes(OSGiveLuckyBagPresentRes)
    /// 送背包响应
    case givePresentsUseBackpackRes(OSGivePresentsUseBackpackRes)
    /// 特权卡列表响应
    case privilegeCardsRes(OSPrivilegeCardsRes)
    /// 使用特权卡响应
    case usePrivilegeCardRes(OSUsePrivilegeCardRes)
    /// 开启心动值响应
    case openLoveNumRes(OSOpenLoveNumRes)
    /// 关闭心动值响应
    case closeLoveNumRes(OSCloseLoveNumRes)
    /// 房间排行榜响应
    case channelRankingsRes(OSChannelRankingsRes)
    /// 设置公告响应
    case announcementSettingRes(OSAnnouncementSettingRes)
    /// 在线用户列表响应
    case onlineUserRes(OSOnlineUserRes)
    /// PK话题列表响应
    case pkTopicsRes(OSPkTopicsRes)
    /// 创建PK响应
    case createPkGameRes(OSCreatePkGameRes)
    /// 搜索Pk房间响应
    case searchPkChannelRes(OSSearchPkChannelRes)
    /// 发起跨厅PK响应
    case askChannelPkRes(OSAskChannelPkRes)
    /// 接受跨厅PK响应
    case acceptChannelPkRes(OSAcceptChannelPkRes)
    /// 拒绝跨厅PK响应
    case refuseChannelPkRes(OSRefuseChannelPkRes)
    /// 停止PK请求
    case stopPkGameRes(OSStopPkGameRes)
    /// PK记录响应
    case pkLogReqs(OSPkLogRes)
    /// 随机房间名称响应
    case randomChannelNameRes(OSRandomChannelNameRes)
    /// 房间礼物墙响应
    case channelGiftWallRes(OSChannelGiftWallRes)
    /// 加入房间黑名单响应
    case joinChannelBlackListRes(OSJoinChannelBlackListRes)
    /// 取消房间黑名单响应
    case removeChannelBlackListRes(OSRemoveChannelBlackListRes)
    /// 房间管理员列表响应
    case channelAdminListRes(OSChannelAdminListRes)
    /// 房间黑名单用户列表响应
    case channelBlackListRes(OSChannelBlackListRes)
    /// 麦位锁状态相关
    case turnOntheMicrophoneRes(OSTurnOntheMicrophoneRes)
    /// 麦位状态相关1------禁麦（解锁麦并开麦）
    case turnOfftheMicrophoneRes(OSTurnOfftheMicrophoneRes)
    /// 加入房间之后请求
    case afterJoinRes(OSAfterJoinRes)
    /// 房间禁言用户列表响应
    case channelProhibitListRes(OSChannelProhibitListRes)
    /// 送粉丝团礼物响应
    case givePresentsFansClubRes(OSGivePresentsFansClubRes)
    /// 清空心动值响应
    case emptyLoveNumRes(OSEmptyLoveNumRes)
    /// 购买动作表情
    case buyExpressionRes(OSBuyExpressionRes)
    ///做动作表情
    case commitExpressionRes(OSCommitExpressionRes)
    ///加载火箭数据
    case loadRocketInfoRes(OSLoadRocketInfoRes)
    ///小时榜数据
    case hoursListRes(OSHoursListRes)
    ///我的/Ta粉丝团信息响应
    case myClubRes(OSMyClubRes)
    ///加入粉丝团响应
    case joinClubRes(OSJoinClubRes)
    ///加载动作表情
    case loadExpressionRes(OSLoadExpressionRes)
    ///个播房间信息响应
    case personalChannelInfoRes(OSPersonalChannelInfoRes)
    ///设置个播模式观众席状态响应
    case personalSeatsConfigRes(OSPersonalSeatsConfigRes)
    ///设置个播模式直播状态响应
    case personalLiveConfigRess(OSPersonalLiveConfigRes)
    ///获得心愿礼物（查询任务进度)响应
    case wishGiftInfoRes(OSWishGiftInfoRes)
    ///设置心愿礼物响应
    case wishGiftConfigRes(OSWishGiftConfigRes)
    ///重启心愿礼物响应
    case wishGiftRestartRes(OSWishGiftRestartRes)
    ///删除心愿礼物响应
    case wishGiftDelRes(OSWishGiftDelRes)
    ///获取用户娱乐玩法相关信息响应
    case userPlayInfoRes(OSUserPlayInfoRes)

  }

  public init() {}
}

/// 创建房间请求
public struct OSCreateReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 菜单id
  public var menuID: Int32 = 0

  /// 房间名称
  public var channelName: String = String()

  /// 房间模式
  public var channelType: OSChannelType = .unkown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 创建房间响应
public struct OSCreateRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户个人信息
  public var myself: OSUserInChannel {
    get {return _storage._myself ?? OSUserInChannel()}
    set {_uniqueStorage()._myself = newValue}
  }
  /// Returns true if `myself` has been explicitly set.
  public var hasMyself: Bool {return _storage._myself != nil}
  /// Clears the value of `myself`. Subsequent reads from it will return its default value.
  public mutating func clearMyself() {_uniqueStorage()._myself = nil}

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _storage._channel ?? OSChannelVo()}
    set {_uniqueStorage()._channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return _storage._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {_uniqueStorage()._channel = nil}

  /// 麦位列表信息
  public var userInSeats: [OSUserInSeats] {
    get {return _storage._userInSeats}
    set {_uniqueStorage()._userInSeats = newValue}
  }

  /// 房间声网token
  public var channelToken: String {
    get {return _storage._channelToken}
    set {_uniqueStorage()._channelToken = newValue}
  }

  /// 守护值前三用户信息
  public var wealthUsers: [OSWealthUsers] {
    get {return _storage._wealthUsers}
    set {_uniqueStorage()._wealthUsers = newValue}
  }

  /// 当前活动信息
  public var activityInfo: OSActivityInfo {
    get {return _storage._activityInfo ?? OSActivityInfo()}
    set {_uniqueStorage()._activityInfo = newValue}
  }
  /// Returns true if `activityInfo` has been explicitly set.
  public var hasActivityInfo: Bool {return _storage._activityInfo != nil}
  /// Clears the value of `activityInfo`. Subsequent reads from it will return its default value.
  public mutating func clearActivityInfo() {_uniqueStorage()._activityInfo = nil}

  /// 游戏状态信息
  public var activeStatus: OSActiveStatus {
    get {return _storage._activeStatus ?? OSActiveStatus()}
    set {_uniqueStorage()._activeStatus = newValue}
  }
  /// Returns true if `activeStatus` has been explicitly set.
  public var hasActiveStatus: Bool {return _storage._activeStatus != nil}
  /// Clears the value of `activeStatus`. Subsequent reads from it will return its default value.
  public mutating func clearActiveStatus() {_uniqueStorage()._activeStatus = nil}

  /// 勋章信息
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 房间设置信息
  public var channelSetting: OSChannelSetting {
    get {return _storage._channelSetting ?? OSChannelSetting()}
    set {_uniqueStorage()._channelSetting = newValue}
  }
  /// Returns true if `channelSetting` has been explicitly set.
  public var hasChannelSetting: Bool {return _storage._channelSetting != nil}
  /// Clears the value of `channelSetting`. Subsequent reads from it will return its default value.
  public mutating func clearChannelSetting() {_uniqueStorage()._channelSetting = nil}

  /// 是否是公开厅 0:否 1:是
  public var isOpenChannel: Bool {
    get {return _storage._isOpenChannel}
    set {_uniqueStorage()._isOpenChannel = newValue}
  }

  /// 是否可以送礼给自己 0:否 1:是
  public var giveSelf: Int32 {
    get {return _storage._giveSelf}
    set {_uniqueStorage()._giveSelf = newValue}
  }

  /// 房间其他信息
  public var other: OSChannelOther {
    get {return _storage._other ?? OSChannelOther()}
    set {_uniqueStorage()._other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return _storage._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {_uniqueStorage()._other = nil}

  /// 气泡框,客户端用,后端不返回数据
  public var bubbleInfo: OSBubbleInfo {
    get {return _storage._bubbleInfo ?? OSBubbleInfo()}
    set {_uniqueStorage()._bubbleInfo = newValue}
  }
  /// Returns true if `bubbleInfo` has been explicitly set.
  public var hasBubbleInfo: Bool {return _storage._bubbleInfo != nil}
  /// Clears the value of `bubbleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBubbleInfo() {_uniqueStorage()._bubbleInfo = nil}

  /// 坐骑信息
  public var mount: OSMount {
    get {return _storage._mount ?? OSMount()}
    set {_uniqueStorage()._mount = newValue}
  }
  /// Returns true if `mount` has been explicitly set.
  public var hasMount: Bool {return _storage._mount != nil}
  /// Clears the value of `mount`. Subsequent reads from it will return its default value.
  public mutating func clearMount() {_uniqueStorage()._mount = nil}

  /// 入场特效
  public var admissionEffects: OSAdmissionEffects {
    get {return _storage._admissionEffects ?? OSAdmissionEffects()}
    set {_uniqueStorage()._admissionEffects = newValue}
  }
  /// Returns true if `admissionEffects` has been explicitly set.
  public var hasAdmissionEffects: Bool {return _storage._admissionEffects != nil}
  /// Clears the value of `admissionEffects`. Subsequent reads from it will return its default value.
  public mutating func clearAdmissionEffects() {_uniqueStorage()._admissionEffects = nil}

  /// 贵宾卡信息
  public var honouredGuestCard: OSHonouredGuestCard {
    get {return _storage._honouredGuestCard ?? OSHonouredGuestCard()}
    set {_uniqueStorage()._honouredGuestCard = newValue}
  }
  /// Returns true if `honouredGuestCard` has been explicitly set.
  public var hasHonouredGuestCard: Bool {return _storage._honouredGuestCard != nil}
  /// Clears the value of `honouredGuestCard`. Subsequent reads from it will return its default value.
  public mutating func clearHonouredGuestCard() {_uniqueStorage()._honouredGuestCard = nil}

  /// 装扮信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 守护值前三用户信息
public struct OSWealthUsers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 礼物值
  public var giftValue: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 当前活动信息
public struct OSActivityInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk信息
  public var pkGame: OSPkGame {
    get {return _pkGame ?? OSPkGame()}
    set {_pkGame = newValue}
  }
  /// Returns true if `pkGame` has been explicitly set.
  public var hasPkGame: Bool {return self._pkGame != nil}
  /// Clears the value of `pkGame`. Subsequent reads from it will return its default value.
  public mutating func clearPkGame() {self._pkGame = nil}

  /// H5活动列表
  public var activityList: [OSActivityList] = []

  /// H5活动列表(半屏)
  public var halfActivityList: [OSActivityList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pkGame: OSPkGame? = nil
}

/// PK信息
public struct OSPkGame: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// pk回合id
  public var pkRoundID: String {
    get {return _storage._pkRoundID}
    set {_uniqueStorage()._pkRoundID = newValue}
  }

  /// pk话题
  public var topic: String {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  /// pk类型
  public var type: OSPkType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 时长
  public var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  /// 蓝方分数
  public var blueTeamScore: Int32 {
    get {return _storage._blueTeamScore}
    set {_uniqueStorage()._blueTeamScore = newValue}
  }

  /// 红方分数
  public var redTeamScore: Int32 {
    get {return _storage._redTeamScore}
    set {_uniqueStorage()._redTeamScore = newValue}
  }

  /// 开始时间
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// 结束时间
  public var endTime: Int64 {
    get {return _storage._endTime}
    set {_uniqueStorage()._endTime = newValue}
  }

  /// 1v1或团战4v4时代表参与者列表,跨厅时代表红方参与者列表
  public var participants: [OSParticipantVo] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  /// 蓝方参与者列表(跨厅pk返回)
  public var blueParticipants: [OSParticipantVo] {
    get {return _storage._blueParticipants}
    set {_uniqueStorage()._blueParticipants = newValue}
  }

  /// 1v1或团战4v4时代表送礼老板列表,跨厅时代表红方老板列表
  public var pkBossUsers: [OSPkBossUserVo] {
    get {return _storage._pkBossUsers}
    set {_uniqueStorage()._pkBossUsers = newValue}
  }

  /// 蓝方老板列表(跨厅pk返回)
  public var bluePkBossUsers: [OSPkBossUserVo] {
    get {return _storage._bluePkBossUsers}
    set {_uniqueStorage()._bluePkBossUsers = newValue}
  }

  /// 红方房间信息(跨厅pk返回)
  public var redChannelInfo: OSPkChannelInfoVo {
    get {return _storage._redChannelInfo ?? OSPkChannelInfoVo()}
    set {_uniqueStorage()._redChannelInfo = newValue}
  }
  /// Returns true if `redChannelInfo` has been explicitly set.
  public var hasRedChannelInfo: Bool {return _storage._redChannelInfo != nil}
  /// Clears the value of `redChannelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRedChannelInfo() {_uniqueStorage()._redChannelInfo = nil}

  /// 蓝方房间信息(跨厅pk返回)
  public var blueChannelInfo: OSPkChannelInfoVo {
    get {return _storage._blueChannelInfo ?? OSPkChannelInfoVo()}
    set {_uniqueStorage()._blueChannelInfo = newValue}
  }
  /// Returns true if `blueChannelInfo` has been explicitly set.
  public var hasBlueChannelInfo: Bool {return _storage._blueChannelInfo != nil}
  /// Clears the value of `blueChannelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBlueChannelInfo() {_uniqueStorage()._blueChannelInfo = nil}

  /// pk状态 0已结束 1进行中
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// 系统当前时间 注：1v1或团战创建pk、跨厅接受pk、创建房间、加入房间会返回当前服务器时间
  public var systemTime: Int64 {
    get {return _storage._systemTime}
    set {_uniqueStorage()._systemTime = newValue}
  }

  /// 红方房间麦位列表信息（跨厅pk个播房间返回）
  public var redUserInSeats: [OSUserInSeats] {
    get {return _storage._redUserInSeats}
    set {_uniqueStorage()._redUserInSeats = newValue}
  }

  /// 蓝方房间麦位列表信息（跨厅pk个播房间返回）
  public var blueUserInSeats: [OSUserInSeats] {
    get {return _storage._blueUserInSeats}
    set {_uniqueStorage()._blueUserInSeats = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// H5活动
public struct OSActivityList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 活动标题
  public var title: String = String()

  /// 活动图标
  public var imgURL: String = String()

  /// 跳转内容
  public var linkValue: String = String()

  /// 跳转类型 (1.浏览器)
  public var linkType: Int32 = 0

  /// id
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 游戏状态信息
public struct OSActiveStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 活动入口(0隐藏 1显示)
  public var activitySwich: Int32 = 0

  /// 抽奖入口列表
  public var lotterys: [OSLotterys] = []

  /// pk入口(0隐藏 1显示)
  public var pkGame: Int32 = 0

  /// 幻灵入口(0隐藏 1显示)
  public var eidolon: Int32 = 0

  /// 是否显示小时榜(0隐藏 1显示)
  public var listsHoursSwitch: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 抽奖入口信息
public struct OSLotterys: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 图标
  public var lotteryIcon: String = String()

  /// 抽奖入口类型 1 2普通宝箱 3嘉年华宝箱 4礼物工坊 5冒泡泡 6星座盲盒
  public var lotteryType: Int32 = 0

  /// 展示位置 1轮播 2工具箱 3轮播图和工具箱
  public var positionType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间其他信息
public struct OSChannelOther: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户是否收藏该房间(0未收藏1已收藏)
  public var collectFlag: Int32 = 0

  /// 游戏浮窗通知
  public var gameNotice: OSGameNotice {
    get {return _gameNotice ?? OSGameNotice()}
    set {_gameNotice = newValue}
  }
  /// Returns true if `gameNotice` has been explicitly set.
  public var hasGameNotice: Bool {return self._gameNotice != nil}
  /// Clears the value of `gameNotice`. Subsequent reads from it will return its default value.
  public mutating func clearGameNotice() {self._gameNotice = nil}

  /// 该房主是否创建了粉丝团 0否1是
  public var isFansClub: Int32 = 0

  /// 是否是该房主的粉丝团成员 0否1是
  public var isFansUser: Int32 = 0

  /// 直播开关 0关1开 （个播返回）
  public var liveSwitch: Int32 = 0

  /// 观众席开关 0关1开（个播返回）
  public var seatsSwitch: Int32 = 0

  ///粉丝团Id
  public var clubID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gameNotice: OSGameNotice? = nil
}

/// 游戏浮窗通知
public struct OSGameNotice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 浮窗内容
  public var content: String = String()

  /// 时长,单位秒
  public var duration: Int32 = 0

  /// 抽奖类型
  public var lotteryType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间设置信息
public struct OSChannelSetting: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 公告标题
  public var announceTitle: String = String()

  /// 公告内容
  public var announceContent: String = String()

  /// 心动值开关 0关 1开
  public var lovenumSwitch: Int32 = 0

  /// 麦位布局 1:横向排列(传统布局) 2:纵向排列(聊天模式)
  public var seatLayout: Int32 = 0

  /// 背景Id
  public var coverID: Int32 = 0

  /// 房间第10个座位是否显示0隐藏1显示
  public var seat9Show: Int32 = 0

  /// 房间模式座位展示数量（1-10）
  public var seatCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加入房间请求
public struct OSJoinReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 房间密码,没密码可不传
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加入房间响应
public struct OSJoinRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户个人信息
  public var myself: OSUserInChannel {
    get {return _storage._myself ?? OSUserInChannel()}
    set {_uniqueStorage()._myself = newValue}
  }
  /// Returns true if `myself` has been explicitly set.
  public var hasMyself: Bool {return _storage._myself != nil}
  /// Clears the value of `myself`. Subsequent reads from it will return its default value.
  public mutating func clearMyself() {_uniqueStorage()._myself = nil}

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _storage._channel ?? OSChannelVo()}
    set {_uniqueStorage()._channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return _storage._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {_uniqueStorage()._channel = nil}

  /// 麦位列表信息
  public var userInSeats: [OSUserInSeats] {
    get {return _storage._userInSeats}
    set {_uniqueStorage()._userInSeats = newValue}
  }

  /// 房间声网token
  public var channelToken: String {
    get {return _storage._channelToken}
    set {_uniqueStorage()._channelToken = newValue}
  }

  /// 守护值前三用户信息
  public var wealthUsers: [OSWealthUsers] {
    get {return _storage._wealthUsers}
    set {_uniqueStorage()._wealthUsers = newValue}
  }

  /// 当前活动信息
  public var activityInfo: OSActivityInfo {
    get {return _storage._activityInfo ?? OSActivityInfo()}
    set {_uniqueStorage()._activityInfo = newValue}
  }
  /// Returns true if `activityInfo` has been explicitly set.
  public var hasActivityInfo: Bool {return _storage._activityInfo != nil}
  /// Clears the value of `activityInfo`. Subsequent reads from it will return its default value.
  public mutating func clearActivityInfo() {_uniqueStorage()._activityInfo = nil}

  /// 游戏状态信息
  public var activeStatus: OSActiveStatus {
    get {return _storage._activeStatus ?? OSActiveStatus()}
    set {_uniqueStorage()._activeStatus = newValue}
  }
  /// Returns true if `activeStatus` has been explicitly set.
  public var hasActiveStatus: Bool {return _storage._activeStatus != nil}
  /// Clears the value of `activeStatus`. Subsequent reads from it will return its default value.
  public mutating func clearActiveStatus() {_uniqueStorage()._activeStatus = nil}

  /// 勋章信息
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 房间设置信息
  public var channelSetting: OSChannelSetting {
    get {return _storage._channelSetting ?? OSChannelSetting()}
    set {_uniqueStorage()._channelSetting = newValue}
  }
  /// Returns true if `channelSetting` has been explicitly set.
  public var hasChannelSetting: Bool {return _storage._channelSetting != nil}
  /// Clears the value of `channelSetting`. Subsequent reads from it will return its default value.
  public mutating func clearChannelSetting() {_uniqueStorage()._channelSetting = nil}

  /// 是否是公开厅 0:否 1:是
  public var isOpenChannel: Bool {
    get {return _storage._isOpenChannel}
    set {_uniqueStorage()._isOpenChannel = newValue}
  }

  /// 是否可以送礼给自己 0:否 1:是
  public var giveSelf: Int32 {
    get {return _storage._giveSelf}
    set {_uniqueStorage()._giveSelf = newValue}
  }

  /// 房间其他信息
  public var other: OSChannelOther {
    get {return _storage._other ?? OSChannelOther()}
    set {_uniqueStorage()._other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return _storage._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {_uniqueStorage()._other = nil}

  /// 房主个人信息
  public var owner: OSUserVo {
    get {return _storage._owner ?? OSUserVo()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// 坐骑信息
  public var mount: OSMount {
    get {return _storage._mount ?? OSMount()}
    set {_uniqueStorage()._mount = newValue}
  }
  /// Returns true if `mount` has been explicitly set.
  public var hasMount: Bool {return _storage._mount != nil}
  /// Clears the value of `mount`. Subsequent reads from it will return its default value.
  public mutating func clearMount() {_uniqueStorage()._mount = nil}

  /// 入场特效
  public var admissionEffects: OSAdmissionEffects {
    get {return _storage._admissionEffects ?? OSAdmissionEffects()}
    set {_uniqueStorage()._admissionEffects = newValue}
  }
  /// Returns true if `admissionEffects` has been explicitly set.
  public var hasAdmissionEffects: Bool {return _storage._admissionEffects != nil}
  /// Clears the value of `admissionEffects`. Subsequent reads from it will return its default value.
  public mutating func clearAdmissionEffects() {_uniqueStorage()._admissionEffects = nil}

  /// 气泡框,客户端用,后端不返回数据
  public var bubbleInfo: OSBubbleInfo {
    get {return _storage._bubbleInfo ?? OSBubbleInfo()}
    set {_uniqueStorage()._bubbleInfo = newValue}
  }
  /// Returns true if `bubbleInfo` has been explicitly set.
  public var hasBubbleInfo: Bool {return _storage._bubbleInfo != nil}
  /// Clears the value of `bubbleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBubbleInfo() {_uniqueStorage()._bubbleInfo = nil}

  /// 贵宾卡信息
  public var honouredGuestCard: OSHonouredGuestCard {
    get {return _storage._honouredGuestCard ?? OSHonouredGuestCard()}
    set {_uniqueStorage()._honouredGuestCard = newValue}
  }
  /// Returns true if `honouredGuestCard` has been explicitly set.
  public var hasHonouredGuestCard: Bool {return _storage._honouredGuestCard != nil}
  /// Clears the value of `honouredGuestCard`. Subsequent reads from it will return its default value.
  public mutating func clearHonouredGuestCard() {_uniqueStorage()._honouredGuestCard = nil}

  /// 装扮信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 坐骑信息
public struct OSMount: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 名称
  public var dressName: String = String()

  /// 特效url,优先取该字段,没有则取dressIconSvga字段
  public var effectURL: String = String()

  /// 静态图
  public var dressIcon: String = String()

  /// 动态图
  public var dressIconSvga: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 入场特效
public struct OSAdmissionEffects: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 名称
  public var dressName: String = String()

  /// 特效url地址
  public var effectURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 回到房间请求
public struct OSBackReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 回到房间响应
public struct OSBackRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户个人信息
  public var myself: OSUserInChannel {
    get {return _storage._myself ?? OSUserInChannel()}
    set {_uniqueStorage()._myself = newValue}
  }
  /// Returns true if `myself` has been explicitly set.
  public var hasMyself: Bool {return _storage._myself != nil}
  /// Clears the value of `myself`. Subsequent reads from it will return its default value.
  public mutating func clearMyself() {_uniqueStorage()._myself = nil}

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _storage._channel ?? OSChannelVo()}
    set {_uniqueStorage()._channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return _storage._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {_uniqueStorage()._channel = nil}

  /// 麦位列表信息
  public var userInSeats: [OSUserInSeats] {
    get {return _storage._userInSeats}
    set {_uniqueStorage()._userInSeats = newValue}
  }

  /// 房间声网token
  public var channelToken: String {
    get {return _storage._channelToken}
    set {_uniqueStorage()._channelToken = newValue}
  }

  /// 守护值前三用户信息
  public var wealthUsers: [OSWealthUsers] {
    get {return _storage._wealthUsers}
    set {_uniqueStorage()._wealthUsers = newValue}
  }

  /// 当前活动信息
  public var activityInfo: OSActivityInfo {
    get {return _storage._activityInfo ?? OSActivityInfo()}
    set {_uniqueStorage()._activityInfo = newValue}
  }
  /// Returns true if `activityInfo` has been explicitly set.
  public var hasActivityInfo: Bool {return _storage._activityInfo != nil}
  /// Clears the value of `activityInfo`. Subsequent reads from it will return its default value.
  public mutating func clearActivityInfo() {_uniqueStorage()._activityInfo = nil}

  /// 游戏状态信息
  public var activeStatus: OSActiveStatus {
    get {return _storage._activeStatus ?? OSActiveStatus()}
    set {_uniqueStorage()._activeStatus = newValue}
  }
  /// Returns true if `activeStatus` has been explicitly set.
  public var hasActiveStatus: Bool {return _storage._activeStatus != nil}
  /// Clears the value of `activeStatus`. Subsequent reads from it will return its default value.
  public mutating func clearActiveStatus() {_uniqueStorage()._activeStatus = nil}

  /// 勋章信息
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 房间设置信息
  public var channelSetting: OSChannelSetting {
    get {return _storage._channelSetting ?? OSChannelSetting()}
    set {_uniqueStorage()._channelSetting = newValue}
  }
  /// Returns true if `channelSetting` has been explicitly set.
  public var hasChannelSetting: Bool {return _storage._channelSetting != nil}
  /// Clears the value of `channelSetting`. Subsequent reads from it will return its default value.
  public mutating func clearChannelSetting() {_uniqueStorage()._channelSetting = nil}

  /// 是否是公开厅 0:否 1:是
  public var isOpenChannel: Bool {
    get {return _storage._isOpenChannel}
    set {_uniqueStorage()._isOpenChannel = newValue}
  }

  /// 是否可以送礼给自己 0:否 1:是
  public var giveSelf: Int32 {
    get {return _storage._giveSelf}
    set {_uniqueStorage()._giveSelf = newValue}
  }

  /// 房间其他信息
  public var other: OSChannelOther {
    get {return _storage._other ?? OSChannelOther()}
    set {_uniqueStorage()._other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return _storage._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {_uniqueStorage()._other = nil}

  /// 房主个人信息
  public var owner: OSUserVo {
    get {return _storage._owner ?? OSUserVo()}
    set {_uniqueStorage()._owner = newValue}
  }
  /// Returns true if `owner` has been explicitly set.
  public var hasOwner: Bool {return _storage._owner != nil}
  /// Clears the value of `owner`. Subsequent reads from it will return its default value.
  public mutating func clearOwner() {_uniqueStorage()._owner = nil}

  /// 坐骑信息
  public var mount: OSMount {
    get {return _storage._mount ?? OSMount()}
    set {_uniqueStorage()._mount = newValue}
  }
  /// Returns true if `mount` has been explicitly set.
  public var hasMount: Bool {return _storage._mount != nil}
  /// Clears the value of `mount`. Subsequent reads from it will return its default value.
  public mutating func clearMount() {_uniqueStorage()._mount = nil}

  /// 入场特效
  public var admissionEffects: OSAdmissionEffects {
    get {return _storage._admissionEffects ?? OSAdmissionEffects()}
    set {_uniqueStorage()._admissionEffects = newValue}
  }
  /// Returns true if `admissionEffects` has been explicitly set.
  public var hasAdmissionEffects: Bool {return _storage._admissionEffects != nil}
  /// Clears the value of `admissionEffects`. Subsequent reads from it will return its default value.
  public mutating func clearAdmissionEffects() {_uniqueStorage()._admissionEffects = nil}

  /// 气泡框,客户端用,后端不返回数据
  public var bubbleInfo: OSBubbleInfo {
    get {return _storage._bubbleInfo ?? OSBubbleInfo()}
    set {_uniqueStorage()._bubbleInfo = newValue}
  }
  /// Returns true if `bubbleInfo` has been explicitly set.
  public var hasBubbleInfo: Bool {return _storage._bubbleInfo != nil}
  /// Clears the value of `bubbleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBubbleInfo() {_uniqueStorage()._bubbleInfo = nil}

  /// 装扮信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 退出房间请求
public struct OSExitReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退出房间响应
public struct OSExitRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 房间实时信息请求(房间每5秒轮询)
public struct OSRealTimeInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 房主id
  public var ownerID: String = String()

  /// pk回合id,pk存在时传
  public var pkRoundID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间实时信息响应(房间每5秒轮询)
public struct OSRealTimeInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 右上角在线人数
  public var onlineNumber: Int32 = 0

  /// 麦位列表
  public var userInSeats: [OSUserInSeats] = []

  /// 前三名财富值用户列表
  public var wealthUsers: [OSWealthUsers] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 心跳请求(房间每2分钟轮询)
public struct OSOnlineReportReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 心跳响应(房间每2分钟轮询)
public struct OSOnlineReportRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间详情请求
public struct OSDetailReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间详情响应
public struct OSDetailRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 管理员列表
  public var adminList: [OSAdminList] = []

  /// 房间详情信息
  public var channel: OSChannelDetail {
    get {return _channel ?? OSChannelDetail()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  /// 房间内家族信息
  public var family: OSFamilyInChannel {
    get {return _family ?? OSFamilyInChannel()}
    set {_family = newValue}
  }
  /// Returns true if `family` has been explicitly set.
  public var hasFamily: Bool {return self._family != nil}
  /// Clears the value of `family`. Subsequent reads from it will return its default value.
  public mutating func clearFamily() {self._family = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelDetail? = nil
  fileprivate var _family: OSFamilyInChannel? = nil
}

/// 管理员列表
public struct OSAdminList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 用户系统id
  public var userID: String = String()

  /// 用户id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 麦位号
  public var seat: Int32 = 0

  /// 权限 OWNER:房主 SUPER_ADMIN:超级管理员 ADMIN:管理员 NORMAL:普通用户 FAMILY_OWNER:公会会长 BLACKLIST:黑名单用户
  public var powerType: OSPowerType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间详情信息
public struct OSChannelDetail: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 房间号
  public var channelNo: Int32 = 0

  /// 房间名称
  public var channelName: String = String()

  /// 房主账号
  public var ownerAccountID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间内家族信息
public struct OSFamilyInChannel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 家族系统id
  public var id: String = String()

  /// 家族账号
  public var accountID: Int32 = 0

  /// 家族头像
  public var avatarURL: String = String()

  /// 家族名称
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 编辑房间信息请求
public struct OSEditChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 房间头像,不修改可不传
  public var avatarURL: String = String()

  /// 房间密码(四位),为空字符串表示解锁房间密码
  public var channelPwd: String = String()

  /// 房间名称,不修改可不传
  public var channelName: String = String()

  /// 房间欢迎语,不修改可不传
  public var welcomingSpeech: String = String()

  /// 菜单id,切换房间模式时传
  public var menuID: Int32 = 0

  /// 房间背景,不修改可不传
  public var coverURL: String = String()

  /// 模式类型,切换房间模式时传
  public var channelType: OSChannelType = .unkown

  /// 修改密码时传,false不修改,true修改
  public var updatePassword: Bool = false

  /// 修改欢迎语时传,false不修改,true修改
  public var updateWelcomingSpeech: Bool = false

  /// 房间背景Id,不修改可不传
  public var coverID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 编辑房间信息响应
public struct OSEditChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 礼物栏标签列表请求
public struct OSTagsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物栏标签列表响应
public struct OSTagsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 标签列表
  public var tags: [OSTags] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 标签列表
public struct OSTags: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tag类型 1:礼物;2:背包;3:福袋 4:特权卡
  public var tagType: OSGiftTag = .unknown

  /// 标签名称
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物/福袋/背包列表请求
public struct OSGiftListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 标签类型
  public var tagType: OSGiftTag = .unknown

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物/福袋/背包列表响应
public struct OSGiftListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 礼物/福袋/背包列表
  public var records: [OSGiftVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物/福袋/背包详情
public struct OSGiftVo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var giftID: Int32 {
    get {return _storage._giftID}
    set {_uniqueStorage()._giftID = newValue}
  }

  /// 名称
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// 图标
  public var iconURL: String {
    get {return _storage._iconURL}
    set {_uniqueStorage()._iconURL = newValue}
  }

  /// 礼物价值,为0时显示"免费"
  public var value: Int32 {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  /// 特效
  public var effects: String {
    get {return _storage._effects}
    set {_uniqueStorage()._effects = newValue}
  }

  /// 角标icon
  public var cornerIcon: String {
    get {return _storage._cornerIcon}
    set {_uniqueStorage()._cornerIcon = newValue}
  }

  /// 礼物数量,类型为背包时返回
  public var count: Int32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// 玩法说明,类型为福袋时返回
  public var explainURL: String {
    get {return _storage._explainURL}
    set {_uniqueStorage()._explainURL = newValue}
  }

  /// 开福袋特效,类型为福袋时返回
  public var lotteryEffcts: String {
    get {return _storage._lotteryEffcts}
    set {_uniqueStorage()._lotteryEffcts = newValue}
  }

  /// 背包礼物过期时间戳,类型为背包时返回
  public var expireTime: Int64 {
    get {return _storage._expireTime}
    set {_uniqueStorage()._expireTime = newValue}
  }

  /// 是否可赠送,0:否;1:是,类型为星座礼物类型时返回
  public var giveStatus: Int32 {
    get {return _storage._giveStatus}
    set {_uniqueStorage()._giveStatus = newValue}
  }

  /// 横幅类型;0:厅内;1:全服
  public var bannerType: Int32 {
    get {return _storage._bannerType}
    set {_uniqueStorage()._bannerType = newValue}
  }

  ///自定义告白语
  public var bannerContent: String {
    get {return _storage._bannerContent}
    set {_uniqueStorage()._bannerContent = newValue}
  }

  ///是否弹窗自定义告白语,0:否;1:是
  public var showPop: Int32 {
    get {return _storage._showPop}
    set {_uniqueStorage()._showPop = newValue}
  }

  ///礼物标识(例如：粉丝团-是否入团礼物 (0否1是))
  public var giftFlag: Int32 {
    get {return _storage._giftFlag}
    set {_uniqueStorage()._giftFlag = newValue}
  }

  ///等级限制
  public var level: Int32 {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  /// 过期时间戳ID
  public var expireTimeID: Int64 {
    get {return _storage._expireTimeID}
    set {_uniqueStorage()._expireTimeID = newValue}
  }

  /// 数据库系统时间戳(Id)
  public var dbTimestamp: Int64 {
    get {return _storage._dbTimestamp}
    set {_uniqueStorage()._dbTimestamp = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 房间内查看用户信息请求
public struct OSViewInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 用户系统id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间内查看用户信息响应
public struct OSViewInfoRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户信息
  public var user: OSUserVo {
    get {return _storage._user ?? OSUserVo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// 勋章信息
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 用户在房间内信息
  public var userInChannel: OSUserInChannel {
    get {return _storage._userInChannel ?? OSUserInChannel()}
    set {_uniqueStorage()._userInChannel = newValue}
  }
  /// Returns true if `userInChannel` has been explicitly set.
  public var hasUserInChannel: Bool {return _storage._userInChannel != nil}
  /// Clears the value of `userInChannel`. Subsequent reads from it will return its default value.
  public mutating func clearUserInChannel() {_uniqueStorage()._userInChannel = nil}

  /// 装扮信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  /// 是否已关注对方 0:否 1:是
  public var following: Int32 {
    get {return _storage._following}
    set {_uniqueStorage()._following = newValue}
  }

  /// 关注状态 0:未关注 1:已关注 2:互相关注
  public var followStatus: OSFollowStatus {
    get {return _storage._followStatus}
    set {_uniqueStorage()._followStatus = newValue}
  }

  /// 黑名单状态 0:未拉黑 1:拉黑
  public var blacklistStatus: Int32 {
    get {return _storage._blacklistStatus}
    set {_uniqueStorage()._blacklistStatus = newValue}
  }

  ///用户当前所在房间信息
  public var currentLocation: OSChannelVo {
    get {return _storage._currentLocation ?? OSChannelVo()}
    set {_uniqueStorage()._currentLocation = newValue}
  }
  /// Returns true if `currentLocation` has been explicitly set.
  public var hasCurrentLocation: Bool {return _storage._currentLocation != nil}
  /// Clears the value of `currentLocation`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentLocation() {_uniqueStorage()._currentLocation = nil}

  /// 幻灵数据
  public var eidolonInfo: OSEidolonInfo {
    get {return _storage._eidolonInfo ?? OSEidolonInfo()}
    set {_uniqueStorage()._eidolonInfo = newValue}
  }
  /// Returns true if `eidolonInfo` has been explicitly set.
  public var hasEidolonInfo: Bool {return _storage._eidolonInfo != nil}
  /// Clears the value of `eidolonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearEidolonInfo() {_uniqueStorage()._eidolonInfo = nil}

  /// 粉丝团徽章信息
  public var fansBadge: OSFansClubVo {
    get {return _storage._fansBadge ?? OSFansClubVo()}
    set {_uniqueStorage()._fansBadge = newValue}
  }
  /// Returns true if `fansBadge` has been explicitly set.
  public var hasFansBadge: Bool {return _storage._fansBadge != nil}
  /// Clears the value of `fansBadge`. Subsequent reads from it will return its default value.
  public mutating func clearFansBadge() {_uniqueStorage()._fansBadge = nil}

  /// 我的/Ta的粉丝团信息
  public var clubInfo: OSFansClubVo {
    get {return _storage._clubInfo ?? OSFansClubVo()}
    set {_uniqueStorage()._clubInfo = newValue}
  }
  /// Returns true if `clubInfo` has been explicitly set.
  public var hasClubInfo: Bool {return _storage._clubInfo != nil}
  /// Clears the value of `clubInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClubInfo() {_uniqueStorage()._clubInfo = nil}

  /// 用户礼物藏馆信息
  public var collectHallInfo: OSCollectionHallVo {
    get {return _storage._collectHallInfo ?? OSCollectionHallVo()}
    set {_uniqueStorage()._collectHallInfo = newValue}
  }
  /// Returns true if `collectHallInfo` has been explicitly set.
  public var hasCollectHallInfo: Bool {return _storage._collectHallInfo != nil}
  /// Clears the value of `collectHallInfo`. Subsequent reads from it will return its default value.
  public mutating func clearCollectHallInfo() {_uniqueStorage()._collectHallInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 上麦请求
public struct OSPickUpMicroPhoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 上麦响应
public struct OSPickUpMicroPhoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位用户列表
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 强制上麦请求
public struct OSPickUpMicroPhoneCompelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 强制上麦响应
public struct OSPickUpMicroPhoneCompelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位用户列表
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 下麦请求
public struct OSPutDownMicroPhoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  /// 抱下麦用户id,自己下麦可不传
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 下麦响应
public struct OSPutDownMicroPhoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位用户列表
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 换麦请求
public struct OSExchangeMicroPhoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 换麦响应
public struct OSExchangeMicroPhoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位用户列表
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 禁止发言(不能发公屏)请求
public struct OSWordsNotAllowedReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 禁止发言(不能发公屏)响应
public struct OSWordsNotAllowedRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 解除禁言(允许发公屏)请求
public struct OSWordsAllowedReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 解除禁言(允许发公屏)响应
public struct OSWordsAllowedRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 锁定麦位请求
public struct OSLockMicroPhoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 锁定麦位响应
public struct OSLockMicroPhoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 解锁麦位请求
public struct OSUnLockMicrophoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 解锁麦位响应
public struct OSUnLockMicrophoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 锁定全部麦位请求
public struct OSLockAllMicrophoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 锁定全部麦位响应
public struct OSLockAllMicrophoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 解锁全部麦位请求
public struct OSUnLockAllMicrophoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 解锁全部麦位响应
public struct OSUnLockAllMicrophoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 闭麦请求
public struct OSLockSeatVoiceReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 闭麦响应
public struct OSLockSeatVoiceRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 解除闭麦请求
public struct OSUnLockSeatVoiceReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,0-8
  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 解除闭麦响应
public struct OSUnLockSeatVoiceRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 开麦(允许麦克风说话)请求
public struct OSTurnOntheMicrophoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户Id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 开麦(允许麦克风说话)响应
public struct OSTurnOntheMicrophoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 禁麦(禁止麦克风说话)请求
public struct OSTurnOfftheMicrophoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户Id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 禁麦(禁止麦克风说话)响应
public struct OSTurnOfftheMicrophoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 抱麦请求
public struct OSHoldOnMicroPhoneReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位号,1-8
  public var seatIndex: Int32 = 0

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 抱麦响应
public struct OSHoldOnMicroPhoneRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位用户列表
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 踢出房间请求
public struct OSKickYouOutReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 踢出房间响应
public struct OSKickYouOutRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 提示
  public var tip: String = String()

  /// 麦位列表
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 设置为超级管理员请求
public struct OSSetSuperAdminReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 设置为超级管理员响应
public struct OSSetSuperAdminRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 取消超级管理员请求
public struct OSCancelSuperAdminReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 取消超级管理员响应
public struct OSCancelSuperAdminRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 设置为管理员请求
public struct OSSetAdminReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 设置为管理员响应
public struct OSSetAdminRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 取消管理员请求
public struct OSCancelAdminReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 取消管理员响应
public struct OSCancelAdminRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 切换麦位布局请求
public struct OSExchangeSeatLayoutReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 麦位布局 1:横向排列(传统布局) 2:纵向排列(聊天模式)
  public var seatLayout: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 切换麦位布局响应
public struct OSExchangeSeatLayoutRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关闭公屏请求
public struct OSWordsNotAllowedAllReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关闭公屏响应
public struct OSWordsNotAllowedAllRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 开启公屏请求
public struct OSWordsAllowedAllReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 开启公屏响应
public struct OSWordsAllowedAllRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: OSChannelVo {
    get {return _channel ?? OSChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: OSChannelVo? = nil
}

/// 送礼物请求
public struct OSGivePresentsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 目标用户
  public var targetIds: [String] = []

  /// 横幅类型;0:厅内;1:全服
  public var bannerType: Int32 = 0

  ///自定义告白语
  public var bannerContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送礼物响应
public struct OSGivePresentsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 礼物信息
  public var gift: OSGiftVo {
    get {return _gift ?? OSGiftVo()}
    set {_gift = newValue}
  }
  /// Returns true if `gift` has been explicitly set.
  public var hasGift: Bool {return self._gift != nil}
  /// Clears the value of `gift`. Subsequent reads from it will return its default value.
  public mutating func clearGift() {self._gift = nil}

  /// 心动值增加数值
  public var lovenum: Int32 = 0

  /// 麦位列表
  public var userInSeats: [OSUserInSeats] = []

  /// 勋章列表
  public var medalList: [OSMedalList] = []

  /// 是否发起横幅通知 0:不发起横幅,1:发起横幅
  public var isGiftBanner: Int32 = 0

  /// 钱包信息
  public var wallet: OSWalletVo {
    get {return _wallet ?? OSWalletVo()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  /// 剩余钻石数量
  public var diamondsAmount: Int32 = 0

  /// 游戏币数量
  public var gameCoin: Int32 = 0

  /// 剩余水晶数量
  public var crystalAmount: Int32 = 0

  /// 系统时间戳
  public var systemTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gift: OSGiftVo? = nil
  fileprivate var _wallet: OSWalletVo? = nil
}

/// 钱包信息
public struct OSWalletVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 剩余钻石数量
  public var diamondsAmount: Int32 = 0

  /// 游戏币数量
  public var gameCoin: Int32 = 0

  /// 剩余水晶数量
  public var crystalAmount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送福袋请求
public struct OSGiveLuckyBagPresentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 目标用户
  public var targetIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送福袋响应
public struct OSGiveLuckyBagPresentRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 福袋礼物列表
  public var luckyGifts: [OSLuckyGiftVo] = []

  /// 心动值增加数值
  public var lovenum: Int32 = 0

  /// 麦位列表
  public var userInSeats: [OSUserInSeats] = []

  /// 勋章列表
  public var medalList: [OSMedalList] = []

  /// 是否发起横幅通知 0:不发起横幅,1:发起横幅
  public var isGiftBanner: Int32 = 0

  /// 钱包信息
  public var wallet: OSWalletVo {
    get {return _wallet ?? OSWalletVo()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  /// 剩余钻石数量
  public var diamondsAmount: Int32 = 0

  /// 游戏币数量
  public var gameCoin: Int32 = 0

  /// 剩余水晶数量
  public var crystalAmount: Int32 = 0

  /// 系统时间戳
  public var systemTime: Int64 = 0

  /// 福袋名称
  public var lotteryName: String = String()

  /// 福袋动效
  public var lotteryEffcts: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wallet: OSWalletVo? = nil
}

/// 福袋礼物信息
public struct OSLuckyGiftVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物名称
  public var giftName: String = String()

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 礼物icon
  public var giftIconURL: String = String()

  /// 心动值
  public var lovenum: Int32 = 0

  /// 礼物价值
  public var giftValue: Int32 = 0

  /// 礼物动效,可返回空
  public var giftEffects: String = String()

  /// 收礼物用户Id
  public var targetID: String = String()

  /// 收礼用户昵称
  public var targetName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送背包请求
public struct OSGivePresentsUseBackpackReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 目标用户
  public var targetIds: [String] = []

  /// 横幅类型;0:厅内;1:全服
  public var bannerType: Int32 = 0

  ///自定义告白语
  public var bannerContent: String = String()

  /// 礼物过期时间戳ID
  public var expireTimeID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送背包响应
public struct OSGivePresentsUseBackpackRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 礼物信息
  public var gift: OSGiftVo {
    get {return _gift ?? OSGiftVo()}
    set {_gift = newValue}
  }
  /// Returns true if `gift` has been explicitly set.
  public var hasGift: Bool {return self._gift != nil}
  /// Clears the value of `gift`. Subsequent reads from it will return its default value.
  public mutating func clearGift() {self._gift = nil}

  /// 心动值增加数值
  public var lovenum: Int32 = 0

  /// 麦位列表
  public var userInSeats: [OSUserInSeats] = []

  /// 勋章列表
  public var medalList: [OSMedalList] = []

  /// 是否发起横幅通知 0:不发起横幅,1:发起横幅
  public var isGiftBanner: Int32 = 0

  /// 钱包信息
  public var wallet: OSWalletVo {
    get {return _wallet ?? OSWalletVo()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  /// 剩余钻石数量
  public var diamondsAmount: Int32 = 0

  /// 游戏币数量
  public var gameCoin: Int32 = 0

  /// 剩余水晶数量
  public var crystalAmount: Int32 = 0

  /// 系统时间戳
  public var systemTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gift: OSGiftVo? = nil
  fileprivate var _wallet: OSWalletVo? = nil
}

/// 送粉丝团礼物请求
public struct OSGivePresentsFansClubReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 目标用户
  public var targetIds: [String] = []

  /// 横幅类型;0:厅内;1:全服
  public var bannerType: Int32 = 0

  ///自定义告白语
  public var bannerContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送粉丝团礼物响应
public struct OSGivePresentsFansClubRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 礼物信息
  public var gift: OSGiftVo {
    get {return _gift ?? OSGiftVo()}
    set {_gift = newValue}
  }
  /// Returns true if `gift` has been explicitly set.
  public var hasGift: Bool {return self._gift != nil}
  /// Clears the value of `gift`. Subsequent reads from it will return its default value.
  public mutating func clearGift() {self._gift = nil}

  /// 心动值增加数值
  public var lovenum: Int32 = 0

  /// 麦位列表
  public var userInSeats: [OSUserInSeats] = []

  /// 勋章列表
  public var medalList: [OSMedalList] = []

  /// 是否发起横幅通知 0:不发起横幅,1:发起横幅
  public var isGiftBanner: Int32 = 0

  /// 钱包信息
  public var wallet: OSWalletVo {
    get {return _wallet ?? OSWalletVo()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  /// 剩余钻石数量
  public var diamondsAmount: Int32 = 0

  /// 游戏币数量
  public var gameCoin: Int32 = 0

  /// 剩余水晶数量
  public var crystalAmount: Int32 = 0

  /// 系统时间戳
  public var systemTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gift: OSGiftVo? = nil
  fileprivate var _wallet: OSWalletVo? = nil
}

/// 特权卡列表请求
public struct OSPrivilegeCardsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 房主系统id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 特权卡列表响应
public struct OSPrivilegeCardsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 特权卡信息
  public var records: [OSPrivilegeCardVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 特权卡信息
public struct OSPrivilegeCardVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 特权卡id
  public var privilegeCardID: Int64 = 0

  /// 特权卡名称
  public var cardName: String = String()

  /// 特权卡图片链接
  public var cardURL: String = String()

  /// 特权卡类型(0:公会卡 1:厅卡)
  public var cardType: Int32 = 0

  /// 特权卡说明
  public var cardDescription: String = String()

  /// 每日可使用的次数
  public var effectiveCount: Int32 = 0

  /// 今日已使用的次数
  public var todayUseCount: Int32 = 0

  /// 过期时间戳
  public var expireTime: Int64 = 0

  /// 房间是否可使用状态(0不可用 1可用)
  public var channelAvailableStatus: Int32 = 0

  /// 所属用户账号
  public var accountID: Int32 = 0

  /// 所属用户系统id
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 使用特权卡请求
public struct OSUsePrivilegeCardReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 特权卡id
  public var privilegeCardID: Int64 = 0

  /// 房主系统id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 使用特权卡响应
public struct OSUsePrivilegeCardRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 特权卡剩余次数(每日可使用的次数 - 今日已使用的次数 获得)
  public var residueCount: Int32 = 0

  /// 特权卡信息
  public var privilegeCard: OSPrivilegeCardVo {
    get {return _privilegeCard ?? OSPrivilegeCardVo()}
    set {_privilegeCard = newValue}
  }
  /// Returns true if `privilegeCard` has been explicitly set.
  public var hasPrivilegeCard: Bool {return self._privilegeCard != nil}
  /// Clears the value of `privilegeCard`. Subsequent reads from it will return its default value.
  public mutating func clearPrivilegeCard() {self._privilegeCard = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _privilegeCard: OSPrivilegeCardVo? = nil
}

/// 开启心动值请求
public struct OSOpenLoveNumReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 开启心动值响应
public struct OSOpenLoveNumRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关闭心动值请求
public struct OSCloseLoveNumReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关闭心动值响应
public struct OSCloseLoveNumRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 清空心动值请求
public struct OSEmptyLoveNumReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户Id(清除指定用户必传)
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 清空心动值响应
public struct OSEmptyLoveNumRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位列表信息
  public var userInSeats: [OSUserInSeats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间排行榜请求
public struct OSChannelRankingsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 类型
  public var type: OSChannelRankType = .online

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间排行榜响应
public struct OSChannelRankingsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 排名列表
  public var rankings: [OSRankingVo] = []

  /// 个人排名信息
  public var self_p: OSRankingVo {
    get {return _self_p ?? OSRankingVo()}
    set {_self_p = newValue}
  }
  /// Returns true if `self_p` has been explicitly set.
  public var hasSelf_p: Bool {return self._self_p != nil}
  /// Clears the value of `self_p`. Subsequent reads from it will return its default value.
  public mutating func clearSelf_p() {self._self_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _self_p: OSRankingVo? = nil
}

/// 排名信息
public struct OSRankingVo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 排名,-1代表没有送礼/收礼数据,-1代表送礼/收礼了但是不上榜,1-50代表上榜
  public var index: Int32 {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  /// 用户系统id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// 用户id
  public var accountID: String {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  /// 性别
  public var gender: OSGender {
    get {return _storage._gender}
    set {_uniqueStorage()._gender = newValue}
  }

  /// 昵称
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  /// 头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 财富值/魅力值
  public var giftValue: Int32 {
    get {return _storage._giftValue}
    set {_uniqueStorage()._giftValue = newValue}
  }

  /// 所在麦位,0-8为主播位,99为观众,即没有在麦上
  public var seat: Int32 {
    get {return _storage._seat}
    set {_uniqueStorage()._seat = newValue}
  }

  /// 权限
  public var powerType: OSPowerType {
    get {return _storage._powerType}
    set {_uniqueStorage()._powerType = newValue}
  }

  /// 勋章列表
  public var userMedalList: [OSMedalList] {
    get {return _storage._userMedalList}
    set {_uniqueStorage()._userMedalList = newValue}
  }

  /// 和上一名相差守护值,个人排名才返回
  public var differGiftValue: Int32 {
    get {return _storage._differGiftValue}
    set {_uniqueStorage()._differGiftValue = newValue}
  }

  /// 守护总值,只有在线榜才返回
  public var totalGiftValue: Int32 {
    get {return _storage._totalGiftValue}
    set {_uniqueStorage()._totalGiftValue = newValue}
  }

  /// 装扮信息,这里只返回了头像框信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  /// 贵宾卡信息
  public var honouredGuestCard: OSHonouredGuestCard {
    get {return _storage._honouredGuestCard ?? OSHonouredGuestCard()}
    set {_uniqueStorage()._honouredGuestCard = newValue}
  }
  /// Returns true if `honouredGuestCard` has been explicitly set.
  public var hasHonouredGuestCard: Bool {return _storage._honouredGuestCard != nil}
  /// Clears the value of `honouredGuestCard`. Subsequent reads from it will return its default value.
  public mutating func clearHonouredGuestCard() {_uniqueStorage()._honouredGuestCard = nil}

  /// 粉丝团徽章信息
  public var fansBadge: OSFansClubVo {
    get {return _storage._fansBadge ?? OSFansClubVo()}
    set {_uniqueStorage()._fansBadge = newValue}
  }
  /// Returns true if `fansBadge` has been explicitly set.
  public var hasFansBadge: Bool {return _storage._fansBadge != nil}
  /// Clears the value of `fansBadge`. Subsequent reads from it will return its default value.
  public mutating func clearFansBadge() {_uniqueStorage()._fansBadge = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 设置公告请求
public struct OSAnnouncementSettingReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 标题 (announceContent不为空必须传)
  public var announceTitle: String = String()

  /// 内容
  public var announceContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 设置公告响应
public struct OSAnnouncementSettingRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间设置信息
  public var channelSetting: OSChannelSetting {
    get {return _channelSetting ?? OSChannelSetting()}
    set {_channelSetting = newValue}
  }
  /// Returns true if `channelSetting` has been explicitly set.
  public var hasChannelSetting: Bool {return self._channelSetting != nil}
  /// Clears the value of `channelSetting`. Subsequent reads from it will return its default value.
  public mutating func clearChannelSetting() {self._channelSetting = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channelSetting: OSChannelSetting? = nil
}

/// 在线用户列表请求
public struct OSOnlineUserReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  /// 角色权限（不传默认查全部）
  public var powerType: OSPowerType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 在线用户列表响应
public struct OSOnlineUserRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 用户列表
  public var records: [OSRankingVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PK话题列表请求
public struct OSPkTopicsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PK话题列表响应
public struct OSPkTopicsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PK话题信息
  public var pkTopics: [OSPkTopicsVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PK话题信息
public struct OSPkTopicsVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 话题id
  public var id: Int32 = 0

  /// 话题名称
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 创建PK请求
public struct OSCreatePkGameReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 话题名称
  public var topic: String = String()

  /// PK类型
  public var pkType: OSPkType = .oneToOne

  /// 时长
  public var duration: Int32 = 0

  /// 1v1蓝方用户id
  public var blueTeam: String = String()

  /// 1v1红方用户id
  public var redTeam: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 创建PK响应
public struct OSCreatePkGameRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk信息
  public var pkGame: OSPkGame {
    get {return _pkGame ?? OSPkGame()}
    set {_pkGame = newValue}
  }
  /// Returns true if `pkGame` has been explicitly set.
  public var hasPkGame: Bool {return self._pkGame != nil}
  /// Clears the value of `pkGame`. Subsequent reads from it will return its default value.
  public mutating func clearPkGame() {self._pkGame = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pkGame: OSPkGame? = nil
}

/// 参与者信息
public struct OSParticipantVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk房间id
  public var pkChannelID: String = String()

  /// pk回合id
  public var pkID: String = String()

  /// pk队伍
  public var team: OSPkTeam = .teamUnknown

  /// 用户系统id
  public var userID: String = String()

  /// 用户账号id
  public var accountID: Int32 = 0

  /// 用户昵称
  public var nickname: String = String()

  /// 用户头像
  public var avatarURL: String = String()

  /// 心动值
  public var lovenum: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送礼老板信息
public struct OSPkBossUserVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 礼物价值
  public var value: Int32 = 0

  /// pk队伍
  public var team: OSPkTeam = .teamUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 跨厅房间信息
public struct OSPkChannelInfoVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 房间号
  public var channelNo: Int32 = 0

  /// 房间名称
  public var channelName: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 房主Id
  public var ownerID: String = String()

  /// 0号麦位锁状态
  public var seat0Status: Int32 = 0

  /// 1号麦位锁状态
  public var seat1Status: Int32 = 0

  /// 2号麦位锁状态
  public var seat2Status: Int32 = 0

  /// 3号麦位锁状态
  public var seat3Status: Int32 = 0

  /// 4号麦位锁状态
  public var seat4Status: Int32 = 0

  /// 5号麦位锁状态
  public var seat5Status: Int32 = 0

  /// 6号麦位锁状态
  public var seat6Status: Int32 = 0

  /// 7号麦位锁状态
  public var seat7Status: Int32 = 0

  /// 8号麦位锁状态
  public var seat8Status: Int32 = 0

  /// 观众席开关
  public var seatsSwitch: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 搜索Pk房间请求
public struct OSSearchPkChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 搜索id
  public var accountID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 搜索Pk房间响应
public struct OSSearchPkChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk房间信息
  public var pkChannelInfo: [OSPkChannelInfoVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 发起跨厅PK请求
public struct OSAskChannelPkReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 当前所在房间id
  public var channelID: String = String()

  /// 目标房间id
  public var targetChannelID: String = String()

  /// pk时长
  public var duration: Int32 = 0

  /// pk话题
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 发起跨厅PK响应
public struct OSAskChannelPkRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 接受跨厅PK请求
public struct OSAcceptChannelPkReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 当前所在房间id
  public var channelID: String = String()

  /// 目标房间id
  public var targetChannelID: String = String()

  /// pk时长
  public var duration: Int32 = 0

  /// pk话题
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 接受跨厅PK响应
public struct OSAcceptChannelPkRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 拒绝跨厅PK请求
public struct OSRefuseChannelPkReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 当前所在房间id
  public var channelID: String = String()

  /// 目标房间id
  public var targetChannelID: String = String()

  /// pk时长
  public var duration: Int32 = 0

  /// pk话题
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 拒绝跨厅PK响应
public struct OSRefuseChannelPkRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 停止PK请求
public struct OSStopPkGameReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// pk回合id
  public var pkRoundID: String = String()

  /// pk类型
  public var type: OSPkType = .oneToOne

  /// 结束跨厅pk时传,目标房间id
  public var targetChannelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 停止PK响应
public struct OSStopPkGameRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk信息
  public var pkGame: OSPkGame {
    get {return _pkGame ?? OSPkGame()}
    set {_pkGame = newValue}
  }
  /// Returns true if `pkGame` has been explicitly set.
  public var hasPkGame: Bool {return self._pkGame != nil}
  /// Clears the value of `pkGame`. Subsequent reads from it will return its default value.
  public mutating func clearPkGame() {self._pkGame = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pkGame: OSPkGame? = nil
}

/// PK记录请求
public struct OSPkLogReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PK记录响应
public struct OSPkLogRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// pk信息
  public var records: [OSPkGame] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 随机房间名称请求
public struct OSRandomChannelNameReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 随机房间名称响应
public struct OSRandomChannelNameRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 随机名称信息
  public var randomChannelName: [OSRandomChannelNameVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 随机名称信息
public struct OSRandomChannelNameVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 菜单id
  public var menuID: Int32 = 0

  /// 房间名称列表
  public var names: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间礼物墙请求
public struct OSChannelGiftWallReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间礼物墙响应
public struct OSChannelGiftWallRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 礼物墙信息
  public var records: [OSChannelGiftWallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物墙信息
public struct OSChannelGiftWallVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物名称
  public var giftName: String = String()

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 礼物icon
  public var giftIconURL: String = String()

  /// 是否显示限时角标 0.不显示 1.显示
  public var timedCornerMark: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加入房间黑名单请求
public struct OSJoinChannelBlackListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 拉黑用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加入房间黑名单响应
public struct OSJoinChannelBlackListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 取消房间黑名单请求
public struct OSRemoveChannelBlackListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 取消拉黑用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 取消房间黑名单响应
public struct OSRemoveChannelBlackListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间管理员列表请求
public struct OSChannelAdminListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间管理员列表响应
public struct OSChannelAdminListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 超级管理员列表
  public var superAdminList: [OSChatChannelUserVo] = []

  /// 管理员列表
  public var adminList: [OSChatChannelUserVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间黑名单用户列表请求
public struct OSChannelBlackListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  /// 搜索关键字
  public var searchStr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间黑名单用户列表响应
public struct OSChannelBlackListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 用户列表
  public var records: [OSRankingVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间禁言用户列表请求
public struct OSChannelProhibitListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  /// 搜索关键字
  public var searchStr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间黑名单用户列表响应
public struct OSChannelProhibitListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 用户列表
  public var records: [OSRankingVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSAfterJoinReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSAfterJoinRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 幻灵数据
  public var eidolonInfo: OSEidolonInfo {
    get {return _eidolonInfo ?? OSEidolonInfo()}
    set {_eidolonInfo = newValue}
  }
  /// Returns true if `eidolonInfo` has been explicitly set.
  public var hasEidolonInfo: Bool {return self._eidolonInfo != nil}
  /// Clears the value of `eidolonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearEidolonInfo() {self._eidolonInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _eidolonInfo: OSEidolonInfo? = nil
}

public struct OSLoadRocketInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSLoadRocketInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///火箭数据数组
  public var list: [OSRocket] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSRocket: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///房间id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  ///用户id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  ///用户头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  ///用户昵称
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  ///火箭图标
  public var iconURL: String {
    get {return _storage._iconURL}
    set {_uniqueStorage()._iconURL = newValue}
  }

  ///已达到顶级次数，不为空，默认为0
  public var alreadyCount: Int32 {
    get {return _storage._alreadyCount}
    set {_uniqueStorage()._alreadyCount = newValue}
  }

  ///火箭动画
  public var animationURL: String {
    get {return _storage._animationURL}
    set {_uniqueStorage()._animationURL = newValue}
  }

  ///达到顶级次数（实时），不为空，默认为0*
  public var count: Int32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  ///创建时间戳（秒）
  public var createTimeStamp: Int64 {
    get {return _storage._createTimeStamp}
    set {_uniqueStorage()._createTimeStamp = newValue}
  }

  ///当前等级，不为空，默认为0*
  public var currentLevel: Int32 {
    get {return _storage._currentLevel}
    set {_uniqueStorage()._currentLevel = newValue}
  }

  ///当前等级的最大值
  public var currentLevelMaxValue: Int32 {
    get {return _storage._currentLevelMaxValue}
    set {_uniqueStorage()._currentLevelMaxValue = newValue}
  }

  ///服务器当前时间戳（秒）
  public var currentTimeStamp: Int64 {
    get {return _storage._currentTimeStamp}
    set {_uniqueStorage()._currentTimeStamp = newValue}
  }

  ///总等级
  public var totalLevel: Int32 {
    get {return _storage._totalLevel}
    set {_uniqueStorage()._totalLevel = newValue}
  }

  ///过期时间戳（秒）
  public var expireTimeStamp: Int64 {
    get {return _storage._expireTimeStamp}
    set {_uniqueStorage()._expireTimeStamp = newValue}
  }

  ///icon的高度
  public var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  ///距离下一等级还差多少值
  public var diffValue: Int32 {
    get {return _storage._diffValue}
    set {_uniqueStorage()._diffValue = newValue}
  }

  ///最大级的值
  public var maxValue: Int32 {
    get {return _storage._maxValue}
    set {_uniqueStorage()._maxValue = newValue}
  }

  public var needReduceValue: Int32 {
    get {return _storage._needReduceValue}
    set {_uniqueStorage()._needReduceValue = newValue}
  }

  ///是否显示新征程标签;0=不显示，1=显示*
  public var showLabel: Int32 {
    get {return _storage._showLabel}
    set {_uniqueStorage()._showLabel = newValue}
  }

  ///当前值
  public var value: Int32 {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct OSHoursListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 小时榜类型 0：本小时， 1：上一小时
  public var hourType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSHoursListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///小时榜-榜单列表
  public var topList: [OSHoursTopListVo] = []

  /// 我的房间排名
  public var myRank: OSHoursTopListVo {
    get {return _myRank ?? OSHoursTopListVo()}
    set {_myRank = newValue}
  }
  /// Returns true if `myRank` has been explicitly set.
  public var hasMyRank: Bool {return self._myRank != nil}
  /// Clears the value of `myRank`. Subsequent reads from it will return its default value.
  public mutating func clearMyRank() {self._myRank = nil}

  ///剩余秒数
  public var remainSeconds: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _myRank: OSHoursTopListVo? = nil
}

///小时榜-榜单列表数据
public struct OSHoursTopListVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///平台类型
  public var appFlag1: Int32 = 0

  ///头像地址
  public var avatarURL: String = String()

  ///频道ID
  public var channelID: String = String()

  ///房间名称
  public var channelName: String = String()

  ///和上一名相差钻石数
  public var differCount: Int32 = 0

  ///是否关注，0：未关注，1：已关注，2：互相关注（好友）
  public var following: Int32 = 0

  ///一小时内收礼钻石数
  public var giveGiftValue: Int32 = 0

  ///排名
  public var hoursRanking: Int32 = 0

  ///用户id
  public var ownerID: String = String()

  ///用户昵称
  public var ownerNickname: String = String()

  /// pk状态 0无pk 1正在pk
  public var pkStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///我的/Ta粉丝团信息请求
public struct OSMyClubReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///目标用户Id(不为空默认查询他人信息)
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///我的/Ta粉丝团信息响应
public struct OSMyClubRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 我的/Ta的粉丝团信息
  public var clubInfo: OSFansClubVo {
    get {return _clubInfo ?? OSFansClubVo()}
    set {_clubInfo = newValue}
  }
  /// Returns true if `clubInfo` has been explicitly set.
  public var hasClubInfo: Bool {return self._clubInfo != nil}
  /// Clears the value of `clubInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClubInfo() {self._clubInfo = nil}

  /// 默认勋章等级
  public var badgeLevel: Int32 = 0

  /// 默认勋章Icon
  public var badgeIcon: String = String()

  /// 粉丝团用户信息
  public var userClubInfo: OSFansClubVo {
    get {return _userClubInfo ?? OSFansClubVo()}
    set {_userClubInfo = newValue}
  }
  /// Returns true if `userClubInfo` has been explicitly set.
  public var hasUserClubInfo: Bool {return self._userClubInfo != nil}
  /// Clears the value of `userClubInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserClubInfo() {self._userClubInfo = nil}

  /// 今日亲密度信息
  public var todayIntimacyInfo: OSIntimacyVo {
    get {return _todayIntimacyInfo ?? OSIntimacyVo()}
    set {_todayIntimacyInfo = newValue}
  }
  /// Returns true if `todayIntimacyInfo` has been explicitly set.
  public var hasTodayIntimacyInfo: Bool {return self._todayIntimacyInfo != nil}
  /// Clears the value of `todayIntimacyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTodayIntimacyInfo() {self._todayIntimacyInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clubInfo: OSFansClubVo? = nil
  fileprivate var _userClubInfo: OSFansClubVo? = nil
  fileprivate var _todayIntimacyInfo: OSIntimacyVo? = nil
}

///加入粉丝团请求
public struct OSJoinClubReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///粉丝团Id
  public var clubID: Int64 = 0

  ///礼物Id
  public var giftID: Int32 = 0

  ///礼物数量
  public var count: Int32 = 0

  ///当前房间Id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///加入粉丝团响应
public struct OSJoinClubRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 我的/Ta的粉丝团信息
  public var clubInfo: OSFansClubVo {
    get {return _clubInfo ?? OSFansClubVo()}
    set {_clubInfo = newValue}
  }
  /// Returns true if `clubInfo` has been explicitly set.
  public var hasClubInfo: Bool {return self._clubInfo != nil}
  /// Clears the value of `clubInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClubInfo() {self._clubInfo = nil}

  /// 粉丝团用户信息
  public var userClubInfo: OSFansClubVo {
    get {return _userClubInfo ?? OSFansClubVo()}
    set {_userClubInfo = newValue}
  }
  /// Returns true if `userClubInfo` has been explicitly set.
  public var hasUserClubInfo: Bool {return self._userClubInfo != nil}
  /// Clears the value of `userClubInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserClubInfo() {self._userClubInfo = nil}

  /// 今日亲密度信息
  public var todayIntimacyInfo: OSIntimacyVo {
    get {return _todayIntimacyInfo ?? OSIntimacyVo()}
    set {_todayIntimacyInfo = newValue}
  }
  /// Returns true if `todayIntimacyInfo` has been explicitly set.
  public var hasTodayIntimacyInfo: Bool {return self._todayIntimacyInfo != nil}
  /// Clears the value of `todayIntimacyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTodayIntimacyInfo() {self._todayIntimacyInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clubInfo: OSFansClubVo? = nil
  fileprivate var _userClubInfo: OSFansClubVo? = nil
  fileprivate var _todayIntimacyInfo: OSIntimacyVo? = nil
}

public struct OSBuyExpressionReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///频道ID
  public var channelID: String = String()

  public var id: Int64 = 0

  /// 时长
  public var duration: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSBuyExpressionRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 剩余钻石
  public var diamond: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSCommitExpressionReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///频道ID
  public var channelID: String = String()

  ///动作id
  public var expressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSCommitExpressionRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSLoadExpressionReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSLoadExpressionRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///列表
  public var records: [OSExpression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSExpression: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///表情id
  public var expressionID: String = String()

  ///名称
  public var name: String = String()

  ///图标
  public var imgURL: String = String()

  ///角标
  public var cornerIcon: String = String()

  ///id
  public var id: Int64 = 0

  ///限定类型;1=免费,2=付费,3=财富魅力要求
  public var limitType: Int32 = 0

  ///购买提示
  public var purchaseHint: String = String()

  ///价格
  public var prices: [OSGoodsPrice] = []

  ///状态;0=未购买，1=已购买
  public var status: Int32 = 0

  ///购买提示类型;0=财富,1=魅力
  public var purchaseHintType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///个播房间信息请求
public struct OSPersonalChannelInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///个播房间信息响应
public struct OSPersonalChannelInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 直播开关 0关1开
  public var liveSwitch: Int32 = 0

  /// 观众席开关 0关1开
  public var seatsSwitch: Int32 = 0

  /// 是否展示心愿礼物入口 0关1开
  public var wishDisplay: Int32 = 0

  /// 心愿礼物数据
  public var userWishGift: OSUserWishGiftVo {
    get {return _userWishGift ?? OSUserWishGiftVo()}
    set {_userWishGift = newValue}
  }
  /// Returns true if `userWishGift` has been explicitly set.
  public var hasUserWishGift: Bool {return self._userWishGift != nil}
  /// Clears the value of `userWishGift`. Subsequent reads from it will return its default value.
  public mutating func clearUserWishGift() {self._userWishGift = nil}

  /// 粉丝团默认入团礼物
  public var clubGiftInfo: OSFansClubGiftVo {
    get {return _clubGiftInfo ?? OSFansClubGiftVo()}
    set {_clubGiftInfo = newValue}
  }
  /// Returns true if `clubGiftInfo` has been explicitly set.
  public var hasClubGiftInfo: Bool {return self._clubGiftInfo != nil}
  /// Clears the value of `clubGiftInfo`. Subsequent reads from it will return its default value.
  public mutating func clearClubGiftInfo() {self._clubGiftInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userWishGift: OSUserWishGiftVo? = nil
  fileprivate var _clubGiftInfo: OSFansClubGiftVo? = nil
}

///设置个播模式观众席状态请求
public struct OSPersonalSeatsConfigReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 观众席状态，0：关闭，1：开启
  public var seatsSwitch: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///设置个播模式观众席状态响应
public struct OSPersonalSeatsConfigRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///设置个播模式直播状态请求
public struct OSPersonalLiveConfigReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 直播开关，0：暂停，1：开启
  public var liveSwitch: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///设置个播模式观众席状态响应
public struct OSPersonalLiveConfigRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///获得心愿礼物（查询任务进度)请求
public struct OSWishGiftInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///获得心愿礼物（查询任务进度)响应
public struct OSWishGiftInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否已达成，0：进行中，1：已完成
  public var finish: Int32 = 0

  /// 最大礼物限制价值
  public var maxLimitValue: Int32 = 0

  /// 心愿进度列表
  public var progressList: [OSWishGiftProgress] = []

  /// 前三用户列表
  public var topUser: [OSWishGifttopUser] = []

  /// 助力人数
  public var userCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///设置心愿礼物请求
public struct OSWishGiftConfigReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 心愿礼物开关，0：关闭，1：开启
  public var wishSwitch: Int32 = 0

  /// 心愿礼物列表，单个礼物参数（giftId：礼物id，giftCount：礼物数量）
  public var userWishGifts: [OSUserWishGift] = []

  /// 修改的心愿礼物列表，单个礼物参数（giftId：礼物id，giftCount：礼物数量）
  public var editWishGifts: [OSUserWishGift] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///设置心愿礼物响应
public struct OSWishGiftConfigRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否已达成，0：进行中，1：已完成
  public var finish: Int32 = 0

  /// 最大礼物限制价值
  public var maxLimitValue: Int32 = 0

  /// 心愿进度列表
  public var progressList: [OSWishGiftProgress] = []

  /// 前三用户列表
  public var topUser: [OSWishGifttopUser] = []

  /// 助力人数
  public var userCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSUserWishGift: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物数量
  public var giftCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///重启心愿礼物请求
public struct OSWishGiftRestartReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///重启心愿礼物响应
public struct OSWishGiftRestartRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否已达成，0：进行中，1：已完成
  public var finish: Int32 = 0

  /// 最大礼物限制价值
  public var maxLimitValue: Int32 = 0

  /// 心愿进度列表
  public var progressList: [OSWishGiftProgress] = []

  /// 前三用户列表
  public var topUser: [OSWishGifttopUser] = []

  /// 助力人数
  public var userCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///删除心愿礼物请求
public struct OSWishGiftDelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 礼物id
  public var giftID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///删除心愿礼物响应
public struct OSWishGiftDelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///获取用户娱乐玩法相关信息请求
public struct OSUserPlayInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///获取用户娱乐玩法相关信息响应
public struct OSUserPlayInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var collectHallInfo: OSCollectionHallVo {
    get {return _collectHallInfo ?? OSCollectionHallVo()}
    set {_collectHallInfo = newValue}
  }
  /// Returns true if `collectHallInfo` has been explicitly set.
  public var hasCollectHallInfo: Bool {return self._collectHallInfo != nil}
  /// Clears the value of `collectHallInfo`. Subsequent reads from it will return its default value.
  public mutating func clearCollectHallInfo() {self._collectHallInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _collectHallInfo: OSCollectionHallVo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createReq"),
    2: .same(proto: "joinReq"),
    3: .same(proto: "backReq"),
    4: .same(proto: "exitReq"),
    5: .same(proto: "realTimeInfoReq"),
    6: .same(proto: "onlineReportReq"),
    7: .same(proto: "detailReq"),
    8: .same(proto: "editChannelReq"),
    9: .same(proto: "tagsReq"),
    10: .same(proto: "giftListReq"),
    11: .same(proto: "viewInfoReq"),
    12: .same(proto: "pickUpMicroPhoneReq"),
    13: .same(proto: "pickUpMicroPhoneCompelReq"),
    14: .same(proto: "putDownMicroPhoneReq"),
    15: .same(proto: "exchangeMicroPhoneReq"),
    16: .same(proto: "wordsNotAllowedReq"),
    17: .same(proto: "wordsAllowedReq"),
    18: .same(proto: "lockMicroPhoneReq"),
    19: .same(proto: "unLockMicrophoneReq"),
    20: .same(proto: "lockAllMicrophoneReq"),
    21: .same(proto: "unLockAllMicrophoneReq"),
    22: .same(proto: "lockSeatVoiceReq"),
    23: .same(proto: "unLockSeatVoiceReq"),
    24: .same(proto: "holdOnMicroPhoneReq"),
    25: .same(proto: "kickYouOutReq"),
    26: .same(proto: "setSuperAdminReq"),
    27: .same(proto: "cancelSuperAdminReq"),
    28: .same(proto: "setAdminReq"),
    29: .same(proto: "cancelAdminReq"),
    30: .same(proto: "exchangeSeatLayoutReq"),
    31: .same(proto: "wordsNotAllowedAllReq"),
    32: .same(proto: "wordsAllowedAllReq"),
    33: .same(proto: "givePresentsReq"),
    34: .same(proto: "giveLuckyBagPresentReq"),
    35: .same(proto: "givePresentsUseBackpackReq"),
    36: .same(proto: "privilegeCardsReq"),
    37: .same(proto: "usePrivilegeCardReq"),
    38: .same(proto: "openLoveNumReq"),
    39: .same(proto: "closeLoveNumReq"),
    40: .same(proto: "channelRankingsReq"),
    41: .same(proto: "announcementSettingReq"),
    42: .same(proto: "onlineUserReq"),
    43: .same(proto: "pkTopicsReq"),
    44: .same(proto: "createPkGameReq"),
    45: .same(proto: "searchPkChannelReq"),
    46: .same(proto: "askChannelPkReq"),
    47: .same(proto: "acceptChannelPkReq"),
    48: .same(proto: "refuseChannelPkReq"),
    49: .same(proto: "stopPkGameReq"),
    50: .same(proto: "pkLogReq"),
    51: .same(proto: "randomChannelNameReq"),
    52: .same(proto: "channelGiftWallReq"),
    53: .same(proto: "joinChannelBlackListReq"),
    54: .same(proto: "removeChannelBlackListReq"),
    55: .same(proto: "channelAdminListReq"),
    56: .same(proto: "channelBlackListReq"),
    57: .same(proto: "turnOntheMicrophoneReq"),
    58: .same(proto: "turnOfftheMicrophoneReq"),
    59: .same(proto: "afterJoinReq"),
    60: .same(proto: "channelProhibitListReq"),
    61: .same(proto: "givePresentsFansClubReq"),
    62: .same(proto: "emptyLoveNumReq"),
    71: .same(proto: "buyExpressionReq"),
    72: .same(proto: "commitExpressionReq"),
    101: .same(proto: "loadRocketInfoReq"),
    102: .same(proto: "hoursListReq"),
    103: .same(proto: "myClubReq"),
    104: .same(proto: "joinClubReq"),
    105: .same(proto: "loadExpressionReq"),
    106: .same(proto: "personalChannelInfoReq"),
    107: .same(proto: "personalSeatsConfigReq"),
    108: .same(proto: "personalLiveConfigReq"),
    109: .same(proto: "wishGiftInfoReq"),
    110: .same(proto: "wishGiftConfigReq"),
    111: .same(proto: "wishGiftRestartReq"),
    112: .same(proto: "wishGiftDelReq"),
    113: .same(proto: "userPlayInfoReq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSCreateReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .createReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .createReq(v)
        }
      }()
      case 2: try {
        var v: OSJoinReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinReq(v)
        }
      }()
      case 3: try {
        var v: OSBackReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .backReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .backReq(v)
        }
      }()
      case 4: try {
        var v: OSExitReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .exitReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .exitReq(v)
        }
      }()
      case 5: try {
        var v: OSRealTimeInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .realTimeInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .realTimeInfoReq(v)
        }
      }()
      case 6: try {
        var v: OSOnlineReportReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .onlineReportReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .onlineReportReq(v)
        }
      }()
      case 7: try {
        var v: OSDetailReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .detailReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .detailReq(v)
        }
      }()
      case 8: try {
        var v: OSEditChannelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .editChannelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .editChannelReq(v)
        }
      }()
      case 9: try {
        var v: OSTagsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .tagsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .tagsReq(v)
        }
      }()
      case 10: try {
        var v: OSGiftListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giftListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giftListReq(v)
        }
      }()
      case 11: try {
        var v: OSViewInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .viewInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .viewInfoReq(v)
        }
      }()
      case 12: try {
        var v: OSPickUpMicroPhoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pickUpMicroPhoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pickUpMicroPhoneReq(v)
        }
      }()
      case 13: try {
        var v: OSPickUpMicroPhoneCompelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pickUpMicroPhoneCompelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pickUpMicroPhoneCompelReq(v)
        }
      }()
      case 14: try {
        var v: OSPutDownMicroPhoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .putDownMicroPhoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .putDownMicroPhoneReq(v)
        }
      }()
      case 15: try {
        var v: OSExchangeMicroPhoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .exchangeMicroPhoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .exchangeMicroPhoneReq(v)
        }
      }()
      case 16: try {
        var v: OSWordsNotAllowedReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsNotAllowedReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsNotAllowedReq(v)
        }
      }()
      case 17: try {
        var v: OSWordsAllowedReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsAllowedReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsAllowedReq(v)
        }
      }()
      case 18: try {
        var v: OSLockMicroPhoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lockMicroPhoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lockMicroPhoneReq(v)
        }
      }()
      case 19: try {
        var v: OSUnLockMicrophoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unLockMicrophoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unLockMicrophoneReq(v)
        }
      }()
      case 20: try {
        var v: OSLockAllMicrophoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lockAllMicrophoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lockAllMicrophoneReq(v)
        }
      }()
      case 21: try {
        var v: OSUnLockAllMicrophoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unLockAllMicrophoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unLockAllMicrophoneReq(v)
        }
      }()
      case 22: try {
        var v: OSLockSeatVoiceReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lockSeatVoiceReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lockSeatVoiceReq(v)
        }
      }()
      case 23: try {
        var v: OSUnLockSeatVoiceReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unLockSeatVoiceReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unLockSeatVoiceReq(v)
        }
      }()
      case 24: try {
        var v: OSHoldOnMicroPhoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .holdOnMicroPhoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .holdOnMicroPhoneReq(v)
        }
      }()
      case 25: try {
        var v: OSKickYouOutReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .kickYouOutReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .kickYouOutReq(v)
        }
      }()
      case 26: try {
        var v: OSSetSuperAdminReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .setSuperAdminReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .setSuperAdminReq(v)
        }
      }()
      case 27: try {
        var v: OSCancelSuperAdminReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .cancelSuperAdminReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .cancelSuperAdminReq(v)
        }
      }()
      case 28: try {
        var v: OSSetAdminReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .setAdminReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .setAdminReq(v)
        }
      }()
      case 29: try {
        var v: OSCancelAdminReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .cancelAdminReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .cancelAdminReq(v)
        }
      }()
      case 30: try {
        var v: OSExchangeSeatLayoutReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .exchangeSeatLayoutReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .exchangeSeatLayoutReq(v)
        }
      }()
      case 31: try {
        var v: OSWordsNotAllowedAllReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsNotAllowedAllReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsNotAllowedAllReq(v)
        }
      }()
      case 32: try {
        var v: OSWordsAllowedAllReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsAllowedAllReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsAllowedAllReq(v)
        }
      }()
      case 33: try {
        var v: OSGivePresentsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .givePresentsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .givePresentsReq(v)
        }
      }()
      case 34: try {
        var v: OSGiveLuckyBagPresentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giveLuckyBagPresentReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giveLuckyBagPresentReq(v)
        }
      }()
      case 35: try {
        var v: OSGivePresentsUseBackpackReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .givePresentsUseBackpackReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .givePresentsUseBackpackReq(v)
        }
      }()
      case 36: try {
        var v: OSPrivilegeCardsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .privilegeCardsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .privilegeCardsReq(v)
        }
      }()
      case 37: try {
        var v: OSUsePrivilegeCardReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .usePrivilegeCardReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .usePrivilegeCardReq(v)
        }
      }()
      case 38: try {
        var v: OSOpenLoveNumReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .openLoveNumReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .openLoveNumReq(v)
        }
      }()
      case 39: try {
        var v: OSCloseLoveNumReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .closeLoveNumReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .closeLoveNumReq(v)
        }
      }()
      case 40: try {
        var v: OSChannelRankingsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelRankingsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelRankingsReq(v)
        }
      }()
      case 41: try {
        var v: OSAnnouncementSettingReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .announcementSettingReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .announcementSettingReq(v)
        }
      }()
      case 42: try {
        var v: OSOnlineUserReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .onlineUserReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .onlineUserReq(v)
        }
      }()
      case 43: try {
        var v: OSPkTopicsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pkTopicsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pkTopicsReq(v)
        }
      }()
      case 44: try {
        var v: OSCreatePkGameReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .createPkGameReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .createPkGameReq(v)
        }
      }()
      case 45: try {
        var v: OSSearchPkChannelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .searchPkChannelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .searchPkChannelReq(v)
        }
      }()
      case 46: try {
        var v: OSAskChannelPkReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .askChannelPkReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .askChannelPkReq(v)
        }
      }()
      case 47: try {
        var v: OSAcceptChannelPkReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .acceptChannelPkReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .acceptChannelPkReq(v)
        }
      }()
      case 48: try {
        var v: OSRefuseChannelPkReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .refuseChannelPkReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .refuseChannelPkReq(v)
        }
      }()
      case 49: try {
        var v: OSStopPkGameReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .stopPkGameReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .stopPkGameReq(v)
        }
      }()
      case 50: try {
        var v: OSPkLogReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pkLogReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pkLogReq(v)
        }
      }()
      case 51: try {
        var v: OSRandomChannelNameReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .randomChannelNameReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .randomChannelNameReq(v)
        }
      }()
      case 52: try {
        var v: OSChannelGiftWallReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelGiftWallReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelGiftWallReq(v)
        }
      }()
      case 53: try {
        var v: OSJoinChannelBlackListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinChannelBlackListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinChannelBlackListReq(v)
        }
      }()
      case 54: try {
        var v: OSRemoveChannelBlackListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .removeChannelBlackListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .removeChannelBlackListReq(v)
        }
      }()
      case 55: try {
        var v: OSChannelAdminListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelAdminListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelAdminListReq(v)
        }
      }()
      case 56: try {
        var v: OSChannelBlackListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelBlackListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelBlackListReq(v)
        }
      }()
      case 57: try {
        var v: OSTurnOntheMicrophoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .turnOntheMicrophoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .turnOntheMicrophoneReq(v)
        }
      }()
      case 58: try {
        var v: OSTurnOfftheMicrophoneReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .turnOfftheMicrophoneReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .turnOfftheMicrophoneReq(v)
        }
      }()
      case 59: try {
        var v: OSAfterJoinReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .afterJoinReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .afterJoinReq(v)
        }
      }()
      case 60: try {
        var v: OSChannelProhibitListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelProhibitListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelProhibitListReq(v)
        }
      }()
      case 61: try {
        var v: OSGivePresentsFansClubReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .givePresentsFansClubReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .givePresentsFansClubReq(v)
        }
      }()
      case 62: try {
        var v: OSEmptyLoveNumReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .emptyLoveNumReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .emptyLoveNumReq(v)
        }
      }()
      case 71: try {
        var v: OSBuyExpressionReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .buyExpressionReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .buyExpressionReq(v)
        }
      }()
      case 72: try {
        var v: OSCommitExpressionReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .commitExpressionReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .commitExpressionReq(v)
        }
      }()
      case 101: try {
        var v: OSLoadRocketInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadRocketInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadRocketInfoReq(v)
        }
      }()
      case 102: try {
        var v: OSHoursListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .hoursListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .hoursListReq(v)
        }
      }()
      case 103: try {
        var v: OSMyClubReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .myClubReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .myClubReq(v)
        }
      }()
      case 104: try {
        var v: OSJoinClubReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinClubReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinClubReq(v)
        }
      }()
      case 105: try {
        var v: OSLoadExpressionReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadExpressionReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadExpressionReq(v)
        }
      }()
      case 106: try {
        var v: OSPersonalChannelInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personalChannelInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personalChannelInfoReq(v)
        }
      }()
      case 107: try {
        var v: OSPersonalSeatsConfigReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personalSeatsConfigReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personalSeatsConfigReq(v)
        }
      }()
      case 108: try {
        var v: OSPersonalLiveConfigReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personalLiveConfigReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personalLiveConfigReq(v)
        }
      }()
      case 109: try {
        var v: OSWishGiftInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftInfoReq(v)
        }
      }()
      case 110: try {
        var v: OSWishGiftConfigReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftConfigReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftConfigReq(v)
        }
      }()
      case 111: try {
        var v: OSWishGiftRestartReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftRestartReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftRestartReq(v)
        }
      }()
      case 112: try {
        var v: OSWishGiftDelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftDelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftDelReq(v)
        }
      }()
      case 113: try {
        var v: OSUserPlayInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userPlayInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userPlayInfoReq(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .createReq?: try {
      guard case .createReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .joinReq?: try {
      guard case .joinReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .backReq?: try {
      guard case .backReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .exitReq?: try {
      guard case .exitReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .realTimeInfoReq?: try {
      guard case .realTimeInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .onlineReportReq?: try {
      guard case .onlineReportReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .detailReq?: try {
      guard case .detailReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .editChannelReq?: try {
      guard case .editChannelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tagsReq?: try {
      guard case .tagsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .giftListReq?: try {
      guard case .giftListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .viewInfoReq?: try {
      guard case .viewInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .pickUpMicroPhoneReq?: try {
      guard case .pickUpMicroPhoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .pickUpMicroPhoneCompelReq?: try {
      guard case .pickUpMicroPhoneCompelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .putDownMicroPhoneReq?: try {
      guard case .putDownMicroPhoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .exchangeMicroPhoneReq?: try {
      guard case .exchangeMicroPhoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .wordsNotAllowedReq?: try {
      guard case .wordsNotAllowedReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .wordsAllowedReq?: try {
      guard case .wordsAllowedReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .lockMicroPhoneReq?: try {
      guard case .lockMicroPhoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .unLockMicrophoneReq?: try {
      guard case .unLockMicrophoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .lockAllMicrophoneReq?: try {
      guard case .lockAllMicrophoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .unLockAllMicrophoneReq?: try {
      guard case .unLockAllMicrophoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .lockSeatVoiceReq?: try {
      guard case .lockSeatVoiceReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .unLockSeatVoiceReq?: try {
      guard case .unLockSeatVoiceReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .holdOnMicroPhoneReq?: try {
      guard case .holdOnMicroPhoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .kickYouOutReq?: try {
      guard case .kickYouOutReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .setSuperAdminReq?: try {
      guard case .setSuperAdminReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .cancelSuperAdminReq?: try {
      guard case .cancelSuperAdminReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .setAdminReq?: try {
      guard case .setAdminReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .cancelAdminReq?: try {
      guard case .cancelAdminReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .exchangeSeatLayoutReq?: try {
      guard case .exchangeSeatLayoutReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .wordsNotAllowedAllReq?: try {
      guard case .wordsNotAllowedAllReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .wordsAllowedAllReq?: try {
      guard case .wordsAllowedAllReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .givePresentsReq?: try {
      guard case .givePresentsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .giveLuckyBagPresentReq?: try {
      guard case .giveLuckyBagPresentReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .givePresentsUseBackpackReq?: try {
      guard case .givePresentsUseBackpackReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .privilegeCardsReq?: try {
      guard case .privilegeCardsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .usePrivilegeCardReq?: try {
      guard case .usePrivilegeCardReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .openLoveNumReq?: try {
      guard case .openLoveNumReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .closeLoveNumReq?: try {
      guard case .closeLoveNumReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .channelRankingsReq?: try {
      guard case .channelRankingsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .announcementSettingReq?: try {
      guard case .announcementSettingReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .onlineUserReq?: try {
      guard case .onlineUserReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .pkTopicsReq?: try {
      guard case .pkTopicsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .createPkGameReq?: try {
      guard case .createPkGameReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .searchPkChannelReq?: try {
      guard case .searchPkChannelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .askChannelPkReq?: try {
      guard case .askChannelPkReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .acceptChannelPkReq?: try {
      guard case .acceptChannelPkReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .refuseChannelPkReq?: try {
      guard case .refuseChannelPkReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .stopPkGameReq?: try {
      guard case .stopPkGameReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .pkLogReq?: try {
      guard case .pkLogReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .randomChannelNameReq?: try {
      guard case .randomChannelNameReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .channelGiftWallReq?: try {
      guard case .channelGiftWallReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .joinChannelBlackListReq?: try {
      guard case .joinChannelBlackListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .removeChannelBlackListReq?: try {
      guard case .removeChannelBlackListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .channelAdminListReq?: try {
      guard case .channelAdminListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .channelBlackListReq?: try {
      guard case .channelBlackListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .turnOntheMicrophoneReq?: try {
      guard case .turnOntheMicrophoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .turnOfftheMicrophoneReq?: try {
      guard case .turnOfftheMicrophoneReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .afterJoinReq?: try {
      guard case .afterJoinReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case .channelProhibitListReq?: try {
      guard case .channelProhibitListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .givePresentsFansClubReq?: try {
      guard case .givePresentsFansClubReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .emptyLoveNumReq?: try {
      guard case .emptyLoveNumReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .buyExpressionReq?: try {
      guard case .buyExpressionReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
    }()
    case .commitExpressionReq?: try {
      guard case .commitExpressionReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .loadRocketInfoReq?: try {
      guard case .loadRocketInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .hoursListReq?: try {
      guard case .hoursListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .myClubReq?: try {
      guard case .myClubReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .joinClubReq?: try {
      guard case .joinClubReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .loadExpressionReq?: try {
      guard case .loadExpressionReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .personalChannelInfoReq?: try {
      guard case .personalChannelInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .personalSeatsConfigReq?: try {
      guard case .personalSeatsConfigReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .personalLiveConfigReq?: try {
      guard case .personalLiveConfigReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .wishGiftInfoReq?: try {
      guard case .wishGiftInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .wishGiftConfigReq?: try {
      guard case .wishGiftConfigReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .wishGiftRestartReq?: try {
      guard case .wishGiftRestartReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .wishGiftDelReq?: try {
      guard case .wishGiftDelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .userPlayInfoReq?: try {
      guard case .userPlayInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelRequest, rhs: OSChannelRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createRes"),
    2: .same(proto: "joinRes"),
    3: .same(proto: "backRes"),
    4: .same(proto: "exitRes"),
    5: .same(proto: "realTimeInfoRes"),
    6: .same(proto: "onlineReportRes"),
    7: .same(proto: "detailRes"),
    8: .same(proto: "editChannelRes"),
    9: .same(proto: "tagsRes"),
    10: .same(proto: "giftListRes"),
    11: .same(proto: "viewInfoRes"),
    12: .same(proto: "pickUpMicroPhoneRes"),
    13: .same(proto: "pickUpMicroPhoneCompelRes"),
    14: .same(proto: "putDownMicroPhoneRes"),
    15: .same(proto: "exchangeMicroPhoneRes"),
    16: .same(proto: "wordsNotAllowedRes"),
    17: .same(proto: "wordsAllowedRes"),
    18: .same(proto: "lockMicroPhoneRes"),
    19: .same(proto: "unLockMicrophoneRes"),
    20: .same(proto: "lockAllMicrophoneRes"),
    21: .same(proto: "unLockAllMicrophoneRes"),
    22: .same(proto: "lockSeatVoiceRes"),
    23: .same(proto: "unLockSeatVoiceRes"),
    24: .same(proto: "holdOnMicroPhoneRes"),
    25: .same(proto: "kickYouOutRes"),
    26: .same(proto: "setSuperAdminRes"),
    27: .same(proto: "cancelSuperAdminRes"),
    28: .same(proto: "setAdminRes"),
    29: .same(proto: "cancelAdminRes"),
    30: .same(proto: "exchangeSeatLayoutRes"),
    31: .same(proto: "wordsNotAllowedAllRes"),
    32: .same(proto: "wordsAllowedAllRes"),
    33: .same(proto: "givePresentsRes"),
    34: .same(proto: "giveLuckyBagPresentRes"),
    35: .same(proto: "givePresentsUseBackpackRes"),
    36: .same(proto: "privilegeCardsRes"),
    37: .same(proto: "usePrivilegeCardRes"),
    38: .same(proto: "openLoveNumRes"),
    39: .same(proto: "closeLoveNumRes"),
    40: .same(proto: "channelRankingsRes"),
    41: .same(proto: "announcementSettingRes"),
    42: .same(proto: "onlineUserRes"),
    43: .same(proto: "pkTopicsRes"),
    44: .same(proto: "createPkGameRes"),
    45: .same(proto: "searchPkChannelRes"),
    46: .same(proto: "askChannelPkRes"),
    47: .same(proto: "acceptChannelPkRes"),
    48: .same(proto: "refuseChannelPkRes"),
    49: .same(proto: "stopPkGameRes"),
    50: .same(proto: "pkLogReqs"),
    51: .same(proto: "randomChannelNameRes"),
    52: .same(proto: "channelGiftWallRes"),
    53: .same(proto: "joinChannelBlackListRes"),
    54: .same(proto: "removeChannelBlackListRes"),
    55: .same(proto: "channelAdminListRes"),
    56: .same(proto: "channelBlackListRes"),
    57: .same(proto: "turnOntheMicrophoneRes"),
    58: .same(proto: "turnOfftheMicrophoneRes"),
    59: .same(proto: "afterJoinRes"),
    60: .same(proto: "channelProhibitListRes"),
    61: .same(proto: "givePresentsFansClubRes"),
    62: .same(proto: "emptyLoveNumRes"),
    71: .same(proto: "buyExpressionRes"),
    72: .same(proto: "commitExpressionRes"),
    101: .same(proto: "loadRocketInfoRes"),
    102: .same(proto: "hoursListRes"),
    103: .same(proto: "myClubRes"),
    104: .same(proto: "joinClubRes"),
    105: .same(proto: "loadExpressionRes"),
    106: .same(proto: "personalChannelInfoRes"),
    107: .same(proto: "personalSeatsConfigRes"),
    108: .same(proto: "personalLiveConfigRess"),
    109: .same(proto: "wishGiftInfoRes"),
    110: .same(proto: "wishGiftConfigRes"),
    111: .same(proto: "wishGiftRestartRes"),
    112: .same(proto: "wishGiftDelRes"),
    113: .same(proto: "userPlayInfoRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSCreateRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .createRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .createRes(v)
        }
      }()
      case 2: try {
        var v: OSJoinRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinRes(v)
        }
      }()
      case 3: try {
        var v: OSBackRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .backRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .backRes(v)
        }
      }()
      case 4: try {
        var v: OSExitRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .exitRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .exitRes(v)
        }
      }()
      case 5: try {
        var v: OSRealTimeInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .realTimeInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .realTimeInfoRes(v)
        }
      }()
      case 6: try {
        var v: OSOnlineReportRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .onlineReportRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .onlineReportRes(v)
        }
      }()
      case 7: try {
        var v: OSDetailRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .detailRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .detailRes(v)
        }
      }()
      case 8: try {
        var v: OSEditChannelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .editChannelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .editChannelRes(v)
        }
      }()
      case 9: try {
        var v: OSTagsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .tagsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .tagsRes(v)
        }
      }()
      case 10: try {
        var v: OSGiftListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giftListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giftListRes(v)
        }
      }()
      case 11: try {
        var v: OSViewInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .viewInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .viewInfoRes(v)
        }
      }()
      case 12: try {
        var v: OSPickUpMicroPhoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pickUpMicroPhoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pickUpMicroPhoneRes(v)
        }
      }()
      case 13: try {
        var v: OSPickUpMicroPhoneCompelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pickUpMicroPhoneCompelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pickUpMicroPhoneCompelRes(v)
        }
      }()
      case 14: try {
        var v: OSPutDownMicroPhoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .putDownMicroPhoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .putDownMicroPhoneRes(v)
        }
      }()
      case 15: try {
        var v: OSExchangeMicroPhoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .exchangeMicroPhoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .exchangeMicroPhoneRes(v)
        }
      }()
      case 16: try {
        var v: OSWordsNotAllowedRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsNotAllowedRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsNotAllowedRes(v)
        }
      }()
      case 17: try {
        var v: OSWordsAllowedRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsAllowedRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsAllowedRes(v)
        }
      }()
      case 18: try {
        var v: OSLockMicroPhoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lockMicroPhoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lockMicroPhoneRes(v)
        }
      }()
      case 19: try {
        var v: OSUnLockMicrophoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unLockMicrophoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unLockMicrophoneRes(v)
        }
      }()
      case 20: try {
        var v: OSLockAllMicrophoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lockAllMicrophoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lockAllMicrophoneRes(v)
        }
      }()
      case 21: try {
        var v: OSUnLockAllMicrophoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unLockAllMicrophoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unLockAllMicrophoneRes(v)
        }
      }()
      case 22: try {
        var v: OSLockSeatVoiceRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lockSeatVoiceRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lockSeatVoiceRes(v)
        }
      }()
      case 23: try {
        var v: OSUnLockSeatVoiceRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unLockSeatVoiceRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unLockSeatVoiceRes(v)
        }
      }()
      case 24: try {
        var v: OSHoldOnMicroPhoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .holdOnMicroPhoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .holdOnMicroPhoneRes(v)
        }
      }()
      case 25: try {
        var v: OSKickYouOutRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .kickYouOutRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .kickYouOutRes(v)
        }
      }()
      case 26: try {
        var v: OSSetSuperAdminRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .setSuperAdminRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .setSuperAdminRes(v)
        }
      }()
      case 27: try {
        var v: OSCancelSuperAdminRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .cancelSuperAdminRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .cancelSuperAdminRes(v)
        }
      }()
      case 28: try {
        var v: OSSetAdminRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .setAdminRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .setAdminRes(v)
        }
      }()
      case 29: try {
        var v: OSCancelAdminRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .cancelAdminRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .cancelAdminRes(v)
        }
      }()
      case 30: try {
        var v: OSExchangeSeatLayoutRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .exchangeSeatLayoutRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .exchangeSeatLayoutRes(v)
        }
      }()
      case 31: try {
        var v: OSWordsNotAllowedAllRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsNotAllowedAllRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsNotAllowedAllRes(v)
        }
      }()
      case 32: try {
        var v: OSWordsAllowedAllRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wordsAllowedAllRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wordsAllowedAllRes(v)
        }
      }()
      case 33: try {
        var v: OSGivePresentsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .givePresentsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .givePresentsRes(v)
        }
      }()
      case 34: try {
        var v: OSGiveLuckyBagPresentRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giveLuckyBagPresentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giveLuckyBagPresentRes(v)
        }
      }()
      case 35: try {
        var v: OSGivePresentsUseBackpackRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .givePresentsUseBackpackRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .givePresentsUseBackpackRes(v)
        }
      }()
      case 36: try {
        var v: OSPrivilegeCardsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .privilegeCardsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .privilegeCardsRes(v)
        }
      }()
      case 37: try {
        var v: OSUsePrivilegeCardRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .usePrivilegeCardRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .usePrivilegeCardRes(v)
        }
      }()
      case 38: try {
        var v: OSOpenLoveNumRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .openLoveNumRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .openLoveNumRes(v)
        }
      }()
      case 39: try {
        var v: OSCloseLoveNumRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .closeLoveNumRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .closeLoveNumRes(v)
        }
      }()
      case 40: try {
        var v: OSChannelRankingsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelRankingsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelRankingsRes(v)
        }
      }()
      case 41: try {
        var v: OSAnnouncementSettingRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .announcementSettingRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .announcementSettingRes(v)
        }
      }()
      case 42: try {
        var v: OSOnlineUserRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .onlineUserRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .onlineUserRes(v)
        }
      }()
      case 43: try {
        var v: OSPkTopicsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pkTopicsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pkTopicsRes(v)
        }
      }()
      case 44: try {
        var v: OSCreatePkGameRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .createPkGameRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .createPkGameRes(v)
        }
      }()
      case 45: try {
        var v: OSSearchPkChannelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .searchPkChannelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .searchPkChannelRes(v)
        }
      }()
      case 46: try {
        var v: OSAskChannelPkRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .askChannelPkRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .askChannelPkRes(v)
        }
      }()
      case 47: try {
        var v: OSAcceptChannelPkRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .acceptChannelPkRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .acceptChannelPkRes(v)
        }
      }()
      case 48: try {
        var v: OSRefuseChannelPkRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .refuseChannelPkRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .refuseChannelPkRes(v)
        }
      }()
      case 49: try {
        var v: OSStopPkGameRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .stopPkGameRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .stopPkGameRes(v)
        }
      }()
      case 50: try {
        var v: OSPkLogRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pkLogReqs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pkLogReqs(v)
        }
      }()
      case 51: try {
        var v: OSRandomChannelNameRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .randomChannelNameRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .randomChannelNameRes(v)
        }
      }()
      case 52: try {
        var v: OSChannelGiftWallRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelGiftWallRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelGiftWallRes(v)
        }
      }()
      case 53: try {
        var v: OSJoinChannelBlackListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinChannelBlackListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinChannelBlackListRes(v)
        }
      }()
      case 54: try {
        var v: OSRemoveChannelBlackListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .removeChannelBlackListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .removeChannelBlackListRes(v)
        }
      }()
      case 55: try {
        var v: OSChannelAdminListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelAdminListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelAdminListRes(v)
        }
      }()
      case 56: try {
        var v: OSChannelBlackListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelBlackListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelBlackListRes(v)
        }
      }()
      case 57: try {
        var v: OSTurnOntheMicrophoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .turnOntheMicrophoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .turnOntheMicrophoneRes(v)
        }
      }()
      case 58: try {
        var v: OSTurnOfftheMicrophoneRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .turnOfftheMicrophoneRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .turnOfftheMicrophoneRes(v)
        }
      }()
      case 59: try {
        var v: OSAfterJoinRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .afterJoinRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .afterJoinRes(v)
        }
      }()
      case 60: try {
        var v: OSChannelProhibitListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelProhibitListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelProhibitListRes(v)
        }
      }()
      case 61: try {
        var v: OSGivePresentsFansClubRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .givePresentsFansClubRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .givePresentsFansClubRes(v)
        }
      }()
      case 62: try {
        var v: OSEmptyLoveNumRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .emptyLoveNumRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .emptyLoveNumRes(v)
        }
      }()
      case 71: try {
        var v: OSBuyExpressionRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .buyExpressionRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .buyExpressionRes(v)
        }
      }()
      case 72: try {
        var v: OSCommitExpressionRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .commitExpressionRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .commitExpressionRes(v)
        }
      }()
      case 101: try {
        var v: OSLoadRocketInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadRocketInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadRocketInfoRes(v)
        }
      }()
      case 102: try {
        var v: OSHoursListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .hoursListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .hoursListRes(v)
        }
      }()
      case 103: try {
        var v: OSMyClubRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .myClubRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .myClubRes(v)
        }
      }()
      case 104: try {
        var v: OSJoinClubRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinClubRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinClubRes(v)
        }
      }()
      case 105: try {
        var v: OSLoadExpressionRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadExpressionRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadExpressionRes(v)
        }
      }()
      case 106: try {
        var v: OSPersonalChannelInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personalChannelInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personalChannelInfoRes(v)
        }
      }()
      case 107: try {
        var v: OSPersonalSeatsConfigRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personalSeatsConfigRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personalSeatsConfigRes(v)
        }
      }()
      case 108: try {
        var v: OSPersonalLiveConfigRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personalLiveConfigRess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personalLiveConfigRess(v)
        }
      }()
      case 109: try {
        var v: OSWishGiftInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftInfoRes(v)
        }
      }()
      case 110: try {
        var v: OSWishGiftConfigRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftConfigRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftConfigRes(v)
        }
      }()
      case 111: try {
        var v: OSWishGiftRestartRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftRestartRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftRestartRes(v)
        }
      }()
      case 112: try {
        var v: OSWishGiftDelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wishGiftDelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wishGiftDelRes(v)
        }
      }()
      case 113: try {
        var v: OSUserPlayInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userPlayInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userPlayInfoRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .createRes?: try {
      guard case .createRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .joinRes?: try {
      guard case .joinRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .backRes?: try {
      guard case .backRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .exitRes?: try {
      guard case .exitRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .realTimeInfoRes?: try {
      guard case .realTimeInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .onlineReportRes?: try {
      guard case .onlineReportRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .detailRes?: try {
      guard case .detailRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .editChannelRes?: try {
      guard case .editChannelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tagsRes?: try {
      guard case .tagsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .giftListRes?: try {
      guard case .giftListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .viewInfoRes?: try {
      guard case .viewInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .pickUpMicroPhoneRes?: try {
      guard case .pickUpMicroPhoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .pickUpMicroPhoneCompelRes?: try {
      guard case .pickUpMicroPhoneCompelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .putDownMicroPhoneRes?: try {
      guard case .putDownMicroPhoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .exchangeMicroPhoneRes?: try {
      guard case .exchangeMicroPhoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .wordsNotAllowedRes?: try {
      guard case .wordsNotAllowedRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .wordsAllowedRes?: try {
      guard case .wordsAllowedRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .lockMicroPhoneRes?: try {
      guard case .lockMicroPhoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .unLockMicrophoneRes?: try {
      guard case .unLockMicrophoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .lockAllMicrophoneRes?: try {
      guard case .lockAllMicrophoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .unLockAllMicrophoneRes?: try {
      guard case .unLockAllMicrophoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .lockSeatVoiceRes?: try {
      guard case .lockSeatVoiceRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .unLockSeatVoiceRes?: try {
      guard case .unLockSeatVoiceRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .holdOnMicroPhoneRes?: try {
      guard case .holdOnMicroPhoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .kickYouOutRes?: try {
      guard case .kickYouOutRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .setSuperAdminRes?: try {
      guard case .setSuperAdminRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .cancelSuperAdminRes?: try {
      guard case .cancelSuperAdminRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .setAdminRes?: try {
      guard case .setAdminRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .cancelAdminRes?: try {
      guard case .cancelAdminRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .exchangeSeatLayoutRes?: try {
      guard case .exchangeSeatLayoutRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .wordsNotAllowedAllRes?: try {
      guard case .wordsNotAllowedAllRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .wordsAllowedAllRes?: try {
      guard case .wordsAllowedAllRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .givePresentsRes?: try {
      guard case .givePresentsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .giveLuckyBagPresentRes?: try {
      guard case .giveLuckyBagPresentRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .givePresentsUseBackpackRes?: try {
      guard case .givePresentsUseBackpackRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .privilegeCardsRes?: try {
      guard case .privilegeCardsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .usePrivilegeCardRes?: try {
      guard case .usePrivilegeCardRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .openLoveNumRes?: try {
      guard case .openLoveNumRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .closeLoveNumRes?: try {
      guard case .closeLoveNumRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .channelRankingsRes?: try {
      guard case .channelRankingsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .announcementSettingRes?: try {
      guard case .announcementSettingRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .onlineUserRes?: try {
      guard case .onlineUserRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .pkTopicsRes?: try {
      guard case .pkTopicsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .createPkGameRes?: try {
      guard case .createPkGameRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .searchPkChannelRes?: try {
      guard case .searchPkChannelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .askChannelPkRes?: try {
      guard case .askChannelPkRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .acceptChannelPkRes?: try {
      guard case .acceptChannelPkRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .refuseChannelPkRes?: try {
      guard case .refuseChannelPkRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .stopPkGameRes?: try {
      guard case .stopPkGameRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .pkLogReqs?: try {
      guard case .pkLogReqs(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .randomChannelNameRes?: try {
      guard case .randomChannelNameRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .channelGiftWallRes?: try {
      guard case .channelGiftWallRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .joinChannelBlackListRes?: try {
      guard case .joinChannelBlackListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .removeChannelBlackListRes?: try {
      guard case .removeChannelBlackListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .channelAdminListRes?: try {
      guard case .channelAdminListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .channelBlackListRes?: try {
      guard case .channelBlackListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .turnOntheMicrophoneRes?: try {
      guard case .turnOntheMicrophoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .turnOfftheMicrophoneRes?: try {
      guard case .turnOfftheMicrophoneRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .afterJoinRes?: try {
      guard case .afterJoinRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case .channelProhibitListRes?: try {
      guard case .channelProhibitListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .givePresentsFansClubRes?: try {
      guard case .givePresentsFansClubRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .emptyLoveNumRes?: try {
      guard case .emptyLoveNumRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .buyExpressionRes?: try {
      guard case .buyExpressionRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
    }()
    case .commitExpressionRes?: try {
      guard case .commitExpressionRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .loadRocketInfoRes?: try {
      guard case .loadRocketInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .hoursListRes?: try {
      guard case .hoursListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .myClubRes?: try {
      guard case .myClubRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .joinClubRes?: try {
      guard case .joinClubRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .loadExpressionRes?: try {
      guard case .loadExpressionRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case .personalChannelInfoRes?: try {
      guard case .personalChannelInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .personalSeatsConfigRes?: try {
      guard case .personalSeatsConfigRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .personalLiveConfigRess?: try {
      guard case .personalLiveConfigRess(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .wishGiftInfoRes?: try {
      guard case .wishGiftInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
    }()
    case .wishGiftConfigRes?: try {
      guard case .wishGiftConfigRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .wishGiftRestartRes?: try {
      guard case .wishGiftRestartRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
    }()
    case .wishGiftDelRes?: try {
      guard case .wishGiftDelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .userPlayInfoRes?: try {
      guard case .userPlayInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelResponse, rhs: OSChannelResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCreateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuId"),
    2: .same(proto: "channelName"),
    3: .same(proto: "channelType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuID != 0 {
      try visitor.visitSingularInt32Field(value: self.menuID, fieldNumber: 1)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 2)
    }
    if self.channelType != .unkown {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCreateReq, rhs: OSCreateReq) -> Bool {
    if lhs.menuID != rhs.menuID {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCreateRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "myself"),
    2: .same(proto: "channel"),
    3: .same(proto: "userInSeats"),
    4: .same(proto: "channelToken"),
    5: .same(proto: "WealthUsers"),
    6: .same(proto: "activityInfo"),
    7: .same(proto: "activeStatus"),
    8: .same(proto: "medalList"),
    9: .same(proto: "channelSetting"),
    10: .same(proto: "isOpenChannel"),
    11: .same(proto: "giveSelf"),
    12: .same(proto: "other"),
    13: .same(proto: "bubbleInfo"),
    14: .same(proto: "mount"),
    15: .same(proto: "admissionEffects"),
    16: .same(proto: "honouredGuestCard"),
    17: .same(proto: "dressUpInfo"),
  ]

  fileprivate class _StorageClass {
    var _myself: OSUserInChannel? = nil
    var _channel: OSChannelVo? = nil
    var _userInSeats: [OSUserInSeats] = []
    var _channelToken: String = String()
    var _wealthUsers: [OSWealthUsers] = []
    var _activityInfo: OSActivityInfo? = nil
    var _activeStatus: OSActiveStatus? = nil
    var _medalList: [OSMedalList] = []
    var _channelSetting: OSChannelSetting? = nil
    var _isOpenChannel: Bool = false
    var _giveSelf: Int32 = 0
    var _other: OSChannelOther? = nil
    var _bubbleInfo: OSBubbleInfo? = nil
    var _mount: OSMount? = nil
    var _admissionEffects: OSAdmissionEffects? = nil
    var _honouredGuestCard: OSHonouredGuestCard? = nil
    var _dressUpInfo: OSDressUpInfo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _myself = source._myself
      _channel = source._channel
      _userInSeats = source._userInSeats
      _channelToken = source._channelToken
      _wealthUsers = source._wealthUsers
      _activityInfo = source._activityInfo
      _activeStatus = source._activeStatus
      _medalList = source._medalList
      _channelSetting = source._channelSetting
      _isOpenChannel = source._isOpenChannel
      _giveSelf = source._giveSelf
      _other = source._other
      _bubbleInfo = source._bubbleInfo
      _mount = source._mount
      _admissionEffects = source._admissionEffects
      _honouredGuestCard = source._honouredGuestCard
      _dressUpInfo = source._dressUpInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._myself) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._channel) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._userInSeats) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._channelToken) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._wealthUsers) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._activityInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._activeStatus) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._channelSetting) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isOpenChannel) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._giveSelf) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._other) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._bubbleInfo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._mount) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._admissionEffects) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._honouredGuestCard) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._myself {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._userInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userInSeats, fieldNumber: 3)
      }
      if !_storage._channelToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelToken, fieldNumber: 4)
      }
      if !_storage._wealthUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._wealthUsers, fieldNumber: 5)
      }
      try { if let v = _storage._activityInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._activeStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 8)
      }
      try { if let v = _storage._channelSetting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isOpenChannel != false {
        try visitor.visitSingularBoolField(value: _storage._isOpenChannel, fieldNumber: 10)
      }
      if _storage._giveSelf != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giveSelf, fieldNumber: 11)
      }
      try { if let v = _storage._other {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._bubbleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._mount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._admissionEffects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._honouredGuestCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCreateRes, rhs: OSCreateRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._myself != rhs_storage._myself {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._userInSeats != rhs_storage._userInSeats {return false}
        if _storage._channelToken != rhs_storage._channelToken {return false}
        if _storage._wealthUsers != rhs_storage._wealthUsers {return false}
        if _storage._activityInfo != rhs_storage._activityInfo {return false}
        if _storage._activeStatus != rhs_storage._activeStatus {return false}
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._channelSetting != rhs_storage._channelSetting {return false}
        if _storage._isOpenChannel != rhs_storage._isOpenChannel {return false}
        if _storage._giveSelf != rhs_storage._giveSelf {return false}
        if _storage._other != rhs_storage._other {return false}
        if _storage._bubbleInfo != rhs_storage._bubbleInfo {return false}
        if _storage._mount != rhs_storage._mount {return false}
        if _storage._admissionEffects != rhs_storage._admissionEffects {return false}
        if _storage._honouredGuestCard != rhs_storage._honouredGuestCard {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWealthUsers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WealthUsers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "avatarUrl"),
    3: .same(proto: "giftValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 2)
    }
    if self.giftValue != 0 {
      try visitor.visitSingularInt32Field(value: self.giftValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWealthUsers, rhs: OSWealthUsers) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.giftValue != rhs.giftValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSActivityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkGame"),
    2: .same(proto: "activityList"),
    3: .same(proto: "halfActivityList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pkGame) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.activityList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.halfActivityList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pkGame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.activityList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityList, fieldNumber: 2)
    }
    if !self.halfActivityList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.halfActivityList, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSActivityInfo, rhs: OSActivityInfo) -> Bool {
    if lhs._pkGame != rhs._pkGame {return false}
    if lhs.activityList != rhs.activityList {return false}
    if lhs.halfActivityList != rhs.halfActivityList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "pkRoundId"),
    3: .same(proto: "topic"),
    4: .same(proto: "type"),
    5: .same(proto: "duration"),
    6: .same(proto: "blueTeamScore"),
    7: .same(proto: "redTeamScore"),
    8: .same(proto: "createTime"),
    9: .same(proto: "endTime"),
    10: .same(proto: "participants"),
    11: .same(proto: "blueParticipants"),
    12: .same(proto: "pkBossUsers"),
    13: .same(proto: "bluePkBossUsers"),
    14: .same(proto: "redChannelInfo"),
    15: .same(proto: "blueChannelInfo"),
    16: .same(proto: "status"),
    17: .same(proto: "systemTime"),
    18: .same(proto: "redUserInSeats"),
    19: .same(proto: "blueUserInSeats"),
  ]

  fileprivate class _StorageClass {
    var _channelID: String = String()
    var _pkRoundID: String = String()
    var _topic: String = String()
    var _type: OSPkType = .oneToOne
    var _duration: Int32 = 0
    var _blueTeamScore: Int32 = 0
    var _redTeamScore: Int32 = 0
    var _createTime: Int64 = 0
    var _endTime: Int64 = 0
    var _participants: [OSParticipantVo] = []
    var _blueParticipants: [OSParticipantVo] = []
    var _pkBossUsers: [OSPkBossUserVo] = []
    var _bluePkBossUsers: [OSPkBossUserVo] = []
    var _redChannelInfo: OSPkChannelInfoVo? = nil
    var _blueChannelInfo: OSPkChannelInfoVo? = nil
    var _status: Int32 = 0
    var _systemTime: Int64 = 0
    var _redUserInSeats: [OSUserInSeats] = []
    var _blueUserInSeats: [OSUserInSeats] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _pkRoundID = source._pkRoundID
      _topic = source._topic
      _type = source._type
      _duration = source._duration
      _blueTeamScore = source._blueTeamScore
      _redTeamScore = source._redTeamScore
      _createTime = source._createTime
      _endTime = source._endTime
      _participants = source._participants
      _blueParticipants = source._blueParticipants
      _pkBossUsers = source._pkBossUsers
      _bluePkBossUsers = source._bluePkBossUsers
      _redChannelInfo = source._redChannelInfo
      _blueChannelInfo = source._blueChannelInfo
      _status = source._status
      _systemTime = source._systemTime
      _redUserInSeats = source._redUserInSeats
      _blueUserInSeats = source._blueUserInSeats
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._pkRoundID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._blueTeamScore) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._redTeamScore) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._endTime) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._participants) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._blueParticipants) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._pkBossUsers) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._bluePkBossUsers) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._redChannelInfo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._blueChannelInfo) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._systemTime) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._redUserInSeats) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._blueUserInSeats) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._pkRoundID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pkRoundID, fieldNumber: 2)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._topic, fieldNumber: 3)
      }
      if _storage._type != .oneToOne {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 5)
      }
      if _storage._blueTeamScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blueTeamScore, fieldNumber: 6)
      }
      if _storage._redTeamScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._redTeamScore, fieldNumber: 7)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 8)
      }
      if _storage._endTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._endTime, fieldNumber: 9)
      }
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._participants, fieldNumber: 10)
      }
      if !_storage._blueParticipants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blueParticipants, fieldNumber: 11)
      }
      if !_storage._pkBossUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pkBossUsers, fieldNumber: 12)
      }
      if !_storage._bluePkBossUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bluePkBossUsers, fieldNumber: 13)
      }
      try { if let v = _storage._redChannelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._blueChannelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 16)
      }
      if _storage._systemTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._systemTime, fieldNumber: 17)
      }
      if !_storage._redUserInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._redUserInSeats, fieldNumber: 18)
      }
      if !_storage._blueUserInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blueUserInSeats, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkGame, rhs: OSPkGame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._pkRoundID != rhs_storage._pkRoundID {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._blueTeamScore != rhs_storage._blueTeamScore {return false}
        if _storage._redTeamScore != rhs_storage._redTeamScore {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._participants != rhs_storage._participants {return false}
        if _storage._blueParticipants != rhs_storage._blueParticipants {return false}
        if _storage._pkBossUsers != rhs_storage._pkBossUsers {return false}
        if _storage._bluePkBossUsers != rhs_storage._bluePkBossUsers {return false}
        if _storage._redChannelInfo != rhs_storage._redChannelInfo {return false}
        if _storage._blueChannelInfo != rhs_storage._blueChannelInfo {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._systemTime != rhs_storage._systemTime {return false}
        if _storage._redUserInSeats != rhs_storage._redUserInSeats {return false}
        if _storage._blueUserInSeats != rhs_storage._blueUserInSeats {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSActivityList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "imgUrl"),
    3: .same(proto: "linkValue"),
    4: .same(proto: "linkType"),
    5: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imgURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.linkValue) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.linkType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 2)
    }
    if !self.linkValue.isEmpty {
      try visitor.visitSingularStringField(value: self.linkValue, fieldNumber: 3)
    }
    if self.linkType != 0 {
      try visitor.visitSingularInt32Field(value: self.linkType, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSActivityList, rhs: OSActivityList) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.linkValue != rhs.linkValue {return false}
    if lhs.linkType != rhs.linkType {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSActiveStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActiveStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "activitySwich"),
    2: .same(proto: "lotterys"),
    3: .same(proto: "pkGame"),
    4: .same(proto: "eidolon"),
    5: .same(proto: "listsHoursSwitch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.activitySwich) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lotterys) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pkGame) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.eidolon) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.listsHoursSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activitySwich != 0 {
      try visitor.visitSingularInt32Field(value: self.activitySwich, fieldNumber: 1)
    }
    if !self.lotterys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lotterys, fieldNumber: 2)
    }
    if self.pkGame != 0 {
      try visitor.visitSingularInt32Field(value: self.pkGame, fieldNumber: 3)
    }
    if self.eidolon != 0 {
      try visitor.visitSingularInt32Field(value: self.eidolon, fieldNumber: 4)
    }
    if self.listsHoursSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.listsHoursSwitch, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSActiveStatus, rhs: OSActiveStatus) -> Bool {
    if lhs.activitySwich != rhs.activitySwich {return false}
    if lhs.lotterys != rhs.lotterys {return false}
    if lhs.pkGame != rhs.pkGame {return false}
    if lhs.eidolon != rhs.eidolon {return false}
    if lhs.listsHoursSwitch != rhs.listsHoursSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLotterys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Lotterys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lotteryIcon"),
    2: .same(proto: "lotteryType"),
    3: .same(proto: "positionType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lotteryIcon) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.lotteryType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.positionType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lotteryIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.lotteryIcon, fieldNumber: 1)
    }
    if self.lotteryType != 0 {
      try visitor.visitSingularInt32Field(value: self.lotteryType, fieldNumber: 2)
    }
    if self.positionType != 0 {
      try visitor.visitSingularInt32Field(value: self.positionType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLotterys, rhs: OSLotterys) -> Bool {
    if lhs.lotteryIcon != rhs.lotteryIcon {return false}
    if lhs.lotteryType != rhs.lotteryType {return false}
    if lhs.positionType != rhs.positionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelOther: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelOther"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collectFlag"),
    2: .same(proto: "gameNotice"),
    3: .same(proto: "isFansClub"),
    4: .same(proto: "isFansUser"),
    5: .same(proto: "liveSwitch"),
    6: .same(proto: "seatsSwitch"),
    7: .same(proto: "clubId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.collectFlag) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gameNotice) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.isFansClub) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.isFansUser) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.liveSwitch) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.seatsSwitch) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.clubID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.collectFlag != 0 {
      try visitor.visitSingularInt32Field(value: self.collectFlag, fieldNumber: 1)
    }
    try { if let v = self._gameNotice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isFansClub != 0 {
      try visitor.visitSingularInt32Field(value: self.isFansClub, fieldNumber: 3)
    }
    if self.isFansUser != 0 {
      try visitor.visitSingularInt32Field(value: self.isFansUser, fieldNumber: 4)
    }
    if self.liveSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.liveSwitch, fieldNumber: 5)
    }
    if self.seatsSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.seatsSwitch, fieldNumber: 6)
    }
    if self.clubID != 0 {
      try visitor.visitSingularInt64Field(value: self.clubID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelOther, rhs: OSChannelOther) -> Bool {
    if lhs.collectFlag != rhs.collectFlag {return false}
    if lhs._gameNotice != rhs._gameNotice {return false}
    if lhs.isFansClub != rhs.isFansClub {return false}
    if lhs.isFansUser != rhs.isFansUser {return false}
    if lhs.liveSwitch != rhs.liveSwitch {return false}
    if lhs.seatsSwitch != rhs.seatsSwitch {return false}
    if lhs.clubID != rhs.clubID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGameNotice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameNotice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "duration"),
    3: .same(proto: "lotteryType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lotteryType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 2)
    }
    if self.lotteryType != 0 {
      try visitor.visitSingularInt32Field(value: self.lotteryType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGameNotice, rhs: OSGameNotice) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.lotteryType != rhs.lotteryType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelSetting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelSetting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "announceTitle"),
    2: .same(proto: "announceContent"),
    3: .same(proto: "lovenumSwitch"),
    4: .same(proto: "seatLayout"),
    5: .same(proto: "coverId"),
    6: .same(proto: "seat9Show"),
    7: .same(proto: "seatCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.announceTitle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.announceContent) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lovenumSwitch) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.seatLayout) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.coverID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.seat9Show) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.seatCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.announceTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.announceTitle, fieldNumber: 1)
    }
    if !self.announceContent.isEmpty {
      try visitor.visitSingularStringField(value: self.announceContent, fieldNumber: 2)
    }
    if self.lovenumSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenumSwitch, fieldNumber: 3)
    }
    if self.seatLayout != 0 {
      try visitor.visitSingularInt32Field(value: self.seatLayout, fieldNumber: 4)
    }
    if self.coverID != 0 {
      try visitor.visitSingularInt32Field(value: self.coverID, fieldNumber: 5)
    }
    if self.seat9Show != 0 {
      try visitor.visitSingularInt32Field(value: self.seat9Show, fieldNumber: 6)
    }
    if self.seatCount != 0 {
      try visitor.visitSingularInt32Field(value: self.seatCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelSetting, rhs: OSChannelSetting) -> Bool {
    if lhs.announceTitle != rhs.announceTitle {return false}
    if lhs.announceContent != rhs.announceContent {return false}
    if lhs.lovenumSwitch != rhs.lovenumSwitch {return false}
    if lhs.seatLayout != rhs.seatLayout {return false}
    if lhs.coverID != rhs.coverID {return false}
    if lhs.seat9Show != rhs.seat9Show {return false}
    if lhs.seatCount != rhs.seatCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinReq, rhs: OSJoinReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "myself"),
    2: .same(proto: "channel"),
    3: .same(proto: "userInSeats"),
    4: .same(proto: "channelToken"),
    5: .same(proto: "WealthUsers"),
    6: .same(proto: "activityInfo"),
    7: .same(proto: "activeStatus"),
    8: .same(proto: "medalList"),
    9: .same(proto: "channelSetting"),
    10: .same(proto: "isOpenChannel"),
    11: .same(proto: "giveSelf"),
    12: .same(proto: "other"),
    13: .same(proto: "owner"),
    14: .same(proto: "mount"),
    15: .same(proto: "admissionEffects"),
    16: .same(proto: "bubbleInfo"),
    17: .same(proto: "honouredGuestCard"),
    18: .same(proto: "dressUpInfo"),
  ]

  fileprivate class _StorageClass {
    var _myself: OSUserInChannel? = nil
    var _channel: OSChannelVo? = nil
    var _userInSeats: [OSUserInSeats] = []
    var _channelToken: String = String()
    var _wealthUsers: [OSWealthUsers] = []
    var _activityInfo: OSActivityInfo? = nil
    var _activeStatus: OSActiveStatus? = nil
    var _medalList: [OSMedalList] = []
    var _channelSetting: OSChannelSetting? = nil
    var _isOpenChannel: Bool = false
    var _giveSelf: Int32 = 0
    var _other: OSChannelOther? = nil
    var _owner: OSUserVo? = nil
    var _mount: OSMount? = nil
    var _admissionEffects: OSAdmissionEffects? = nil
    var _bubbleInfo: OSBubbleInfo? = nil
    var _honouredGuestCard: OSHonouredGuestCard? = nil
    var _dressUpInfo: OSDressUpInfo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _myself = source._myself
      _channel = source._channel
      _userInSeats = source._userInSeats
      _channelToken = source._channelToken
      _wealthUsers = source._wealthUsers
      _activityInfo = source._activityInfo
      _activeStatus = source._activeStatus
      _medalList = source._medalList
      _channelSetting = source._channelSetting
      _isOpenChannel = source._isOpenChannel
      _giveSelf = source._giveSelf
      _other = source._other
      _owner = source._owner
      _mount = source._mount
      _admissionEffects = source._admissionEffects
      _bubbleInfo = source._bubbleInfo
      _honouredGuestCard = source._honouredGuestCard
      _dressUpInfo = source._dressUpInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._myself) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._channel) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._userInSeats) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._channelToken) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._wealthUsers) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._activityInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._activeStatus) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._channelSetting) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isOpenChannel) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._giveSelf) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._other) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._mount) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._admissionEffects) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bubbleInfo) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._honouredGuestCard) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._myself {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._userInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userInSeats, fieldNumber: 3)
      }
      if !_storage._channelToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelToken, fieldNumber: 4)
      }
      if !_storage._wealthUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._wealthUsers, fieldNumber: 5)
      }
      try { if let v = _storage._activityInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._activeStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 8)
      }
      try { if let v = _storage._channelSetting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isOpenChannel != false {
        try visitor.visitSingularBoolField(value: _storage._isOpenChannel, fieldNumber: 10)
      }
      if _storage._giveSelf != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giveSelf, fieldNumber: 11)
      }
      try { if let v = _storage._other {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._mount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._admissionEffects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._bubbleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._honouredGuestCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinRes, rhs: OSJoinRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._myself != rhs_storage._myself {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._userInSeats != rhs_storage._userInSeats {return false}
        if _storage._channelToken != rhs_storage._channelToken {return false}
        if _storage._wealthUsers != rhs_storage._wealthUsers {return false}
        if _storage._activityInfo != rhs_storage._activityInfo {return false}
        if _storage._activeStatus != rhs_storage._activeStatus {return false}
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._channelSetting != rhs_storage._channelSetting {return false}
        if _storage._isOpenChannel != rhs_storage._isOpenChannel {return false}
        if _storage._giveSelf != rhs_storage._giveSelf {return false}
        if _storage._other != rhs_storage._other {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._mount != rhs_storage._mount {return false}
        if _storage._admissionEffects != rhs_storage._admissionEffects {return false}
        if _storage._bubbleInfo != rhs_storage._bubbleInfo {return false}
        if _storage._honouredGuestCard != rhs_storage._honouredGuestCard {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressName"),
    2: .same(proto: "effectUrl"),
    3: .same(proto: "dressIcon"),
    4: .same(proto: "dressIconSvga"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressIcon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dressIconSvga) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 1)
    }
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 2)
    }
    if !self.dressIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIcon, fieldNumber: 3)
    }
    if !self.dressIconSvga.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIconSvga, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMount, rhs: OSMount) -> Bool {
    if lhs.dressName != rhs.dressName {return false}
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs.dressIcon != rhs.dressIcon {return false}
    if lhs.dressIconSvga != rhs.dressIconSvga {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAdmissionEffects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdmissionEffects"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressName"),
    2: .same(proto: "effectUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 1)
    }
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAdmissionEffects, rhs: OSAdmissionEffects) -> Bool {
    if lhs.dressName != rhs.dressName {return false}
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBackReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BackReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBackReq, rhs: OSBackReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBackRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BackRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "myself"),
    2: .same(proto: "channel"),
    3: .same(proto: "userInSeats"),
    4: .same(proto: "channelToken"),
    5: .same(proto: "WealthUsers"),
    6: .same(proto: "activityInfo"),
    7: .same(proto: "activeStatus"),
    8: .same(proto: "medalList"),
    9: .same(proto: "channelSetting"),
    10: .same(proto: "isOpenChannel"),
    11: .same(proto: "giveSelf"),
    12: .same(proto: "other"),
    13: .same(proto: "owner"),
    14: .same(proto: "mount"),
    15: .same(proto: "admissionEffects"),
    16: .same(proto: "bubbleInfo"),
    17: .same(proto: "dressUpInfo"),
  ]

  fileprivate class _StorageClass {
    var _myself: OSUserInChannel? = nil
    var _channel: OSChannelVo? = nil
    var _userInSeats: [OSUserInSeats] = []
    var _channelToken: String = String()
    var _wealthUsers: [OSWealthUsers] = []
    var _activityInfo: OSActivityInfo? = nil
    var _activeStatus: OSActiveStatus? = nil
    var _medalList: [OSMedalList] = []
    var _channelSetting: OSChannelSetting? = nil
    var _isOpenChannel: Bool = false
    var _giveSelf: Int32 = 0
    var _other: OSChannelOther? = nil
    var _owner: OSUserVo? = nil
    var _mount: OSMount? = nil
    var _admissionEffects: OSAdmissionEffects? = nil
    var _bubbleInfo: OSBubbleInfo? = nil
    var _dressUpInfo: OSDressUpInfo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _myself = source._myself
      _channel = source._channel
      _userInSeats = source._userInSeats
      _channelToken = source._channelToken
      _wealthUsers = source._wealthUsers
      _activityInfo = source._activityInfo
      _activeStatus = source._activeStatus
      _medalList = source._medalList
      _channelSetting = source._channelSetting
      _isOpenChannel = source._isOpenChannel
      _giveSelf = source._giveSelf
      _other = source._other
      _owner = source._owner
      _mount = source._mount
      _admissionEffects = source._admissionEffects
      _bubbleInfo = source._bubbleInfo
      _dressUpInfo = source._dressUpInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._myself) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._channel) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._userInSeats) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._channelToken) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._wealthUsers) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._activityInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._activeStatus) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._channelSetting) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isOpenChannel) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._giveSelf) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._other) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._owner) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._mount) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._admissionEffects) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bubbleInfo) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._myself {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._channel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._userInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userInSeats, fieldNumber: 3)
      }
      if !_storage._channelToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelToken, fieldNumber: 4)
      }
      if !_storage._wealthUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._wealthUsers, fieldNumber: 5)
      }
      try { if let v = _storage._activityInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._activeStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 8)
      }
      try { if let v = _storage._channelSetting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isOpenChannel != false {
        try visitor.visitSingularBoolField(value: _storage._isOpenChannel, fieldNumber: 10)
      }
      if _storage._giveSelf != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giveSelf, fieldNumber: 11)
      }
      try { if let v = _storage._other {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._owner {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._mount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._admissionEffects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._bubbleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBackRes, rhs: OSBackRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._myself != rhs_storage._myself {return false}
        if _storage._channel != rhs_storage._channel {return false}
        if _storage._userInSeats != rhs_storage._userInSeats {return false}
        if _storage._channelToken != rhs_storage._channelToken {return false}
        if _storage._wealthUsers != rhs_storage._wealthUsers {return false}
        if _storage._activityInfo != rhs_storage._activityInfo {return false}
        if _storage._activeStatus != rhs_storage._activeStatus {return false}
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._channelSetting != rhs_storage._channelSetting {return false}
        if _storage._isOpenChannel != rhs_storage._isOpenChannel {return false}
        if _storage._giveSelf != rhs_storage._giveSelf {return false}
        if _storage._other != rhs_storage._other {return false}
        if _storage._owner != rhs_storage._owner {return false}
        if _storage._mount != rhs_storage._mount {return false}
        if _storage._admissionEffects != rhs_storage._admissionEffects {return false}
        if _storage._bubbleInfo != rhs_storage._bubbleInfo {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExitReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExitReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExitReq, rhs: OSExitReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExitRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExitRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExitRes, rhs: OSExitRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRealTimeInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RealTimeInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "ownerId"),
    3: .same(proto: "pkRoundId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pkRoundID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 2)
    }
    if !self.pkRoundID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkRoundID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRealTimeInfoReq, rhs: OSRealTimeInfoReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.pkRoundID != rhs.pkRoundID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRealTimeInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RealTimeInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "onlineNumber"),
    2: .same(proto: "userInSeats"),
    3: .same(proto: "wealthUsers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.onlineNumber) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.wealthUsers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.onlineNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.onlineNumber, fieldNumber: 1)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 2)
    }
    if !self.wealthUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.wealthUsers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRealTimeInfoRes, rhs: OSRealTimeInfoRes) -> Bool {
    if lhs.onlineNumber != rhs.onlineNumber {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.wealthUsers != rhs.wealthUsers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineReportReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineReportReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineReportReq, rhs: OSOnlineReportReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineReportRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineReportRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineReportRes, rhs: OSOnlineReportRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDetailReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetailReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDetailReq, rhs: OSDetailReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDetailRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetailRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adminList"),
    2: .same(proto: "channel"),
    3: .same(proto: "family"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.adminList) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._family) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.adminList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.adminList, fieldNumber: 1)
    }
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._family {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDetailRes, rhs: OSDetailRes) -> Bool {
    if lhs.adminList != rhs.adminList {return false}
    if lhs._channel != rhs._channel {return false}
    if lhs._family != rhs._family {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAdminList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "userId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "nickname"),
    5: .same(proto: "avatarUrl"),
    6: .same(proto: "gender"),
    7: .same(proto: "seat"),
    8: .same(proto: "powerType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.seat) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.powerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 4)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    if self.seat != 0 {
      try visitor.visitSingularInt32Field(value: self.seat, fieldNumber: 7)
    }
    if self.powerType != .unknown {
      try visitor.visitSingularEnumField(value: self.powerType, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAdminList, rhs: OSAdminList) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.seat != rhs.seat {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "channelNo"),
    3: .same(proto: "channelName"),
    4: .same(proto: "ownerAccountId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channelNo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.ownerAccountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.channelNo != 0 {
      try visitor.visitSingularInt32Field(value: self.channelNo, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if self.ownerAccountID != 0 {
      try visitor.visitSingularInt32Field(value: self.ownerAccountID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelDetail, rhs: OSChannelDetail) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelNo != rhs.channelNo {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.ownerAccountID != rhs.ownerAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFamilyInChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FamilyInChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "accountId"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFamilyInChannel, rhs: OSFamilyInChannel) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEditChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "avatarUrl"),
    3: .same(proto: "channelPwd"),
    4: .same(proto: "channelName"),
    5: .same(proto: "welcomingSpeech"),
    6: .same(proto: "menuId"),
    7: .same(proto: "coverUrl"),
    8: .same(proto: "channelType"),
    9: .same(proto: "updatePassword"),
    10: .same(proto: "updateWelcomingSpeech"),
    11: .same(proto: "coverId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelPwd) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.welcomingSpeech) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.menuID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.coverURL) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.updatePassword) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.updateWelcomingSpeech) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.coverID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 2)
    }
    if !self.channelPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPwd, fieldNumber: 3)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 4)
    }
    if !self.welcomingSpeech.isEmpty {
      try visitor.visitSingularStringField(value: self.welcomingSpeech, fieldNumber: 5)
    }
    if self.menuID != 0 {
      try visitor.visitSingularInt32Field(value: self.menuID, fieldNumber: 6)
    }
    if !self.coverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coverURL, fieldNumber: 7)
    }
    if self.channelType != .unkown {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 8)
    }
    if self.updatePassword != false {
      try visitor.visitSingularBoolField(value: self.updatePassword, fieldNumber: 9)
    }
    if self.updateWelcomingSpeech != false {
      try visitor.visitSingularBoolField(value: self.updateWelcomingSpeech, fieldNumber: 10)
    }
    if self.coverID != 0 {
      try visitor.visitSingularInt32Field(value: self.coverID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEditChannelReq, rhs: OSEditChannelReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.channelPwd != rhs.channelPwd {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.welcomingSpeech != rhs.welcomingSpeech {return false}
    if lhs.menuID != rhs.menuID {return false}
    if lhs.coverURL != rhs.coverURL {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.updatePassword != rhs.updatePassword {return false}
    if lhs.updateWelcomingSpeech != rhs.updateWelcomingSpeech {return false}
    if lhs.coverID != rhs.coverID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEditChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditChannelRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEditChannelRes, rhs: OSEditChannelRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTagsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTagsReq, rhs: OSTagsReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTagsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTagsRes, rhs: OSTagsRes) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tagType"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tagType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tagType != .unknown {
      try visitor.visitSingularEnumField(value: self.tagType, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTags, rhs: OSTags) -> Bool {
    if lhs.tagType != rhs.tagType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "tagType"),
    4: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.tagType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.tagType != .unknown {
      try visitor.visitSingularEnumField(value: self.tagType, fieldNumber: 3)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftListReq, rhs: OSGiftListReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.tagType != rhs.tagType {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftListRes, rhs: OSGiftListRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftId"),
    2: .same(proto: "name"),
    3: .same(proto: "iconUrl"),
    4: .same(proto: "value"),
    5: .same(proto: "effects"),
    6: .same(proto: "cornerIcon"),
    7: .same(proto: "count"),
    8: .same(proto: "explainUrl"),
    9: .same(proto: "lotteryEffcts"),
    10: .same(proto: "expireTime"),
    11: .same(proto: "giveStatus"),
    12: .same(proto: "bannerType"),
    13: .same(proto: "bannerContent"),
    14: .same(proto: "showPop"),
    15: .same(proto: "giftFlag"),
    16: .same(proto: "level"),
    17: .same(proto: "expireTimeId"),
    18: .same(proto: "dbTimestamp"),
  ]

  fileprivate class _StorageClass {
    var _giftID: Int32 = 0
    var _name: String = String()
    var _iconURL: String = String()
    var _value: Int32 = 0
    var _effects: String = String()
    var _cornerIcon: String = String()
    var _count: Int32 = 0
    var _explainURL: String = String()
    var _lotteryEffcts: String = String()
    var _expireTime: Int64 = 0
    var _giveStatus: Int32 = 0
    var _bannerType: Int32 = 0
    var _bannerContent: String = String()
    var _showPop: Int32 = 0
    var _giftFlag: Int32 = 0
    var _level: Int32 = 0
    var _expireTimeID: Int64 = 0
    var _dbTimestamp: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _giftID = source._giftID
      _name = source._name
      _iconURL = source._iconURL
      _value = source._value
      _effects = source._effects
      _cornerIcon = source._cornerIcon
      _count = source._count
      _explainURL = source._explainURL
      _lotteryEffcts = source._lotteryEffcts
      _expireTime = source._expireTime
      _giveStatus = source._giveStatus
      _bannerType = source._bannerType
      _bannerContent = source._bannerContent
      _showPop = source._showPop
      _giftFlag = source._giftFlag
      _level = source._level
      _expireTimeID = source._expireTimeID
      _dbTimestamp = source._dbTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._giftID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._iconURL) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._value) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._effects) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._cornerIcon) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._count) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._explainURL) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._lotteryEffcts) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._expireTime) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._giveStatus) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._bannerType) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._bannerContent) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._showPop) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._giftFlag) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._level) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._expireTimeID) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._dbTimestamp) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._giftID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._iconURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iconURL, fieldNumber: 3)
      }
      if _storage._value != 0 {
        try visitor.visitSingularInt32Field(value: _storage._value, fieldNumber: 4)
      }
      if !_storage._effects.isEmpty {
        try visitor.visitSingularStringField(value: _storage._effects, fieldNumber: 5)
      }
      if !_storage._cornerIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cornerIcon, fieldNumber: 6)
      }
      if _storage._count != 0 {
        try visitor.visitSingularInt32Field(value: _storage._count, fieldNumber: 7)
      }
      if !_storage._explainURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._explainURL, fieldNumber: 8)
      }
      if !_storage._lotteryEffcts.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lotteryEffcts, fieldNumber: 9)
      }
      if _storage._expireTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expireTime, fieldNumber: 10)
      }
      if _storage._giveStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giveStatus, fieldNumber: 11)
      }
      if _storage._bannerType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bannerType, fieldNumber: 12)
      }
      if !_storage._bannerContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bannerContent, fieldNumber: 13)
      }
      if _storage._showPop != 0 {
        try visitor.visitSingularInt32Field(value: _storage._showPop, fieldNumber: 14)
      }
      if _storage._giftFlag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftFlag, fieldNumber: 15)
      }
      if _storage._level != 0 {
        try visitor.visitSingularInt32Field(value: _storage._level, fieldNumber: 16)
      }
      if _storage._expireTimeID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expireTimeID, fieldNumber: 17)
      }
      if _storage._dbTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._dbTimestamp, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftVo, rhs: OSGiftVo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._giftID != rhs_storage._giftID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._iconURL != rhs_storage._iconURL {return false}
        if _storage._value != rhs_storage._value {return false}
        if _storage._effects != rhs_storage._effects {return false}
        if _storage._cornerIcon != rhs_storage._cornerIcon {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._explainURL != rhs_storage._explainURL {return false}
        if _storage._lotteryEffcts != rhs_storage._lotteryEffcts {return false}
        if _storage._expireTime != rhs_storage._expireTime {return false}
        if _storage._giveStatus != rhs_storage._giveStatus {return false}
        if _storage._bannerType != rhs_storage._bannerType {return false}
        if _storage._bannerContent != rhs_storage._bannerContent {return false}
        if _storage._showPop != rhs_storage._showPop {return false}
        if _storage._giftFlag != rhs_storage._giftFlag {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._expireTimeID != rhs_storage._expireTimeID {return false}
        if _storage._dbTimestamp != rhs_storage._dbTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSViewInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSViewInfoReq, rhs: OSViewInfoReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSViewInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "medalList"),
    3: .same(proto: "userInChannel"),
    4: .same(proto: "dressUpInfo"),
    5: .same(proto: "following"),
    6: .same(proto: "followStatus"),
    7: .same(proto: "blacklistStatus"),
    8: .same(proto: "currentLocation"),
    9: .same(proto: "eidolonInfo"),
    10: .same(proto: "fansBadge"),
    11: .same(proto: "clubInfo"),
    12: .same(proto: "collectHallInfo"),
  ]

  fileprivate class _StorageClass {
    var _user: OSUserVo? = nil
    var _medalList: [OSMedalList] = []
    var _userInChannel: OSUserInChannel? = nil
    var _dressUpInfo: OSDressUpInfo? = nil
    var _following: Int32 = 0
    var _followStatus: OSFollowStatus = .unfollow
    var _blacklistStatus: Int32 = 0
    var _currentLocation: OSChannelVo? = nil
    var _eidolonInfo: OSEidolonInfo? = nil
    var _fansBadge: OSFansClubVo? = nil
    var _clubInfo: OSFansClubVo? = nil
    var _collectHallInfo: OSCollectionHallVo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _medalList = source._medalList
      _userInChannel = source._userInChannel
      _dressUpInfo = source._dressUpInfo
      _following = source._following
      _followStatus = source._followStatus
      _blacklistStatus = source._blacklistStatus
      _currentLocation = source._currentLocation
      _eidolonInfo = source._eidolonInfo
      _fansBadge = source._fansBadge
      _clubInfo = source._clubInfo
      _collectHallInfo = source._collectHallInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._userInChannel) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._following) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._followStatus) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._blacklistStatus) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._currentLocation) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._eidolonInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._fansBadge) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._clubInfo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._collectHallInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 2)
      }
      try { if let v = _storage._userInChannel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._following != 0 {
        try visitor.visitSingularInt32Field(value: _storage._following, fieldNumber: 5)
      }
      if _storage._followStatus != .unfollow {
        try visitor.visitSingularEnumField(value: _storage._followStatus, fieldNumber: 6)
      }
      if _storage._blacklistStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blacklistStatus, fieldNumber: 7)
      }
      try { if let v = _storage._currentLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._eidolonInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._fansBadge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._clubInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._collectHallInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSViewInfoRes, rhs: OSViewInfoRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._userInChannel != rhs_storage._userInChannel {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        if _storage._following != rhs_storage._following {return false}
        if _storage._followStatus != rhs_storage._followStatus {return false}
        if _storage._blacklistStatus != rhs_storage._blacklistStatus {return false}
        if _storage._currentLocation != rhs_storage._currentLocation {return false}
        if _storage._eidolonInfo != rhs_storage._eidolonInfo {return false}
        if _storage._fansBadge != rhs_storage._fansBadge {return false}
        if _storage._clubInfo != rhs_storage._clubInfo {return false}
        if _storage._collectHallInfo != rhs_storage._collectHallInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPickUpMicroPhoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickUpMicroPhoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPickUpMicroPhoneReq, rhs: OSPickUpMicroPhoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPickUpMicroPhoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickUpMicroPhoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPickUpMicroPhoneRes, rhs: OSPickUpMicroPhoneRes) -> Bool {
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPickUpMicroPhoneCompelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickUpMicroPhoneCompelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPickUpMicroPhoneCompelReq, rhs: OSPickUpMicroPhoneCompelReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPickUpMicroPhoneCompelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PickUpMicroPhoneCompelRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPickUpMicroPhoneCompelRes, rhs: OSPickUpMicroPhoneCompelRes) -> Bool {
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPutDownMicroPhoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutDownMicroPhoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
    3: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPutDownMicroPhoneReq, rhs: OSPutDownMicroPhoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPutDownMicroPhoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PutDownMicroPhoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPutDownMicroPhoneRes, rhs: OSPutDownMicroPhoneRes) -> Bool {
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExchangeMicroPhoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeMicroPhoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExchangeMicroPhoneReq, rhs: OSExchangeMicroPhoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExchangeMicroPhoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeMicroPhoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExchangeMicroPhoneRes, rhs: OSExchangeMicroPhoneRes) -> Bool {
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsNotAllowedReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsNotAllowedReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsNotAllowedReq, rhs: OSWordsNotAllowedReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsNotAllowedRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsNotAllowedRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsNotAllowedRes, rhs: OSWordsNotAllowedRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsAllowedReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsAllowedReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsAllowedReq, rhs: OSWordsAllowedReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsAllowedRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsAllowedRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsAllowedRes, rhs: OSWordsAllowedRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLockMicroPhoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockMicroPhoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLockMicroPhoneReq, rhs: OSLockMicroPhoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLockMicroPhoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockMicroPhoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLockMicroPhoneRes, rhs: OSLockMicroPhoneRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnLockMicrophoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLockMicrophoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnLockMicrophoneReq, rhs: OSUnLockMicrophoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnLockMicrophoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLockMicrophoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnLockMicrophoneRes, rhs: OSUnLockMicrophoneRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLockAllMicrophoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockAllMicrophoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLockAllMicrophoneReq, rhs: OSLockAllMicrophoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLockAllMicrophoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockAllMicrophoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLockAllMicrophoneRes, rhs: OSLockAllMicrophoneRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnLockAllMicrophoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLockAllMicrophoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnLockAllMicrophoneReq, rhs: OSUnLockAllMicrophoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnLockAllMicrophoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLockAllMicrophoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnLockAllMicrophoneRes, rhs: OSUnLockAllMicrophoneRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLockSeatVoiceReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockSeatVoiceReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLockSeatVoiceReq, rhs: OSLockSeatVoiceReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLockSeatVoiceRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LockSeatVoiceRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLockSeatVoiceRes, rhs: OSLockSeatVoiceRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnLockSeatVoiceReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLockSeatVoiceReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnLockSeatVoiceReq, rhs: OSUnLockSeatVoiceReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnLockSeatVoiceRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnLockSeatVoiceRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnLockSeatVoiceRes, rhs: OSUnLockSeatVoiceRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTurnOntheMicrophoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnOntheMicrophoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTurnOntheMicrophoneReq, rhs: OSTurnOntheMicrophoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTurnOntheMicrophoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnOntheMicrophoneRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTurnOntheMicrophoneRes, rhs: OSTurnOntheMicrophoneRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTurnOfftheMicrophoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnOfftheMicrophoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTurnOfftheMicrophoneReq, rhs: OSTurnOfftheMicrophoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTurnOfftheMicrophoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnOfftheMicrophoneRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTurnOfftheMicrophoneRes, rhs: OSTurnOfftheMicrophoneRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHoldOnMicroPhoneReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoldOnMicroPhoneReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatIndex"),
    3: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 2)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHoldOnMicroPhoneReq, rhs: OSHoldOnMicroPhoneReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHoldOnMicroPhoneRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoldOnMicroPhoneRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHoldOnMicroPhoneRes, rhs: OSHoldOnMicroPhoneRes) -> Bool {
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSKickYouOutReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KickYouOutReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSKickYouOutReq, rhs: OSKickYouOutReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSKickYouOutRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KickYouOutRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tip"),
    2: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tip) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tip.isEmpty {
      try visitor.visitSingularStringField(value: self.tip, fieldNumber: 1)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSKickYouOutRes, rhs: OSKickYouOutRes) -> Bool {
    if lhs.tip != rhs.tip {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSetSuperAdminReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSuperAdminReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSetSuperAdminReq, rhs: OSSetSuperAdminReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSetSuperAdminRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetSuperAdminRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSetSuperAdminRes, rhs: OSSetSuperAdminRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCancelSuperAdminReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelSuperAdminReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCancelSuperAdminReq, rhs: OSCancelSuperAdminReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCancelSuperAdminRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelSuperAdminRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCancelSuperAdminRes, rhs: OSCancelSuperAdminRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSetAdminReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAdminReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSetAdminReq, rhs: OSSetAdminReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSetAdminRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAdminRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSetAdminRes, rhs: OSSetAdminRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCancelAdminReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelAdminReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCancelAdminReq, rhs: OSCancelAdminReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCancelAdminRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelAdminRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCancelAdminRes, rhs: OSCancelAdminRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExchangeSeatLayoutReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeSeatLayoutReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatLayout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatLayout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatLayout != 0 {
      try visitor.visitSingularInt32Field(value: self.seatLayout, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExchangeSeatLayoutReq, rhs: OSExchangeSeatLayoutReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatLayout != rhs.seatLayout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExchangeSeatLayoutRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExchangeSeatLayoutRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExchangeSeatLayoutRes, rhs: OSExchangeSeatLayoutRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsNotAllowedAllReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsNotAllowedAllReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsNotAllowedAllReq, rhs: OSWordsNotAllowedAllReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsNotAllowedAllRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsNotAllowedAllRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsNotAllowedAllRes, rhs: OSWordsNotAllowedAllRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsAllowedAllReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsAllowedAllReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsAllowedAllReq, rhs: OSWordsAllowedAllReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWordsAllowedAllRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WordsAllowedAllRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWordsAllowedAllRes, rhs: OSWordsAllowedAllRes) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGivePresentsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GivePresentsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "giftId"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "targetIds"),
    5: .same(proto: "bannerType"),
    6: .same(proto: "bannerContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.bannerType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 4)
    }
    if self.bannerType != 0 {
      try visitor.visitSingularInt32Field(value: self.bannerType, fieldNumber: 5)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGivePresentsReq, rhs: OSGivePresentsReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.bannerType != rhs.bannerType {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGivePresentsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GivePresentsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "gift"),
    3: .same(proto: "lovenum"),
    4: .same(proto: "userInSeats"),
    5: .same(proto: "medalList"),
    6: .same(proto: "isGiftBanner"),
    7: .same(proto: "wallet"),
    8: .same(proto: "diamondsAmount"),
    9: .same(proto: "gameCoin"),
    10: .same(proto: "crystalAmount"),
    11: .same(proto: "systemTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gift) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.medalList) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.isGiftBanner) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.diamondsAmount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.gameCoin) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.crystalAmount) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.systemTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._gift {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 3)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 4)
    }
    if !self.medalList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.medalList, fieldNumber: 5)
    }
    if self.isGiftBanner != 0 {
      try visitor.visitSingularInt32Field(value: self.isGiftBanner, fieldNumber: 6)
    }
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.diamondsAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsAmount, fieldNumber: 8)
    }
    if self.gameCoin != 0 {
      try visitor.visitSingularInt32Field(value: self.gameCoin, fieldNumber: 9)
    }
    if self.crystalAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.crystalAmount, fieldNumber: 10)
    }
    if self.systemTime != 0 {
      try visitor.visitSingularInt64Field(value: self.systemTime, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGivePresentsRes, rhs: OSGivePresentsRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._gift != rhs._gift {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.medalList != rhs.medalList {return false}
    if lhs.isGiftBanner != rhs.isGiftBanner {return false}
    if lhs._wallet != rhs._wallet {return false}
    if lhs.diamondsAmount != rhs.diamondsAmount {return false}
    if lhs.gameCoin != rhs.gameCoin {return false}
    if lhs.crystalAmount != rhs.crystalAmount {return false}
    if lhs.systemTime != rhs.systemTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWalletVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    8: .same(proto: "diamondsAmount"),
    9: .same(proto: "gameCoin"),
    10: .same(proto: "crystalAmount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.diamondsAmount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.gameCoin) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.crystalAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.diamondsAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsAmount, fieldNumber: 8)
    }
    if self.gameCoin != 0 {
      try visitor.visitSingularInt32Field(value: self.gameCoin, fieldNumber: 9)
    }
    if self.crystalAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.crystalAmount, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWalletVo, rhs: OSWalletVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.diamondsAmount != rhs.diamondsAmount {return false}
    if lhs.gameCoin != rhs.gameCoin {return false}
    if lhs.crystalAmount != rhs.crystalAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiveLuckyBagPresentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiveLuckyBagPresentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "giftId"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "targetIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiveLuckyBagPresentReq, rhs: OSGiveLuckyBagPresentReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiveLuckyBagPresentRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiveLuckyBagPresentRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "luckyGifts"),
    3: .same(proto: "lovenum"),
    4: .same(proto: "userInSeats"),
    5: .same(proto: "medalList"),
    6: .same(proto: "isGiftBanner"),
    7: .same(proto: "wallet"),
    8: .same(proto: "diamondsAmount"),
    9: .same(proto: "gameCoin"),
    10: .same(proto: "crystalAmount"),
    11: .same(proto: "systemTime"),
    12: .same(proto: "lotteryName"),
    13: .same(proto: "lotteryEffcts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.luckyGifts) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.medalList) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.isGiftBanner) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.diamondsAmount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.gameCoin) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.crystalAmount) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.systemTime) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.lotteryName) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.lotteryEffcts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.luckyGifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.luckyGifts, fieldNumber: 2)
    }
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 3)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 4)
    }
    if !self.medalList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.medalList, fieldNumber: 5)
    }
    if self.isGiftBanner != 0 {
      try visitor.visitSingularInt32Field(value: self.isGiftBanner, fieldNumber: 6)
    }
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.diamondsAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsAmount, fieldNumber: 8)
    }
    if self.gameCoin != 0 {
      try visitor.visitSingularInt32Field(value: self.gameCoin, fieldNumber: 9)
    }
    if self.crystalAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.crystalAmount, fieldNumber: 10)
    }
    if self.systemTime != 0 {
      try visitor.visitSingularInt64Field(value: self.systemTime, fieldNumber: 11)
    }
    if !self.lotteryName.isEmpty {
      try visitor.visitSingularStringField(value: self.lotteryName, fieldNumber: 12)
    }
    if !self.lotteryEffcts.isEmpty {
      try visitor.visitSingularStringField(value: self.lotteryEffcts, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiveLuckyBagPresentRes, rhs: OSGiveLuckyBagPresentRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.luckyGifts != rhs.luckyGifts {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.medalList != rhs.medalList {return false}
    if lhs.isGiftBanner != rhs.isGiftBanner {return false}
    if lhs._wallet != rhs._wallet {return false}
    if lhs.diamondsAmount != rhs.diamondsAmount {return false}
    if lhs.gameCoin != rhs.gameCoin {return false}
    if lhs.crystalAmount != rhs.crystalAmount {return false}
    if lhs.systemTime != rhs.systemTime {return false}
    if lhs.lotteryName != rhs.lotteryName {return false}
    if lhs.lotteryEffcts != rhs.lotteryEffcts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLuckyGiftVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LuckyGiftVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftId"),
    2: .same(proto: "giftName"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "giftIconUrl"),
    5: .same(proto: "lovenum"),
    6: .same(proto: "giftValue"),
    7: .same(proto: "giftEffects"),
    8: .same(proto: "targetId"),
    9: .same(proto: "targetName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.giftIconURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.giftValue) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.giftEffects) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.targetName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 1)
    }
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.giftIconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIconURL, fieldNumber: 4)
    }
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 5)
    }
    if self.giftValue != 0 {
      try visitor.visitSingularInt32Field(value: self.giftValue, fieldNumber: 6)
    }
    if !self.giftEffects.isEmpty {
      try visitor.visitSingularStringField(value: self.giftEffects, fieldNumber: 7)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 8)
    }
    if !self.targetName.isEmpty {
      try visitor.visitSingularStringField(value: self.targetName, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLuckyGiftVo, rhs: OSLuckyGiftVo) -> Bool {
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.giftIconURL != rhs.giftIconURL {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.giftValue != rhs.giftValue {return false}
    if lhs.giftEffects != rhs.giftEffects {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.targetName != rhs.targetName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGivePresentsUseBackpackReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GivePresentsUseBackpackReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "giftId"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "targetIds"),
    5: .same(proto: "bannerType"),
    6: .same(proto: "bannerContent"),
    7: .same(proto: "expireTimeId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.bannerType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.expireTimeID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 4)
    }
    if self.bannerType != 0 {
      try visitor.visitSingularInt32Field(value: self.bannerType, fieldNumber: 5)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 6)
    }
    if self.expireTimeID != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTimeID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGivePresentsUseBackpackReq, rhs: OSGivePresentsUseBackpackReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.bannerType != rhs.bannerType {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.expireTimeID != rhs.expireTimeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGivePresentsUseBackpackRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GivePresentsUseBackpackRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "gift"),
    3: .same(proto: "lovenum"),
    4: .same(proto: "userInSeats"),
    5: .same(proto: "medalList"),
    6: .same(proto: "isGiftBanner"),
    7: .same(proto: "wallet"),
    8: .same(proto: "diamondsAmount"),
    9: .same(proto: "gameCoin"),
    10: .same(proto: "crystalAmount"),
    11: .same(proto: "systemTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gift) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.medalList) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.isGiftBanner) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.diamondsAmount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.gameCoin) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.crystalAmount) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.systemTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._gift {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 3)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 4)
    }
    if !self.medalList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.medalList, fieldNumber: 5)
    }
    if self.isGiftBanner != 0 {
      try visitor.visitSingularInt32Field(value: self.isGiftBanner, fieldNumber: 6)
    }
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.diamondsAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsAmount, fieldNumber: 8)
    }
    if self.gameCoin != 0 {
      try visitor.visitSingularInt32Field(value: self.gameCoin, fieldNumber: 9)
    }
    if self.crystalAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.crystalAmount, fieldNumber: 10)
    }
    if self.systemTime != 0 {
      try visitor.visitSingularInt64Field(value: self.systemTime, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGivePresentsUseBackpackRes, rhs: OSGivePresentsUseBackpackRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._gift != rhs._gift {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.medalList != rhs.medalList {return false}
    if lhs.isGiftBanner != rhs.isGiftBanner {return false}
    if lhs._wallet != rhs._wallet {return false}
    if lhs.diamondsAmount != rhs.diamondsAmount {return false}
    if lhs.gameCoin != rhs.gameCoin {return false}
    if lhs.crystalAmount != rhs.crystalAmount {return false}
    if lhs.systemTime != rhs.systemTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGivePresentsFansClubReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GivePresentsFansClubReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "giftId"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "targetIds"),
    5: .same(proto: "bannerType"),
    6: .same(proto: "bannerContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.targetIds) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.bannerType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.targetIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.targetIds, fieldNumber: 4)
    }
    if self.bannerType != 0 {
      try visitor.visitSingularInt32Field(value: self.bannerType, fieldNumber: 5)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGivePresentsFansClubReq, rhs: OSGivePresentsFansClubReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.bannerType != rhs.bannerType {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGivePresentsFansClubRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GivePresentsFansClubRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "gift"),
    3: .same(proto: "lovenum"),
    4: .same(proto: "userInSeats"),
    5: .same(proto: "medalList"),
    6: .same(proto: "isGiftBanner"),
    7: .same(proto: "wallet"),
    8: .same(proto: "diamondsAmount"),
    9: .same(proto: "gameCoin"),
    10: .same(proto: "crystalAmount"),
    11: .same(proto: "systemTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gift) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.medalList) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.isGiftBanner) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.diamondsAmount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.gameCoin) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.crystalAmount) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.systemTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._gift {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 3)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 4)
    }
    if !self.medalList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.medalList, fieldNumber: 5)
    }
    if self.isGiftBanner != 0 {
      try visitor.visitSingularInt32Field(value: self.isGiftBanner, fieldNumber: 6)
    }
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.diamondsAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsAmount, fieldNumber: 8)
    }
    if self.gameCoin != 0 {
      try visitor.visitSingularInt32Field(value: self.gameCoin, fieldNumber: 9)
    }
    if self.crystalAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.crystalAmount, fieldNumber: 10)
    }
    if self.systemTime != 0 {
      try visitor.visitSingularInt64Field(value: self.systemTime, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGivePresentsFansClubRes, rhs: OSGivePresentsFansClubRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._gift != rhs._gift {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.medalList != rhs.medalList {return false}
    if lhs.isGiftBanner != rhs.isGiftBanner {return false}
    if lhs._wallet != rhs._wallet {return false}
    if lhs.diamondsAmount != rhs.diamondsAmount {return false}
    if lhs.gameCoin != rhs.gameCoin {return false}
    if lhs.crystalAmount != rhs.crystalAmount {return false}
    if lhs.systemTime != rhs.systemTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPrivilegeCardsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivilegeCardsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPrivilegeCardsReq, rhs: OSPrivilegeCardsReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPrivilegeCardsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivilegeCardsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPrivilegeCardsRes, rhs: OSPrivilegeCardsRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPrivilegeCardVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivilegeCardVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privilegeCardId"),
    2: .same(proto: "cardName"),
    3: .same(proto: "cardUrl"),
    4: .same(proto: "cardType"),
    5: .same(proto: "cardDescription"),
    6: .same(proto: "effectiveCount"),
    7: .same(proto: "todayUseCount"),
    8: .same(proto: "expireTime"),
    9: .same(proto: "channelAvailableStatus"),
    10: .same(proto: "accountId"),
    11: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.privilegeCardID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cardName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cardURL) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.cardType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.cardDescription) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.effectiveCount) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.todayUseCount) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.expireTime) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.channelAvailableStatus) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.privilegeCardID != 0 {
      try visitor.visitSingularInt64Field(value: self.privilegeCardID, fieldNumber: 1)
    }
    if !self.cardName.isEmpty {
      try visitor.visitSingularStringField(value: self.cardName, fieldNumber: 2)
    }
    if !self.cardURL.isEmpty {
      try visitor.visitSingularStringField(value: self.cardURL, fieldNumber: 3)
    }
    if self.cardType != 0 {
      try visitor.visitSingularInt32Field(value: self.cardType, fieldNumber: 4)
    }
    if !self.cardDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.cardDescription, fieldNumber: 5)
    }
    if self.effectiveCount != 0 {
      try visitor.visitSingularInt32Field(value: self.effectiveCount, fieldNumber: 6)
    }
    if self.todayUseCount != 0 {
      try visitor.visitSingularInt32Field(value: self.todayUseCount, fieldNumber: 7)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTime, fieldNumber: 8)
    }
    if self.channelAvailableStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.channelAvailableStatus, fieldNumber: 9)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 10)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPrivilegeCardVo, rhs: OSPrivilegeCardVo) -> Bool {
    if lhs.privilegeCardID != rhs.privilegeCardID {return false}
    if lhs.cardName != rhs.cardName {return false}
    if lhs.cardURL != rhs.cardURL {return false}
    if lhs.cardType != rhs.cardType {return false}
    if lhs.cardDescription != rhs.cardDescription {return false}
    if lhs.effectiveCount != rhs.effectiveCount {return false}
    if lhs.todayUseCount != rhs.todayUseCount {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.channelAvailableStatus != rhs.channelAvailableStatus {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUsePrivilegeCardReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsePrivilegeCardReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "privilegeCardId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.privilegeCardID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.privilegeCardID != 0 {
      try visitor.visitSingularInt64Field(value: self.privilegeCardID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUsePrivilegeCardReq, rhs: OSUsePrivilegeCardReq) -> Bool {
    if lhs.privilegeCardID != rhs.privilegeCardID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUsePrivilegeCardRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsePrivilegeCardRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "residueCount"),
    2: .same(proto: "privilegeCard"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.residueCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._privilegeCard) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.residueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.residueCount, fieldNumber: 1)
    }
    try { if let v = self._privilegeCard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUsePrivilegeCardRes, rhs: OSUsePrivilegeCardRes) -> Bool {
    if lhs.residueCount != rhs.residueCount {return false}
    if lhs._privilegeCard != rhs._privilegeCard {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOpenLoveNumReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenLoveNumReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOpenLoveNumReq, rhs: OSOpenLoveNumReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOpenLoveNumRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenLoveNumRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOpenLoveNumRes, rhs: OSOpenLoveNumRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCloseLoveNumReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseLoveNumReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCloseLoveNumReq, rhs: OSCloseLoveNumReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCloseLoveNumRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloseLoveNumRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCloseLoveNumRes, rhs: OSCloseLoveNumRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEmptyLoveNumReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmptyLoveNumReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEmptyLoveNumReq, rhs: OSEmptyLoveNumReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEmptyLoveNumRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmptyLoveNumRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEmptyLoveNumRes, rhs: OSEmptyLoveNumRes) -> Bool {
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelRankingsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelRankingsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.type != .online {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelRankingsReq, rhs: OSChannelRankingsReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelRankingsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelRankingsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rankings"),
    2: .same(proto: "self"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rankings) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._self_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rankings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rankings, fieldNumber: 1)
    }
    try { if let v = self._self_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelRankingsRes, rhs: OSChannelRankingsRes) -> Bool {
    if lhs.rankings != rhs.rankings {return false}
    if lhs._self_p != rhs._self_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRankingVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RankingVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "userId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "gender"),
    5: .same(proto: "nickname"),
    6: .same(proto: "avatarUrl"),
    7: .same(proto: "giftValue"),
    8: .same(proto: "seat"),
    9: .same(proto: "powerType"),
    10: .same(proto: "userMedalList"),
    11: .same(proto: "differGiftValue"),
    12: .same(proto: "totalGiftValue"),
    13: .same(proto: "dressUpInfo"),
    14: .same(proto: "honouredGuestCard"),
    15: .same(proto: "fansBadge"),
  ]

  fileprivate class _StorageClass {
    var _index: Int32 = 0
    var _userID: String = String()
    var _accountID: String = String()
    var _gender: OSGender = .unknown
    var _nickname: String = String()
    var _avatarURL: String = String()
    var _giftValue: Int32 = 0
    var _seat: Int32 = 0
    var _powerType: OSPowerType = .unknown
    var _userMedalList: [OSMedalList] = []
    var _differGiftValue: Int32 = 0
    var _totalGiftValue: Int32 = 0
    var _dressUpInfo: OSDressUpInfo? = nil
    var _honouredGuestCard: OSHonouredGuestCard? = nil
    var _fansBadge: OSFansClubVo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _index = source._index
      _userID = source._userID
      _accountID = source._accountID
      _gender = source._gender
      _nickname = source._nickname
      _avatarURL = source._avatarURL
      _giftValue = source._giftValue
      _seat = source._seat
      _powerType = source._powerType
      _userMedalList = source._userMedalList
      _differGiftValue = source._differGiftValue
      _totalGiftValue = source._totalGiftValue
      _dressUpInfo = source._dressUpInfo
      _honouredGuestCard = source._honouredGuestCard
      _fansBadge = source._fansBadge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._index) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._accountID) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._gender) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._giftValue) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._seat) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._powerType) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._userMedalList) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._differGiftValue) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._totalGiftValue) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._honouredGuestCard) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._fansBadge) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._index != 0 {
        try visitor.visitSingularInt32Field(value: _storage._index, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._accountID, fieldNumber: 3)
      }
      if _storage._gender != .unknown {
        try visitor.visitSingularEnumField(value: _storage._gender, fieldNumber: 4)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 5)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 6)
      }
      if _storage._giftValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftValue, fieldNumber: 7)
      }
      if _storage._seat != 0 {
        try visitor.visitSingularInt32Field(value: _storage._seat, fieldNumber: 8)
      }
      if _storage._powerType != .unknown {
        try visitor.visitSingularEnumField(value: _storage._powerType, fieldNumber: 9)
      }
      if !_storage._userMedalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userMedalList, fieldNumber: 10)
      }
      if _storage._differGiftValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._differGiftValue, fieldNumber: 11)
      }
      if _storage._totalGiftValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalGiftValue, fieldNumber: 12)
      }
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._honouredGuestCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._fansBadge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRankingVo, rhs: OSRankingVo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._index != rhs_storage._index {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._gender != rhs_storage._gender {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._giftValue != rhs_storage._giftValue {return false}
        if _storage._seat != rhs_storage._seat {return false}
        if _storage._powerType != rhs_storage._powerType {return false}
        if _storage._userMedalList != rhs_storage._userMedalList {return false}
        if _storage._differGiftValue != rhs_storage._differGiftValue {return false}
        if _storage._totalGiftValue != rhs_storage._totalGiftValue {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        if _storage._honouredGuestCard != rhs_storage._honouredGuestCard {return false}
        if _storage._fansBadge != rhs_storage._fansBadge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAnnouncementSettingReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnouncementSettingReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "announceTitle"),
    3: .same(proto: "announceContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.announceTitle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.announceContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.announceTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.announceTitle, fieldNumber: 2)
    }
    if !self.announceContent.isEmpty {
      try visitor.visitSingularStringField(value: self.announceContent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAnnouncementSettingReq, rhs: OSAnnouncementSettingReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.announceTitle != rhs.announceTitle {return false}
    if lhs.announceContent != rhs.announceContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAnnouncementSettingRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnouncementSettingRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelSetting"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channelSetting) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channelSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAnnouncementSettingRes, rhs: OSAnnouncementSettingRes) -> Bool {
    if lhs._channelSetting != rhs._channelSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineUserReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineUserReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "channelId"),
    4: .same(proto: "powerType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.powerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if self.powerType != .unknown {
      try visitor.visitSingularEnumField(value: self.powerType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineUserReq, rhs: OSOnlineUserReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineUserRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineUserRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineUserRes, rhs: OSOnlineUserRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkTopicsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkTopicsReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkTopicsReq, rhs: OSPkTopicsReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkTopicsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkTopicsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkTopics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pkTopics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pkTopics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pkTopics, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkTopicsRes, rhs: OSPkTopicsRes) -> Bool {
    if lhs.pkTopics != rhs.pkTopics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkTopicsVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkTopicsVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkTopicsVo, rhs: OSPkTopicsVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCreatePkGameReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePkGameReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "topic"),
    3: .same(proto: "pkType"),
    4: .same(proto: "duration"),
    5: .same(proto: "blueTeam"),
    6: .same(proto: "redTeam"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.pkType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.blueTeam) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.redTeam) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if self.pkType != .oneToOne {
      try visitor.visitSingularEnumField(value: self.pkType, fieldNumber: 3)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 4)
    }
    if !self.blueTeam.isEmpty {
      try visitor.visitSingularStringField(value: self.blueTeam, fieldNumber: 5)
    }
    if !self.redTeam.isEmpty {
      try visitor.visitSingularStringField(value: self.redTeam, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCreatePkGameReq, rhs: OSCreatePkGameReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.pkType != rhs.pkType {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.blueTeam != rhs.blueTeam {return false}
    if lhs.redTeam != rhs.redTeam {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCreatePkGameRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePkGameRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkGame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pkGame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pkGame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCreatePkGameRes, rhs: OSCreatePkGameRes) -> Bool {
    if lhs._pkGame != rhs._pkGame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSParticipantVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParticipantVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkChannelId"),
    2: .same(proto: "pkId"),
    3: .same(proto: "team"),
    4: .same(proto: "userId"),
    5: .same(proto: "accountId"),
    6: .same(proto: "nickname"),
    7: .same(proto: "avatarUrl"),
    8: .same(proto: "lovenum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pkChannelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pkID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.team) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pkChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkChannelID, fieldNumber: 1)
    }
    if !self.pkID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkID, fieldNumber: 2)
    }
    if self.team != .teamUnknown {
      try visitor.visitSingularEnumField(value: self.team, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 5)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 6)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 7)
    }
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSParticipantVo, rhs: OSParticipantVo) -> Bool {
    if lhs.pkChannelID != rhs.pkChannelID {return false}
    if lhs.pkID != rhs.pkID {return false}
    if lhs.team != rhs.team {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkBossUserVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkBossUserVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "value"),
    6: .same(proto: "team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.team) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 5)
    }
    if self.team != .teamUnknown {
      try visitor.visitSingularEnumField(value: self.team, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkBossUserVo, rhs: OSPkBossUserVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.value != rhs.value {return false}
    if lhs.team != rhs.team {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkChannelInfoVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkChannelInfoVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "channelNo"),
    3: .same(proto: "channelName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "ownerId"),
    6: .same(proto: "seat0Status"),
    7: .same(proto: "seat1Status"),
    8: .same(proto: "seat2Status"),
    9: .same(proto: "seat3Status"),
    10: .same(proto: "seat4Status"),
    11: .same(proto: "seat5Status"),
    12: .same(proto: "seat6Status"),
    13: .same(proto: "seat7Status"),
    14: .same(proto: "seat8Status"),
    15: .same(proto: "seatsSwitch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channelNo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.seat0Status) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.seat1Status) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.seat2Status) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.seat3Status) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.seat4Status) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.seat5Status) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.seat6Status) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.seat7Status) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.seat8Status) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.seatsSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.channelNo != 0 {
      try visitor.visitSingularInt32Field(value: self.channelNo, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 5)
    }
    if self.seat0Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat0Status, fieldNumber: 6)
    }
    if self.seat1Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat1Status, fieldNumber: 7)
    }
    if self.seat2Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat2Status, fieldNumber: 8)
    }
    if self.seat3Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat3Status, fieldNumber: 9)
    }
    if self.seat4Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat4Status, fieldNumber: 10)
    }
    if self.seat5Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat5Status, fieldNumber: 11)
    }
    if self.seat6Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat6Status, fieldNumber: 12)
    }
    if self.seat7Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat7Status, fieldNumber: 13)
    }
    if self.seat8Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat8Status, fieldNumber: 14)
    }
    if self.seatsSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.seatsSwitch, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkChannelInfoVo, rhs: OSPkChannelInfoVo) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelNo != rhs.channelNo {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.seat0Status != rhs.seat0Status {return false}
    if lhs.seat1Status != rhs.seat1Status {return false}
    if lhs.seat2Status != rhs.seat2Status {return false}
    if lhs.seat3Status != rhs.seat3Status {return false}
    if lhs.seat4Status != rhs.seat4Status {return false}
    if lhs.seat5Status != rhs.seat5Status {return false}
    if lhs.seat6Status != rhs.seat6Status {return false}
    if lhs.seat7Status != rhs.seat7Status {return false}
    if lhs.seat8Status != rhs.seat8Status {return false}
    if lhs.seatsSwitch != rhs.seatsSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSearchPkChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchPkChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSearchPkChannelReq, rhs: OSSearchPkChannelReq) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSearchPkChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchPkChannelRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkChannelInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pkChannelInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pkChannelInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pkChannelInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSearchPkChannelRes, rhs: OSSearchPkChannelRes) -> Bool {
    if lhs.pkChannelInfo != rhs.pkChannelInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAskChannelPkReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AskChannelPkReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetChannelId"),
    3: .same(proto: "duration"),
    4: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetChannelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetChannelID, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 3)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAskChannelPkReq, rhs: OSAskChannelPkReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetChannelID != rhs.targetChannelID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAskChannelPkRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AskChannelPkRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAskChannelPkRes, rhs: OSAskChannelPkRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAcceptChannelPkReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcceptChannelPkReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetChannelId"),
    3: .same(proto: "duration"),
    4: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetChannelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetChannelID, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 3)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAcceptChannelPkReq, rhs: OSAcceptChannelPkReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetChannelID != rhs.targetChannelID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAcceptChannelPkRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcceptChannelPkRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAcceptChannelPkRes, rhs: OSAcceptChannelPkRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRefuseChannelPkReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefuseChannelPkReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetChannelId"),
    3: .same(proto: "duration"),
    4: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetChannelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetChannelID, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 3)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRefuseChannelPkReq, rhs: OSRefuseChannelPkReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetChannelID != rhs.targetChannelID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRefuseChannelPkRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefuseChannelPkRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRefuseChannelPkRes, rhs: OSRefuseChannelPkRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStopPkGameReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopPkGameReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "pkRoundId"),
    3: .same(proto: "type"),
    4: .same(proto: "targetChannelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pkRoundID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetChannelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.pkRoundID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkRoundID, fieldNumber: 2)
    }
    if self.type != .oneToOne {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.targetChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetChannelID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStopPkGameReq, rhs: OSStopPkGameReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.pkRoundID != rhs.pkRoundID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.targetChannelID != rhs.targetChannelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStopPkGameRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopPkGameRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkGame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pkGame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pkGame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStopPkGameRes, rhs: OSStopPkGameRes) -> Bool {
    if lhs._pkGame != rhs._pkGame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkLogReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkLogReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkLogReq, rhs: OSPkLogReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPkLogRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkLogRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPkLogRes, rhs: OSPkLogRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRandomChannelNameReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomChannelNameReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRandomChannelNameReq, rhs: OSRandomChannelNameReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRandomChannelNameRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomChannelNameRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "randomChannelName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.randomChannelName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.randomChannelName.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.randomChannelName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRandomChannelNameRes, rhs: OSRandomChannelNameRes) -> Bool {
    if lhs.randomChannelName != rhs.randomChannelName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRandomChannelNameVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RandomChannelNameVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuId"),
    2: .same(proto: "names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuID != 0 {
      try visitor.visitSingularInt32Field(value: self.menuID, fieldNumber: 1)
    }
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRandomChannelNameVo, rhs: OSRandomChannelNameVo) -> Bool {
    if lhs.menuID != rhs.menuID {return false}
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelGiftWallReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelGiftWallReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelGiftWallReq, rhs: OSChannelGiftWallReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelGiftWallRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelGiftWallRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelGiftWallRes, rhs: OSChannelGiftWallRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelGiftWallVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelGiftWallVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftId"),
    2: .same(proto: "giftName"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "giftIconUrl"),
    5: .same(proto: "timedCornerMark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.giftIconURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.timedCornerMark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 1)
    }
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.giftIconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIconURL, fieldNumber: 4)
    }
    if self.timedCornerMark != 0 {
      try visitor.visitSingularInt32Field(value: self.timedCornerMark, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelGiftWallVo, rhs: OSChannelGiftWallVo) -> Bool {
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.giftIconURL != rhs.giftIconURL {return false}
    if lhs.timedCornerMark != rhs.timedCornerMark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinChannelBlackListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChannelBlackListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinChannelBlackListReq, rhs: OSJoinChannelBlackListReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinChannelBlackListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinChannelBlackListRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinChannelBlackListRes, rhs: OSJoinChannelBlackListRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRemoveChannelBlackListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveChannelBlackListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRemoveChannelBlackListReq, rhs: OSRemoveChannelBlackListReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRemoveChannelBlackListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveChannelBlackListRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRemoveChannelBlackListRes, rhs: OSRemoveChannelBlackListRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelAdminListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelAdminListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelAdminListReq, rhs: OSChannelAdminListReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelAdminListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelAdminListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "superAdminList"),
    2: .same(proto: "adminList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.superAdminList) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.adminList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.superAdminList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.superAdminList, fieldNumber: 1)
    }
    if !self.adminList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.adminList, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelAdminListRes, rhs: OSChannelAdminListRes) -> Bool {
    if lhs.superAdminList != rhs.superAdminList {return false}
    if lhs.adminList != rhs.adminList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelBlackListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelBlackListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "channelId"),
    4: .same(proto: "searchStr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.searchStr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if !self.searchStr.isEmpty {
      try visitor.visitSingularStringField(value: self.searchStr, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelBlackListReq, rhs: OSChannelBlackListReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.searchStr != rhs.searchStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelBlackListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelBlackListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelBlackListRes, rhs: OSChannelBlackListRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelProhibitListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelProhibitListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "channelId"),
    4: .same(proto: "searchStr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.searchStr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if !self.searchStr.isEmpty {
      try visitor.visitSingularStringField(value: self.searchStr, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelProhibitListReq, rhs: OSChannelProhibitListReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.searchStr != rhs.searchStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelProhibitListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelProhibitListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelProhibitListRes, rhs: OSChannelProhibitListRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAfterJoinReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AfterJoinReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAfterJoinReq, rhs: OSAfterJoinReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAfterJoinRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AfterJoinRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eidolonInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._eidolonInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._eidolonInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAfterJoinRes, rhs: OSAfterJoinRes) -> Bool {
    if lhs._eidolonInfo != rhs._eidolonInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadRocketInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadRocketInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadRocketInfoReq, rhs: OSLoadRocketInfoReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadRocketInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadRocketInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadRocketInfoRes, rhs: OSLoadRocketInfoRes) -> Bool {
    if lhs.list != rhs.list {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rocket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "userId"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "nickname"),
    5: .same(proto: "iconUrl"),
    6: .same(proto: "alreadyCount"),
    7: .same(proto: "animationUrl"),
    8: .same(proto: "count"),
    9: .same(proto: "createTimeStamp"),
    10: .same(proto: "currentLevel"),
    11: .same(proto: "currentLevelMaxValue"),
    12: .same(proto: "currentTimeStamp"),
    13: .same(proto: "totalLevel"),
    14: .same(proto: "expireTimeStamp"),
    15: .same(proto: "height"),
    16: .same(proto: "diffValue"),
    17: .same(proto: "maxValue"),
    18: .same(proto: "needReduceValue"),
    19: .same(proto: "showLabel"),
    20: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _channelID: String = String()
    var _userID: String = String()
    var _avatarURL: String = String()
    var _nickname: String = String()
    var _iconURL: String = String()
    var _alreadyCount: Int32 = 0
    var _animationURL: String = String()
    var _count: Int32 = 0
    var _createTimeStamp: Int64 = 0
    var _currentLevel: Int32 = 0
    var _currentLevelMaxValue: Int32 = 0
    var _currentTimeStamp: Int64 = 0
    var _totalLevel: Int32 = 0
    var _expireTimeStamp: Int64 = 0
    var _height: Int32 = 0
    var _diffValue: Int32 = 0
    var _maxValue: Int32 = 0
    var _needReduceValue: Int32 = 0
    var _showLabel: Int32 = 0
    var _value: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _userID = source._userID
      _avatarURL = source._avatarURL
      _nickname = source._nickname
      _iconURL = source._iconURL
      _alreadyCount = source._alreadyCount
      _animationURL = source._animationURL
      _count = source._count
      _createTimeStamp = source._createTimeStamp
      _currentLevel = source._currentLevel
      _currentLevelMaxValue = source._currentLevelMaxValue
      _currentTimeStamp = source._currentTimeStamp
      _totalLevel = source._totalLevel
      _expireTimeStamp = source._expireTimeStamp
      _height = source._height
      _diffValue = source._diffValue
      _maxValue = source._maxValue
      _needReduceValue = source._needReduceValue
      _showLabel = source._showLabel
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._iconURL) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._alreadyCount) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._animationURL) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._count) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createTimeStamp) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._currentLevel) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._currentLevelMaxValue) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._currentTimeStamp) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._totalLevel) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._expireTimeStamp) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._diffValue) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._maxValue) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._needReduceValue) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._showLabel) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._value) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 3)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 4)
      }
      if !_storage._iconURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iconURL, fieldNumber: 5)
      }
      if _storage._alreadyCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._alreadyCount, fieldNumber: 6)
      }
      if !_storage._animationURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._animationURL, fieldNumber: 7)
      }
      if _storage._count != 0 {
        try visitor.visitSingularInt32Field(value: _storage._count, fieldNumber: 8)
      }
      if _storage._createTimeStamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTimeStamp, fieldNumber: 9)
      }
      if _storage._currentLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentLevel, fieldNumber: 10)
      }
      if _storage._currentLevelMaxValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentLevelMaxValue, fieldNumber: 11)
      }
      if _storage._currentTimeStamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._currentTimeStamp, fieldNumber: 12)
      }
      if _storage._totalLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalLevel, fieldNumber: 13)
      }
      if _storage._expireTimeStamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expireTimeStamp, fieldNumber: 14)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 15)
      }
      if _storage._diffValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._diffValue, fieldNumber: 16)
      }
      if _storage._maxValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxValue, fieldNumber: 17)
      }
      if _storage._needReduceValue != 0 {
        try visitor.visitSingularInt32Field(value: _storage._needReduceValue, fieldNumber: 18)
      }
      if _storage._showLabel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._showLabel, fieldNumber: 19)
      }
      if _storage._value != 0 {
        try visitor.visitSingularInt32Field(value: _storage._value, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRocket, rhs: OSRocket) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._iconURL != rhs_storage._iconURL {return false}
        if _storage._alreadyCount != rhs_storage._alreadyCount {return false}
        if _storage._animationURL != rhs_storage._animationURL {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._createTimeStamp != rhs_storage._createTimeStamp {return false}
        if _storage._currentLevel != rhs_storage._currentLevel {return false}
        if _storage._currentLevelMaxValue != rhs_storage._currentLevelMaxValue {return false}
        if _storage._currentTimeStamp != rhs_storage._currentTimeStamp {return false}
        if _storage._totalLevel != rhs_storage._totalLevel {return false}
        if _storage._expireTimeStamp != rhs_storage._expireTimeStamp {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._diffValue != rhs_storage._diffValue {return false}
        if _storage._maxValue != rhs_storage._maxValue {return false}
        if _storage._needReduceValue != rhs_storage._needReduceValue {return false}
        if _storage._showLabel != rhs_storage._showLabel {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHoursListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoursListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "hourType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hourType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.hourType != 0 {
      try visitor.visitSingularInt32Field(value: self.hourType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHoursListReq, rhs: OSHoursListReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.hourType != rhs.hourType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHoursListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoursListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topList"),
    2: .same(proto: "myRank"),
    3: .same(proto: "remainSeconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topList) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._myRank) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.remainSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.topList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topList, fieldNumber: 1)
    }
    try { if let v = self._myRank {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.remainSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.remainSeconds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHoursListRes, rhs: OSHoursListRes) -> Bool {
    if lhs.topList != rhs.topList {return false}
    if lhs._myRank != rhs._myRank {return false}
    if lhs.remainSeconds != rhs.remainSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHoursTopListVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoursTopListVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appFlag1"),
    2: .same(proto: "avatarUrl"),
    3: .same(proto: "channelId"),
    4: .same(proto: "channelName"),
    5: .same(proto: "differCount"),
    6: .same(proto: "following"),
    7: .same(proto: "giveGiftValue"),
    8: .same(proto: "hoursRanking"),
    9: .same(proto: "ownerId"),
    10: .same(proto: "ownerNickname"),
    11: .same(proto: "pkStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.appFlag1) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.differCount) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.following) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.giveGiftValue) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.hoursRanking) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.ownerNickname) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.pkStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.appFlag1 != 0 {
      try visitor.visitSingularInt32Field(value: self.appFlag1, fieldNumber: 1)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 4)
    }
    if self.differCount != 0 {
      try visitor.visitSingularInt32Field(value: self.differCount, fieldNumber: 5)
    }
    if self.following != 0 {
      try visitor.visitSingularInt32Field(value: self.following, fieldNumber: 6)
    }
    if self.giveGiftValue != 0 {
      try visitor.visitSingularInt32Field(value: self.giveGiftValue, fieldNumber: 7)
    }
    if self.hoursRanking != 0 {
      try visitor.visitSingularInt32Field(value: self.hoursRanking, fieldNumber: 8)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 9)
    }
    if !self.ownerNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerNickname, fieldNumber: 10)
    }
    if self.pkStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.pkStatus, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHoursTopListVo, rhs: OSHoursTopListVo) -> Bool {
    if lhs.appFlag1 != rhs.appFlag1 {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.differCount != rhs.differCount {return false}
    if lhs.following != rhs.following {return false}
    if lhs.giveGiftValue != rhs.giveGiftValue {return false}
    if lhs.hoursRanking != rhs.hoursRanking {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.ownerNickname != rhs.ownerNickname {return false}
    if lhs.pkStatus != rhs.pkStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMyClubReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyClubReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMyClubReq, rhs: OSMyClubReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMyClubRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyClubRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubInfo"),
    2: .same(proto: "badgeLevel"),
    3: .same(proto: "badgeIcon"),
    4: .same(proto: "userClubInfo"),
    5: .same(proto: "todayIntimacyInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clubInfo) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.badgeLevel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.badgeIcon) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userClubInfo) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._todayIntimacyInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clubInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.badgeLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.badgeLevel, fieldNumber: 2)
    }
    if !self.badgeIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.badgeIcon, fieldNumber: 3)
    }
    try { if let v = self._userClubInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._todayIntimacyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMyClubRes, rhs: OSMyClubRes) -> Bool {
    if lhs._clubInfo != rhs._clubInfo {return false}
    if lhs.badgeLevel != rhs.badgeLevel {return false}
    if lhs.badgeIcon != rhs.badgeIcon {return false}
    if lhs._userClubInfo != rhs._userClubInfo {return false}
    if lhs._todayIntimacyInfo != rhs._todayIntimacyInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinClubReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinClubReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubId"),
    2: .same(proto: "giftId"),
    3: .same(proto: "count"),
    4: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clubID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clubID != 0 {
      try visitor.visitSingularInt64Field(value: self.clubID, fieldNumber: 1)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinClubReq, rhs: OSJoinClubReq) -> Bool {
    if lhs.clubID != rhs.clubID {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.count != rhs.count {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinClubRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinClubRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubInfo"),
    2: .same(proto: "userClubInfo"),
    3: .same(proto: "todayIntimacyInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clubInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userClubInfo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._todayIntimacyInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._clubInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._userClubInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._todayIntimacyInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinClubRes, rhs: OSJoinClubRes) -> Bool {
    if lhs._clubInfo != rhs._clubInfo {return false}
    if lhs._userClubInfo != rhs._userClubInfo {return false}
    if lhs._todayIntimacyInfo != rhs._todayIntimacyInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBuyExpressionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyExpressionReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "id"),
    3: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBuyExpressionReq, rhs: OSBuyExpressionReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBuyExpressionRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyExpressionRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diamond"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diamond) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diamond != 0 {
      try visitor.visitSingularInt32Field(value: self.diamond, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBuyExpressionRes, rhs: OSBuyExpressionRes) -> Bool {
    if lhs.diamond != rhs.diamond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCommitExpressionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitExpressionReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "expressionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.expressionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.expressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.expressionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCommitExpressionReq, rhs: OSCommitExpressionReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.expressionID != rhs.expressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCommitExpressionRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitExpressionRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCommitExpressionRes, rhs: OSCommitExpressionRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadExpressionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadExpressionReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadExpressionReq, rhs: OSLoadExpressionReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadExpressionRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadExpressionRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadExpressionRes, rhs: OSLoadExpressionRes) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Expression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expressionId"),
    2: .same(proto: "name"),
    3: .same(proto: "imgUrl"),
    4: .same(proto: "cornerIcon"),
    5: .same(proto: "id"),
    6: .same(proto: "limitType"),
    7: .same(proto: "purchaseHint"),
    8: .same(proto: "prices"),
    9: .same(proto: "status"),
    10: .same(proto: "purchaseHintType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.expressionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imgURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cornerIcon) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.limitType) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.purchaseHint) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.prices) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.purchaseHintType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.expressionID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 3)
    }
    if !self.cornerIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.cornerIcon, fieldNumber: 4)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 5)
    }
    if self.limitType != 0 {
      try visitor.visitSingularInt32Field(value: self.limitType, fieldNumber: 6)
    }
    if !self.purchaseHint.isEmpty {
      try visitor.visitSingularStringField(value: self.purchaseHint, fieldNumber: 7)
    }
    if !self.prices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prices, fieldNumber: 8)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 9)
    }
    if self.purchaseHintType != 0 {
      try visitor.visitSingularInt32Field(value: self.purchaseHintType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSExpression, rhs: OSExpression) -> Bool {
    if lhs.expressionID != rhs.expressionID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.cornerIcon != rhs.cornerIcon {return false}
    if lhs.id != rhs.id {return false}
    if lhs.limitType != rhs.limitType {return false}
    if lhs.purchaseHint != rhs.purchaseHint {return false}
    if lhs.prices != rhs.prices {return false}
    if lhs.status != rhs.status {return false}
    if lhs.purchaseHintType != rhs.purchaseHintType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonalChannelInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonalChannelInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonalChannelInfoReq, rhs: OSPersonalChannelInfoReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonalChannelInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonalChannelInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "liveSwitch"),
    2: .same(proto: "seatsSwitch"),
    3: .same(proto: "wishDisplay"),
    4: .same(proto: "userWishGift"),
    5: .same(proto: "clubGiftInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.liveSwitch) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatsSwitch) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.wishDisplay) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userWishGift) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._clubGiftInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.liveSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.liveSwitch, fieldNumber: 1)
    }
    if self.seatsSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.seatsSwitch, fieldNumber: 2)
    }
    if self.wishDisplay != 0 {
      try visitor.visitSingularInt32Field(value: self.wishDisplay, fieldNumber: 3)
    }
    try { if let v = self._userWishGift {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._clubGiftInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonalChannelInfoRes, rhs: OSPersonalChannelInfoRes) -> Bool {
    if lhs.liveSwitch != rhs.liveSwitch {return false}
    if lhs.seatsSwitch != rhs.seatsSwitch {return false}
    if lhs.wishDisplay != rhs.wishDisplay {return false}
    if lhs._userWishGift != rhs._userWishGift {return false}
    if lhs._clubGiftInfo != rhs._clubGiftInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonalSeatsConfigReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonalSeatsConfigReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "seatsSwitch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatsSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.seatsSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.seatsSwitch, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonalSeatsConfigReq, rhs: OSPersonalSeatsConfigReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.seatsSwitch != rhs.seatsSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonalSeatsConfigRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonalSeatsConfigRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonalSeatsConfigRes, rhs: OSPersonalSeatsConfigRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonalLiveConfigReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonalLiveConfigReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "liveSwitch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.liveSwitch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.liveSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.liveSwitch, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonalLiveConfigReq, rhs: OSPersonalLiveConfigReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.liveSwitch != rhs.liveSwitch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonalLiveConfigRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonalLiveConfigRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonalLiveConfigRes, rhs: OSPersonalLiveConfigRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftInfoReq, rhs: OSWishGiftInfoReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finish"),
    2: .same(proto: "maxLimitValue"),
    3: .same(proto: "progressList"),
    4: .same(proto: "topUser"),
    5: .same(proto: "userCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxLimitValue) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.progressList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.topUser) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.userCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 1)
    }
    if self.maxLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLimitValue, fieldNumber: 2)
    }
    if !self.progressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.progressList, fieldNumber: 3)
    }
    if !self.topUser.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topUser, fieldNumber: 4)
    }
    if self.userCount != 0 {
      try visitor.visitSingularInt32Field(value: self.userCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftInfoRes, rhs: OSWishGiftInfoRes) -> Bool {
    if lhs.finish != rhs.finish {return false}
    if lhs.maxLimitValue != rhs.maxLimitValue {return false}
    if lhs.progressList != rhs.progressList {return false}
    if lhs.topUser != rhs.topUser {return false}
    if lhs.userCount != rhs.userCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftConfigReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftConfigReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "wishSwitch"),
    3: .same(proto: "userWishGifts"),
    4: .same(proto: "editWishGifts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.wishSwitch) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.userWishGifts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.editWishGifts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.wishSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.wishSwitch, fieldNumber: 2)
    }
    if !self.userWishGifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userWishGifts, fieldNumber: 3)
    }
    if !self.editWishGifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.editWishGifts, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftConfigReq, rhs: OSWishGiftConfigReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.wishSwitch != rhs.wishSwitch {return false}
    if lhs.userWishGifts != rhs.userWishGifts {return false}
    if lhs.editWishGifts != rhs.editWishGifts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftConfigRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftConfigRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finish"),
    2: .same(proto: "maxLimitValue"),
    3: .same(proto: "progressList"),
    4: .same(proto: "topUser"),
    5: .same(proto: "userCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxLimitValue) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.progressList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.topUser) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.userCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 1)
    }
    if self.maxLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLimitValue, fieldNumber: 2)
    }
    if !self.progressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.progressList, fieldNumber: 3)
    }
    if !self.topUser.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topUser, fieldNumber: 4)
    }
    if self.userCount != 0 {
      try visitor.visitSingularInt32Field(value: self.userCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftConfigRes, rhs: OSWishGiftConfigRes) -> Bool {
    if lhs.finish != rhs.finish {return false}
    if lhs.maxLimitValue != rhs.maxLimitValue {return false}
    if lhs.progressList != rhs.progressList {return false}
    if lhs.topUser != rhs.topUser {return false}
    if lhs.userCount != rhs.userCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserWishGift: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWishGift"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftId"),
    2: .same(proto: "giftCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 1)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserWishGift, rhs: OSUserWishGift) -> Bool {
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftRestartReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftRestartReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftRestartReq, rhs: OSWishGiftRestartReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftRestartRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftRestartRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finish"),
    2: .same(proto: "maxLimitValue"),
    3: .same(proto: "progressList"),
    4: .same(proto: "topUser"),
    5: .same(proto: "userCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxLimitValue) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.progressList) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.topUser) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.userCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 1)
    }
    if self.maxLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLimitValue, fieldNumber: 2)
    }
    if !self.progressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.progressList, fieldNumber: 3)
    }
    if !self.topUser.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topUser, fieldNumber: 4)
    }
    if self.userCount != 0 {
      try visitor.visitSingularInt32Field(value: self.userCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftRestartRes, rhs: OSWishGiftRestartRes) -> Bool {
    if lhs.finish != rhs.finish {return false}
    if lhs.maxLimitValue != rhs.maxLimitValue {return false}
    if lhs.progressList != rhs.progressList {return false}
    if lhs.topUser != rhs.topUser {return false}
    if lhs.userCount != rhs.userCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftDelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftDelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "giftId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftDelReq, rhs: OSWishGiftDelReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWishGiftDelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WishGiftDelRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWishGiftDelRes, rhs: OSWishGiftDelRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserPlayInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPlayInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserPlayInfoReq, rhs: OSUserPlayInfoReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserPlayInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPlayInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collectHallInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._collectHallInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._collectHallInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserPlayInfoRes, rhs: OSUserPlayInfoRes) -> Bool {
    if lhs._collectHallInfo != rhs._collectHallInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
