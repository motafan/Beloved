// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app_game_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 数据/事件类型
public enum STMessageId: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case msgNone // = 0

  /// 创建频道
  case createChannel // = 1

  /// 加入频道
  case joinChannel // = 2

  /// 退出频道
  case quitChannel // = 3

  /// 返回频道
  case backToChannel // = 4

  /// 踢人
  case gameKickUser // = 50

  /// 加入游戏 (自动准备)
  case gameJoin // = 51

  /// 退出游戏
  case gameQuit // = 52

  /// 准备游戏
  case gameReady // = 100

  /// 取消准备
  case gameCancelReady // = 101

  /// 开始游戏
  case gameStart // = 102

  /// 游戏结束
  case gameStop // = 103

  /// 强制关闭游戏
  case gameTerminated // = 104

  /// H5游戏端自定义请求数据转发
  case gameMessageH5 // = 105

  /// 游戏服务端推送的消息
  case gameMessagePush // = 106

  /// "一起看" 操作
  case cinemaOperation // = 120

  /// 数据刷新提醒
  case dataRefresh // = 121

  /// 收发礼物消息推送
  case messageGift // = 200

  /// 活动消息推送
  case messageActivity // = 201

  /// 签约消息推送
  case messageContract // = 202

  /// 支付消息推送
  case messagePayment // = 203

  /// 公屏信息推送
  case messageChannelChat // = 204

  /// "一起看" 操作实时推送
  case messageCinemaOperation // = 205

  /// 宝箱游戏
  case messageBoxGame // = 207

  /// 房间火箭消息
  case messageRocket // = 208
  case messageCommon // = 209

  /// 冒泡泡游戏
  case messageBubbleGame // = 210

  /// 全服横幅消息推送
  case messageAppBanner // = 211

  /// 快照快照定时推送:频道状态
  case messageChannelSnapshot // = 250

  /// 房间心愿礼物推送
  case messageWishGift // = 253

  /// 挚友信息推送
  case messageBosomFriend // = 255

  /// 消息列表通知推送
  case messageSysMsgNotifyList // = 256

  /// vip消息推送
  case messageVip // = 257

  /// 动作表情推送
  case messageExpression // = 258

  /// 房间操作事件
  case messageChannelOperate // = 301

  /// 数据刷新消息提醒
  case messageDataRefresh // = 302

  /// 开启心动值
  case messageOpenLoveNum // = 303

  /// 关闭心动值
  case messageCloseLoveNum // = 304

  /// 私信消息
  case chatMessage // = 305

  /// 用户模块
  case userModule // = 306

  /// 消息通知推送
  case messageSysMsgNotify // = 307

  /// 房间模块
  case channelModule // = 308

  /// 幻灵消息推送
  case messageEidolon // = 309
  case UNRECOGNIZED(Int)

  public init() {
    self = .msgNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .msgNone
    case 1: self = .createChannel
    case 2: self = .joinChannel
    case 3: self = .quitChannel
    case 4: self = .backToChannel
    case 50: self = .gameKickUser
    case 51: self = .gameJoin
    case 52: self = .gameQuit
    case 100: self = .gameReady
    case 101: self = .gameCancelReady
    case 102: self = .gameStart
    case 103: self = .gameStop
    case 104: self = .gameTerminated
    case 105: self = .gameMessageH5
    case 106: self = .gameMessagePush
    case 120: self = .cinemaOperation
    case 121: self = .dataRefresh
    case 200: self = .messageGift
    case 201: self = .messageActivity
    case 202: self = .messageContract
    case 203: self = .messagePayment
    case 204: self = .messageChannelChat
    case 205: self = .messageCinemaOperation
    case 207: self = .messageBoxGame
    case 208: self = .messageRocket
    case 209: self = .messageCommon
    case 210: self = .messageBubbleGame
    case 211: self = .messageAppBanner
    case 250: self = .messageChannelSnapshot
    case 253: self = .messageWishGift
    case 255: self = .messageBosomFriend
    case 256: self = .messageSysMsgNotifyList
    case 257: self = .messageVip
    case 258: self = .messageExpression
    case 301: self = .messageChannelOperate
    case 302: self = .messageDataRefresh
    case 303: self = .messageOpenLoveNum
    case 304: self = .messageCloseLoveNum
    case 305: self = .chatMessage
    case 306: self = .userModule
    case 307: self = .messageSysMsgNotify
    case 308: self = .channelModule
    case 309: self = .messageEidolon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .msgNone: return 0
    case .createChannel: return 1
    case .joinChannel: return 2
    case .quitChannel: return 3
    case .backToChannel: return 4
    case .gameKickUser: return 50
    case .gameJoin: return 51
    case .gameQuit: return 52
    case .gameReady: return 100
    case .gameCancelReady: return 101
    case .gameStart: return 102
    case .gameStop: return 103
    case .gameTerminated: return 104
    case .gameMessageH5: return 105
    case .gameMessagePush: return 106
    case .cinemaOperation: return 120
    case .dataRefresh: return 121
    case .messageGift: return 200
    case .messageActivity: return 201
    case .messageContract: return 202
    case .messagePayment: return 203
    case .messageChannelChat: return 204
    case .messageCinemaOperation: return 205
    case .messageBoxGame: return 207
    case .messageRocket: return 208
    case .messageCommon: return 209
    case .messageBubbleGame: return 210
    case .messageAppBanner: return 211
    case .messageChannelSnapshot: return 250
    case .messageWishGift: return 253
    case .messageBosomFriend: return 255
    case .messageSysMsgNotifyList: return 256
    case .messageVip: return 257
    case .messageExpression: return 258
    case .messageChannelOperate: return 301
    case .messageDataRefresh: return 302
    case .messageOpenLoveNum: return 303
    case .messageCloseLoveNum: return 304
    case .chatMessage: return 305
    case .userModule: return 306
    case .messageSysMsgNotify: return 307
    case .channelModule: return 308
    case .messageEidolon: return 309
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STMessageId] = [
    .msgNone,
    .createChannel,
    .joinChannel,
    .quitChannel,
    .backToChannel,
    .gameKickUser,
    .gameJoin,
    .gameQuit,
    .gameReady,
    .gameCancelReady,
    .gameStart,
    .gameStop,
    .gameTerminated,
    .gameMessageH5,
    .gameMessagePush,
    .cinemaOperation,
    .dataRefresh,
    .messageGift,
    .messageActivity,
    .messageContract,
    .messagePayment,
    .messageChannelChat,
    .messageCinemaOperation,
    .messageBoxGame,
    .messageRocket,
    .messageCommon,
    .messageBubbleGame,
    .messageAppBanner,
    .messageChannelSnapshot,
    .messageWishGift,
    .messageBosomFriend,
    .messageSysMsgNotifyList,
    .messageVip,
    .messageExpression,
    .messageChannelOperate,
    .messageDataRefresh,
    .messageOpenLoveNum,
    .messageCloseLoveNum,
    .chatMessage,
    .userModule,
    .messageSysMsgNotify,
    .channelModule,
    .messageEidolon,
  ]

}

/// 哪种游戏
public enum STGameId: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case gameNone // = 0

  /// 大话骰
  case daHuaShai // = 1

  /// 桌球
  case zhuoQiu // = 2

  /// 谁是卧底
  case shuiShiWoDi // = 3

  /// 五子棋
  case wuZiQi // = 4

  /// 大富翁
  case daFuWeng // = 5

  /// 斗地主
  case douDiZhu // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .gameNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gameNone
    case 1: self = .daHuaShai
    case 2: self = .zhuoQiu
    case 3: self = .shuiShiWoDi
    case 4: self = .wuZiQi
    case 5: self = .daFuWeng
    case 6: self = .douDiZhu
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .gameNone: return 0
    case .daHuaShai: return 1
    case .zhuoQiu: return 2
    case .shuiShiWoDi: return 3
    case .wuZiQi: return 4
    case .daFuWeng: return 5
    case .douDiZhu: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STGameId] = [
    .gameNone,
    .daHuaShai,
    .zhuoQiu,
    .shuiShiWoDi,
    .wuZiQi,
    .daFuWeng,
    .douDiZhu,
  ]

}

/// 渠道类型
public enum STChannelType2: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 娱乐
  case chat // = 0

  /// 开黑
  case game // = 1

  /// 互动小游戏
  case miniGame // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .chat
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .chat
    case 1: self = .game
    case 2: self = .miniGame
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .chat: return 0
    case .game: return 1
    case .miniGame: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STChannelType2] = [
    .chat,
    .game,
    .miniGame,
  ]

}

public enum STActivityType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 通用消息推送(如横幅等)
  case common // = 0

  /// 宝箱消息推送
  case box // = 1

  /// 萌兔宝藏
  case rabbit // = 2

  /// 全服霸屏svga动效
  case screenEffect // = 5

  /// 全屏动效
  case animation // = 6

  /// 活动模块
  case h5 // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .common
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .common
    case 1: self = .box
    case 2: self = .rabbit
    case 5: self = .screenEffect
    case 6: self = .animation
    case 7: self = .h5
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .common: return 0
    case .box: return 1
    case .rabbit: return 2
    case .screenEffect: return 5
    case .animation: return 6
    case .h5: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STActivityType] = [
    .common,
    .box,
    .rabbit,
    .screenEffect,
    .animation,
    .h5,
  ]

}

public enum STContractType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 未读提醒
  case unreadNotify // = 0
  case UNRECOGNIZED(Int)

  public init() {
    self = .unreadNotify
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unreadNotify
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unreadNotify: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STContractType] = [
    .unreadNotify,
  ]

}

public enum STPaymentType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 普通订单结果详情
  case orderInfo // = 0

  /// 首充订单详情
  case firstOrderInfo // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .orderInfo
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .orderInfo
    case 1: self = .firstOrderInfo
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .orderInfo: return 0
    case .firstOrderInfo: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STPaymentType] = [
    .orderInfo,
    .firstOrderInfo,
  ]

}

/// 房间管理角色权限
public enum STUserRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///黑名单内
  case inBlackList // = 0

  /// 普通用户
  case normal // = 1

  /// 房间管理员
  case admin // = 2

  /// 超级房间管理员
  case superAdmin // = 3

  /// 房主
  case owner // = 4

  /// 族长
  case familyOwner // = 5

  /// 副族长
  case familyDeputyOwner // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .inBlackList
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inBlackList
    case 1: self = .normal
    case 2: self = .admin
    case 3: self = .superAdmin
    case 4: self = .owner
    case 5: self = .familyOwner
    case 6: self = .familyDeputyOwner
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .inBlackList: return 0
    case .normal: return 1
    case .admin: return 2
    case .superAdmin: return 3
    case .owner: return 4
    case .familyOwner: return 5
    case .familyDeputyOwner: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STUserRole] = [
    .inBlackList,
    .normal,
    .admin,
    .superAdmin,
    .owner,
    .familyOwner,
    .familyDeputyOwner,
  ]

}

/// 房间外部管理角色权限
public enum STExternUserRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 非管理角色
  case notExternalAdmin // = 0

  /// 签约厅家族长
  case contractFamilyOwner // = 1

  /// 普通家族长
  case normalFamilyOwner // = 2

  /// 签约厅家副族长
  case contractFamilyDeputyOwner // = 3

  /// 普通家副族长
  case normalFamilyDeputyOwner // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .notExternalAdmin
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notExternalAdmin
    case 1: self = .contractFamilyOwner
    case 2: self = .normalFamilyOwner
    case 3: self = .contractFamilyDeputyOwner
    case 4: self = .normalFamilyDeputyOwner
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notExternalAdmin: return 0
    case .contractFamilyOwner: return 1
    case .normalFamilyOwner: return 2
    case .contractFamilyDeputyOwner: return 3
    case .normalFamilyDeputyOwner: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STExternUserRole] = [
    .notExternalAdmin,
    .contractFamilyOwner,
    .normalFamilyOwner,
    .contractFamilyDeputyOwner,
    .normalFamilyDeputyOwner,
  ]

}

/// 播放状态
public enum STMediaPlayerState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 停止
  case stop // = 0

  /// 播放
  case play // = 1

  /// 暂停
  case pause // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .stop
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stop
    case 1: self = .play
    case 2: self = .pause
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .stop: return 0
    case .play: return 1
    case .pause: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STMediaPlayerState] = [
    .stop,
    .play,
    .pause,
  ]

}

/// 播放操作
public enum STMediaPlayerOperation: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case operationPlay // = 0
  case operationPause // = 1
  case operationStop // = 2
  case operationSeek // = 3

  /// 请求同步云端快照
  case operationSync // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .operationPlay
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .operationPlay
    case 1: self = .operationPause
    case 2: self = .operationStop
    case 3: self = .operationSeek
    case 4: self = .operationSync
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .operationPlay: return 0
    case .operationPause: return 1
    case .operationStop: return 2
    case .operationSeek: return 3
    case .operationSync: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STMediaPlayerOperation] = [
    .operationPlay,
    .operationPause,
    .operationStop,
    .operationSeek,
    .operationSync,
  ]

}

public enum STCinemaErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case errorNone // = 0

  /// 无效的操作请求
  case errorOperationInvalid // = 1

  /// 没有操作权限
  case errorNoPermission // = 2

  /// 房间人数不足2人
  case errorUserNotEnough // = 3

  /// 视频已失效
  case errorVideoInvalid // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .errorNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .errorNone
    case 1: self = .errorOperationInvalid
    case 2: self = .errorNoPermission
    case 3: self = .errorUserNotEnough
    case 4: self = .errorVideoInvalid
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .errorNone: return 0
    case .errorOperationInvalid: return 1
    case .errorNoPermission: return 2
    case .errorUserNotEnough: return 3
    case .errorVideoInvalid: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STCinemaErrorCode] = [
    .errorNone,
    .errorOperationInvalid,
    .errorNoPermission,
    .errorUserNotEnough,
    .errorVideoInvalid,
  ]

}

public enum STGiftSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case giftNone // = 0

  /// 普通礼物
  case giftCommon // = 1

  /// 福袋/盲盒
  case giftLucky // = 2

  /// 抽奖获得礼物
  case giftLottery // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .giftNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .giftNone
    case 1: self = .giftCommon
    case 2: self = .giftLucky
    case 3: self = .giftLottery
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .giftNone: return 0
    case .giftCommon: return 1
    case .giftLucky: return 2
    case .giftLottery: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STGiftSource] = [
    .giftNone,
    .giftCommon,
    .giftLucky,
    .giftLottery,
  ]

}

/// 业务类型
public enum STBusinessType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 首充提醒
  case remindFirstRecharge // = 0

  /// 任务系统数据刷新
  case refreshMission // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .remindFirstRecharge
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .remindFirstRecharge
    case 1: self = .refreshMission
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .remindFirstRecharge: return 0
    case .refreshMission: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STBusinessType] = [
    .remindFirstRecharge,
    .refreshMission,
  ]

}

public enum STAppFlag: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  ///音诱语音
  case yinyou // = 0

  ///yomi语音
  case yomi // = 1

  ///元气语音
  case yuanqi // = 2

  ///Kis派对
  case kis // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .yinyou
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .yinyou
    case 1: self = .yomi
    case 2: self = .yuanqi
    case 3: self = .kis
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .yinyou: return 0
    case .yomi: return 1
    case .yuanqi: return 2
    case .kis: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STAppFlag] = [
    .yinyou,
    .yomi,
    .yuanqi,
    .kis,
  ]

}

public struct STAnyMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 请求实体
public struct STRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 数据/事件类型
  public var id: STMessageId {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// 版本号, 默认1
  public var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// 当次请求id
  public var context: Int32 {
    get {return _storage._context}
    set {_uniqueStorage()._context = newValue}
  }

  /// 用户id
  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// 消息当前时间戳(毫秒)
  public var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  /// 签名
  public var sign: String {
    get {return _storage._sign}
    set {_uniqueStorage()._sign = newValue}
  }

  /// 发给游戏服务器
  public var extra: Data {
    get {return _storage._extra}
    set {_uniqueStorage()._extra = newValue}
  }

  /// 请求端口
  public var appFlag: STAppFlag {
    get {return _storage._appFlag}
    set {_uniqueStorage()._appFlag = newValue}
  }

  ///后续新增功能全部分离出来
  public var request: OneOf_Request? {
    get {return _storage._request}
    set {_uniqueStorage()._request = newValue}
  }

  public var message: STMessageRequest {
    get {
      if case .message(let v)? = _storage._request {return v}
      return STMessageRequest()
    }
    set {_uniqueStorage()._request = .message(newValue)}
  }

  public var user: STUserRequest {
    get {
      if case .user(let v)? = _storage._request {return v}
      return STUserRequest()
    }
    set {_uniqueStorage()._request = .user(newValue)}
  }

  public var createChannelReq: STCreateChannelReq {
    get {return _storage._createChannelReq ?? STCreateChannelReq()}
    set {_uniqueStorage()._createChannelReq = newValue}
  }
  /// Returns true if `createChannelReq` has been explicitly set.
  public var hasCreateChannelReq: Bool {return _storage._createChannelReq != nil}
  /// Clears the value of `createChannelReq`. Subsequent reads from it will return its default value.
  public mutating func clearCreateChannelReq() {_uniqueStorage()._createChannelReq = nil}

  public var joinChannelReq: STJoinChannelReq {
    get {return _storage._joinChannelReq ?? STJoinChannelReq()}
    set {_uniqueStorage()._joinChannelReq = newValue}
  }
  /// Returns true if `joinChannelReq` has been explicitly set.
  public var hasJoinChannelReq: Bool {return _storage._joinChannelReq != nil}
  /// Clears the value of `joinChannelReq`. Subsequent reads from it will return its default value.
  public mutating func clearJoinChannelReq() {_uniqueStorage()._joinChannelReq = nil}

  public var kickUserReq: STKickUserReq {
    get {return _storage._kickUserReq ?? STKickUserReq()}
    set {_uniqueStorage()._kickUserReq = newValue}
  }
  /// Returns true if `kickUserReq` has been explicitly set.
  public var hasKickUserReq: Bool {return _storage._kickUserReq != nil}
  /// Clears the value of `kickUserReq`. Subsequent reads from it will return its default value.
  public mutating func clearKickUserReq() {_uniqueStorage()._kickUserReq = nil}

  public var quitChanelReq: STQuitChannelReq {
    get {return _storage._quitChanelReq ?? STQuitChannelReq()}
    set {_uniqueStorage()._quitChanelReq = newValue}
  }
  /// Returns true if `quitChanelReq` has been explicitly set.
  public var hasQuitChanelReq: Bool {return _storage._quitChanelReq != nil}
  /// Clears the value of `quitChanelReq`. Subsequent reads from it will return its default value.
  public mutating func clearQuitChanelReq() {_uniqueStorage()._quitChanelReq = nil}

  public var modifyChannelReq: STModifyChannelReq {
    get {return _storage._modifyChannelReq ?? STModifyChannelReq()}
    set {_uniqueStorage()._modifyChannelReq = newValue}
  }
  /// Returns true if `modifyChannelReq` has been explicitly set.
  public var hasModifyChannelReq: Bool {return _storage._modifyChannelReq != nil}
  /// Clears the value of `modifyChannelReq`. Subsequent reads from it will return its default value.
  public mutating func clearModifyChannelReq() {_uniqueStorage()._modifyChannelReq = nil}

  public var backToChannelReq: STBackToChannelReq {
    get {return _storage._backToChannelReq ?? STBackToChannelReq()}
    set {_uniqueStorage()._backToChannelReq = newValue}
  }
  /// Returns true if `backToChannelReq` has been explicitly set.
  public var hasBackToChannelReq: Bool {return _storage._backToChannelReq != nil}
  /// Clears the value of `backToChannelReq`. Subsequent reads from it will return its default value.
  public mutating func clearBackToChannelReq() {_uniqueStorage()._backToChannelReq = nil}

  public var cinemaOperationReq: STCinemaOperationReq {
    get {return _storage._cinemaOperationReq ?? STCinemaOperationReq()}
    set {_uniqueStorage()._cinemaOperationReq = newValue}
  }
  /// Returns true if `cinemaOperationReq` has been explicitly set.
  public var hasCinemaOperationReq: Bool {return _storage._cinemaOperationReq != nil}
  /// Clears the value of `cinemaOperationReq`. Subsequent reads from it will return its default value.
  public mutating func clearCinemaOperationReq() {_uniqueStorage()._cinemaOperationReq = nil}

  public var gameReadyReq: STAnyMessage {
    get {return _storage._gameReadyReq ?? STAnyMessage()}
    set {_uniqueStorage()._gameReadyReq = newValue}
  }
  /// Returns true if `gameReadyReq` has been explicitly set.
  public var hasGameReadyReq: Bool {return _storage._gameReadyReq != nil}
  /// Clears the value of `gameReadyReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameReadyReq() {_uniqueStorage()._gameReadyReq = nil}

  public var gameCancelReadyReq: STAnyMessage {
    get {return _storage._gameCancelReadyReq ?? STAnyMessage()}
    set {_uniqueStorage()._gameCancelReadyReq = newValue}
  }
  /// Returns true if `gameCancelReadyReq` has been explicitly set.
  public var hasGameCancelReadyReq: Bool {return _storage._gameCancelReadyReq != nil}
  /// Clears the value of `gameCancelReadyReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameCancelReadyReq() {_uniqueStorage()._gameCancelReadyReq = nil}

  public var gameJoinReq: STGameJoinReq {
    get {return _storage._gameJoinReq ?? STGameJoinReq()}
    set {_uniqueStorage()._gameJoinReq = newValue}
  }
  /// Returns true if `gameJoinReq` has been explicitly set.
  public var hasGameJoinReq: Bool {return _storage._gameJoinReq != nil}
  /// Clears the value of `gameJoinReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameJoinReq() {_uniqueStorage()._gameJoinReq = nil}

  public var gameQuitReq: STAnyMessage {
    get {return _storage._gameQuitReq ?? STAnyMessage()}
    set {_uniqueStorage()._gameQuitReq = newValue}
  }
  /// Returns true if `gameQuitReq` has been explicitly set.
  public var hasGameQuitReq: Bool {return _storage._gameQuitReq != nil}
  /// Clears the value of `gameQuitReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameQuitReq() {_uniqueStorage()._gameQuitReq = nil}

  public var gameStartReq: STAnyMessage {
    get {return _storage._gameStartReq ?? STAnyMessage()}
    set {_uniqueStorage()._gameStartReq = newValue}
  }
  /// Returns true if `gameStartReq` has been explicitly set.
  public var hasGameStartReq: Bool {return _storage._gameStartReq != nil}
  /// Clears the value of `gameStartReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameStartReq() {_uniqueStorage()._gameStartReq = nil}

  public var gameStopReq: STAnyMessage {
    get {return _storage._gameStopReq ?? STAnyMessage()}
    set {_uniqueStorage()._gameStopReq = newValue}
  }
  /// Returns true if `gameStopReq` has been explicitly set.
  public var hasGameStopReq: Bool {return _storage._gameStopReq != nil}
  /// Clears the value of `gameStopReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameStopReq() {_uniqueStorage()._gameStopReq = nil}

  public var gameTerminatedReq: STAnyMessage {
    get {return _storage._gameTerminatedReq ?? STAnyMessage()}
    set {_uniqueStorage()._gameTerminatedReq = newValue}
  }
  /// Returns true if `gameTerminatedReq` has been explicitly set.
  public var hasGameTerminatedReq: Bool {return _storage._gameTerminatedReq != nil}
  /// Clears the value of `gameTerminatedReq`. Subsequent reads from it will return its default value.
  public mutating func clearGameTerminatedReq() {_uniqueStorage()._gameTerminatedReq = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  ///后续新增功能全部分离出来
  public enum OneOf_Request: Equatable, Sendable {
    case message(STMessageRequest)
    case user(STUserRequest)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 响应实体
public struct STResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: STMessageId {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// 协议版本号, 默认1
  public var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// 当次响应对应的请求id
  public var context: Int32 {
    get {return _storage._context}
    set {_uniqueStorage()._context = newValue}
  }

  /// 状态码, 0成功，非0失败
  public var code: Int32 {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  /// 消息当前时间戳(毫秒)
  public var time: Int64 {
    get {return _storage._time}
    set {_uniqueStorage()._time = newValue}
  }

  /// 消息提示
  public var msg: String {
    get {return _storage._msg}
    set {_uniqueStorage()._msg = newValue}
  }

  /// 返回H5游戏端数据转发, 或json
  public var extra: Data {
    get {return _storage._extra}
    set {_uniqueStorage()._extra = newValue}
  }

  /// 请求端口
  public var appFlag: STAppFlag {
    get {return _storage._appFlag}
    set {_uniqueStorage()._appFlag = newValue}
  }

  public var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  public var message: STMessageResponse {
    get {
      if case .message(let v)? = _storage._response {return v}
      return STMessageResponse()
    }
    set {_uniqueStorage()._response = .message(newValue)}
  }

  public var user: STUserResponse {
    get {
      if case .user(let v)? = _storage._response {return v}
      return STUserResponse()
    }
    set {_uniqueStorage()._response = .user(newValue)}
  }

  public var channel: STChannelResponse {
    get {
      if case .channel(let v)? = _storage._response {return v}
      return STChannelResponse()
    }
    set {_uniqueStorage()._response = .channel(newValue)}
  }

  public var createChannelRes: STCreateChannelRes {
    get {return _storage._createChannelRes ?? STCreateChannelRes()}
    set {_uniqueStorage()._createChannelRes = newValue}
  }
  /// Returns true if `createChannelRes` has been explicitly set.
  public var hasCreateChannelRes: Bool {return _storage._createChannelRes != nil}
  /// Clears the value of `createChannelRes`. Subsequent reads from it will return its default value.
  public mutating func clearCreateChannelRes() {_uniqueStorage()._createChannelRes = nil}

  public var joinChannelRes: STJoinChannelRes {
    get {return _storage._joinChannelRes ?? STJoinChannelRes()}
    set {_uniqueStorage()._joinChannelRes = newValue}
  }
  /// Returns true if `joinChannelRes` has been explicitly set.
  public var hasJoinChannelRes: Bool {return _storage._joinChannelRes != nil}
  /// Clears the value of `joinChannelRes`. Subsequent reads from it will return its default value.
  public mutating func clearJoinChannelRes() {_uniqueStorage()._joinChannelRes = nil}

  public var kickUserRes: STKickUserRes {
    get {return _storage._kickUserRes ?? STKickUserRes()}
    set {_uniqueStorage()._kickUserRes = newValue}
  }
  /// Returns true if `kickUserRes` has been explicitly set.
  public var hasKickUserRes: Bool {return _storage._kickUserRes != nil}
  /// Clears the value of `kickUserRes`. Subsequent reads from it will return its default value.
  public mutating func clearKickUserRes() {_uniqueStorage()._kickUserRes = nil}

  public var quitChannelRes: STQuitChannelRes {
    get {return _storage._quitChannelRes ?? STQuitChannelRes()}
    set {_uniqueStorage()._quitChannelRes = newValue}
  }
  /// Returns true if `quitChannelRes` has been explicitly set.
  public var hasQuitChannelRes: Bool {return _storage._quitChannelRes != nil}
  /// Clears the value of `quitChannelRes`. Subsequent reads from it will return its default value.
  public mutating func clearQuitChannelRes() {_uniqueStorage()._quitChannelRes = nil}

  public var modifyChannelRes: STModifyChannelRes {
    get {return _storage._modifyChannelRes ?? STModifyChannelRes()}
    set {_uniqueStorage()._modifyChannelRes = newValue}
  }
  /// Returns true if `modifyChannelRes` has been explicitly set.
  public var hasModifyChannelRes: Bool {return _storage._modifyChannelRes != nil}
  /// Clears the value of `modifyChannelRes`. Subsequent reads from it will return its default value.
  public mutating func clearModifyChannelRes() {_uniqueStorage()._modifyChannelRes = nil}

  public var backToChannelRes: STBackToChannelRes {
    get {return _storage._backToChannelRes ?? STBackToChannelRes()}
    set {_uniqueStorage()._backToChannelRes = newValue}
  }
  /// Returns true if `backToChannelRes` has been explicitly set.
  public var hasBackToChannelRes: Bool {return _storage._backToChannelRes != nil}
  /// Clears the value of `backToChannelRes`. Subsequent reads from it will return its default value.
  public mutating func clearBackToChannelRes() {_uniqueStorage()._backToChannelRes = nil}

  public var cinemaOperationRes: STCinemaOperationRes {
    get {return _storage._cinemaOperationRes ?? STCinemaOperationRes()}
    set {_uniqueStorage()._cinemaOperationRes = newValue}
  }
  /// Returns true if `cinemaOperationRes` has been explicitly set.
  public var hasCinemaOperationRes: Bool {return _storage._cinemaOperationRes != nil}
  /// Clears the value of `cinemaOperationRes`. Subsequent reads from it will return its default value.
  public mutating func clearCinemaOperationRes() {_uniqueStorage()._cinemaOperationRes = nil}

  public var gameReadyRes: STAnyMessage {
    get {return _storage._gameReadyRes ?? STAnyMessage()}
    set {_uniqueStorage()._gameReadyRes = newValue}
  }
  /// Returns true if `gameReadyRes` has been explicitly set.
  public var hasGameReadyRes: Bool {return _storage._gameReadyRes != nil}
  /// Clears the value of `gameReadyRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameReadyRes() {_uniqueStorage()._gameReadyRes = nil}

  public var gameCancelReadyRes: STAnyMessage {
    get {return _storage._gameCancelReadyRes ?? STAnyMessage()}
    set {_uniqueStorage()._gameCancelReadyRes = newValue}
  }
  /// Returns true if `gameCancelReadyRes` has been explicitly set.
  public var hasGameCancelReadyRes: Bool {return _storage._gameCancelReadyRes != nil}
  /// Clears the value of `gameCancelReadyRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameCancelReadyRes() {_uniqueStorage()._gameCancelReadyRes = nil}

  public var gameJoinRes: STAnyMessage {
    get {return _storage._gameJoinRes ?? STAnyMessage()}
    set {_uniqueStorage()._gameJoinRes = newValue}
  }
  /// Returns true if `gameJoinRes` has been explicitly set.
  public var hasGameJoinRes: Bool {return _storage._gameJoinRes != nil}
  /// Clears the value of `gameJoinRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameJoinRes() {_uniqueStorage()._gameJoinRes = nil}

  public var gameQuitRes: STAnyMessage {
    get {return _storage._gameQuitRes ?? STAnyMessage()}
    set {_uniqueStorage()._gameQuitRes = newValue}
  }
  /// Returns true if `gameQuitRes` has been explicitly set.
  public var hasGameQuitRes: Bool {return _storage._gameQuitRes != nil}
  /// Clears the value of `gameQuitRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameQuitRes() {_uniqueStorage()._gameQuitRes = nil}

  public var gameStartRes: STAnyMessage {
    get {return _storage._gameStartRes ?? STAnyMessage()}
    set {_uniqueStorage()._gameStartRes = newValue}
  }
  /// Returns true if `gameStartRes` has been explicitly set.
  public var hasGameStartRes: Bool {return _storage._gameStartRes != nil}
  /// Clears the value of `gameStartRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameStartRes() {_uniqueStorage()._gameStartRes = nil}

  public var gameStopRes: STAnyMessage {
    get {return _storage._gameStopRes ?? STAnyMessage()}
    set {_uniqueStorage()._gameStopRes = newValue}
  }
  /// Returns true if `gameStopRes` has been explicitly set.
  public var hasGameStopRes: Bool {return _storage._gameStopRes != nil}
  /// Clears the value of `gameStopRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameStopRes() {_uniqueStorage()._gameStopRes = nil}

  public var gameTerminatedRes: STGameTerminatedRes {
    get {return _storage._gameTerminatedRes ?? STGameTerminatedRes()}
    set {_uniqueStorage()._gameTerminatedRes = newValue}
  }
  /// Returns true if `gameTerminatedRes` has been explicitly set.
  public var hasGameTerminatedRes: Bool {return _storage._gameTerminatedRes != nil}
  /// Clears the value of `gameTerminatedRes`. Subsequent reads from it will return its default value.
  public mutating func clearGameTerminatedRes() {_uniqueStorage()._gameTerminatedRes = nil}

  /// channel snapshot
  public var channelSnapshot: STChannelSnapshot {
    get {return _storage._channelSnapshot ?? STChannelSnapshot()}
    set {_uniqueStorage()._channelSnapshot = newValue}
  }
  /// Returns true if `channelSnapshot` has been explicitly set.
  public var hasChannelSnapshot: Bool {return _storage._channelSnapshot != nil}
  /// Clears the value of `channelSnapshot`. Subsequent reads from it will return its default value.
  public mutating func clearChannelSnapshot() {_uniqueStorage()._channelSnapshot = nil}

  /// 以下是通知
  public var giftNotification: STGiftNotification {
    get {return _storage._giftNotification ?? STGiftNotification()}
    set {_uniqueStorage()._giftNotification = newValue}
  }
  /// Returns true if `giftNotification` has been explicitly set.
  public var hasGiftNotification: Bool {return _storage._giftNotification != nil}
  /// Clears the value of `giftNotification`. Subsequent reads from it will return its default value.
  public mutating func clearGiftNotification() {_uniqueStorage()._giftNotification = nil}

  public var activityNotification: STActivityNotification {
    get {return _storage._activityNotification ?? STActivityNotification()}
    set {_uniqueStorage()._activityNotification = newValue}
  }
  /// Returns true if `activityNotification` has been explicitly set.
  public var hasActivityNotification: Bool {return _storage._activityNotification != nil}
  /// Clears the value of `activityNotification`. Subsequent reads from it will return its default value.
  public mutating func clearActivityNotification() {_uniqueStorage()._activityNotification = nil}

  public var contractNotification: STContractNotification {
    get {return _storage._contractNotification ?? STContractNotification()}
    set {_uniqueStorage()._contractNotification = newValue}
  }
  /// Returns true if `contractNotification` has been explicitly set.
  public var hasContractNotification: Bool {return _storage._contractNotification != nil}
  /// Clears the value of `contractNotification`. Subsequent reads from it will return its default value.
  public mutating func clearContractNotification() {_uniqueStorage()._contractNotification = nil}

  public var paymentNotification: STPaymentNotification {
    get {return _storage._paymentNotification ?? STPaymentNotification()}
    set {_uniqueStorage()._paymentNotification = newValue}
  }
  /// Returns true if `paymentNotification` has been explicitly set.
  public var hasPaymentNotification: Bool {return _storage._paymentNotification != nil}
  /// Clears the value of `paymentNotification`. Subsequent reads from it will return its default value.
  public mutating func clearPaymentNotification() {_uniqueStorage()._paymentNotification = nil}

  public var chatMessageNotification: STChannelChatNotification {
    get {return _storage._chatMessageNotification ?? STChannelChatNotification()}
    set {_uniqueStorage()._chatMessageNotification = newValue}
  }
  /// Returns true if `chatMessageNotification` has been explicitly set.
  public var hasChatMessageNotification: Bool {return _storage._chatMessageNotification != nil}
  /// Clears the value of `chatMessageNotification`. Subsequent reads from it will return its default value.
  public mutating func clearChatMessageNotification() {_uniqueStorage()._chatMessageNotification = nil}

  public var cinemaOperationNotification: STCinemaOperationNotification {
    get {return _storage._cinemaOperationNotification ?? STCinemaOperationNotification()}
    set {_uniqueStorage()._cinemaOperationNotification = newValue}
  }
  /// Returns true if `cinemaOperationNotification` has been explicitly set.
  public var hasCinemaOperationNotification: Bool {return _storage._cinemaOperationNotification != nil}
  /// Clears the value of `cinemaOperationNotification`. Subsequent reads from it will return its default value.
  public mutating func clearCinemaOperationNotification() {_uniqueStorage()._cinemaOperationNotification = nil}

  public var dataRefreshNotification: STDataRefreshNotification {
    get {return _storage._dataRefreshNotification ?? STDataRefreshNotification()}
    set {_uniqueStorage()._dataRefreshNotification = newValue}
  }
  /// Returns true if `dataRefreshNotification` has been explicitly set.
  public var hasDataRefreshNotification: Bool {return _storage._dataRefreshNotification != nil}
  /// Clears the value of `dataRefreshNotification`. Subsequent reads from it will return its default value.
  public mutating func clearDataRefreshNotification() {_uniqueStorage()._dataRefreshNotification = nil}

  public var boxGameNotification: STBoxGameNotification {
    get {return _storage._boxGameNotification ?? STBoxGameNotification()}
    set {_uniqueStorage()._boxGameNotification = newValue}
  }
  /// Returns true if `boxGameNotification` has been explicitly set.
  public var hasBoxGameNotification: Bool {return _storage._boxGameNotification != nil}
  /// Clears the value of `boxGameNotification`. Subsequent reads from it will return its default value.
  public mutating func clearBoxGameNotification() {_uniqueStorage()._boxGameNotification = nil}

  public var rocketNotification: STRocketNotification {
    get {return _storage._rocketNotification ?? STRocketNotification()}
    set {_uniqueStorage()._rocketNotification = newValue}
  }
  /// Returns true if `rocketNotification` has been explicitly set.
  public var hasRocketNotification: Bool {return _storage._rocketNotification != nil}
  /// Clears the value of `rocketNotification`. Subsequent reads from it will return its default value.
  public mutating func clearRocketNotification() {_uniqueStorage()._rocketNotification = nil}

  public var commonNotification: STCommonNotification {
    get {return _storage._commonNotification ?? STCommonNotification()}
    set {_uniqueStorage()._commonNotification = newValue}
  }
  /// Returns true if `commonNotification` has been explicitly set.
  public var hasCommonNotification: Bool {return _storage._commonNotification != nil}
  /// Clears the value of `commonNotification`. Subsequent reads from it will return its default value.
  public mutating func clearCommonNotification() {_uniqueStorage()._commonNotification = nil}

  public var lotteryNotification: STLotteryNotification {
    get {return _storage._lotteryNotification ?? STLotteryNotification()}
    set {_uniqueStorage()._lotteryNotification = newValue}
  }
  /// Returns true if `lotteryNotification` has been explicitly set.
  public var hasLotteryNotification: Bool {return _storage._lotteryNotification != nil}
  /// Clears the value of `lotteryNotification`. Subsequent reads from it will return its default value.
  public mutating func clearLotteryNotification() {_uniqueStorage()._lotteryNotification = nil}

  public var appBannerNotification: STAppBannerNotification {
    get {return _storage._appBannerNotification ?? STAppBannerNotification()}
    set {_uniqueStorage()._appBannerNotification = newValue}
  }
  /// Returns true if `appBannerNotification` has been explicitly set.
  public var hasAppBannerNotification: Bool {return _storage._appBannerNotification != nil}
  /// Clears the value of `appBannerNotification`. Subsequent reads from it will return its default value.
  public mutating func clearAppBannerNotification() {_uniqueStorage()._appBannerNotification = nil}

  public var wishGiftNotification: STWishGiftNotification {
    get {return _storage._wishGiftNotification ?? STWishGiftNotification()}
    set {_uniqueStorage()._wishGiftNotification = newValue}
  }
  /// Returns true if `wishGiftNotification` has been explicitly set.
  public var hasWishGiftNotification: Bool {return _storage._wishGiftNotification != nil}
  /// Clears the value of `wishGiftNotification`. Subsequent reads from it will return its default value.
  public mutating func clearWishGiftNotification() {_uniqueStorage()._wishGiftNotification = nil}

  public var sysMsgNotification: STSysMsgNotification {
    get {return _storage._sysMsgNotification ?? STSysMsgNotification()}
    set {_uniqueStorage()._sysMsgNotification = newValue}
  }
  /// Returns true if `sysMsgNotification` has been explicitly set.
  public var hasSysMsgNotification: Bool {return _storage._sysMsgNotification != nil}
  /// Clears the value of `sysMsgNotification`. Subsequent reads from it will return its default value.
  public mutating func clearSysMsgNotification() {_uniqueStorage()._sysMsgNotification = nil}

  public var bosomFriendDto: STBosomFriendDto {
    get {return _storage._bosomFriendDto ?? STBosomFriendDto()}
    set {_uniqueStorage()._bosomFriendDto = newValue}
  }
  /// Returns true if `bosomFriendDto` has been explicitly set.
  public var hasBosomFriendDto: Bool {return _storage._bosomFriendDto != nil}
  /// Clears the value of `bosomFriendDto`. Subsequent reads from it will return its default value.
  public mutating func clearBosomFriendDto() {_uniqueStorage()._bosomFriendDto = nil}

  public var sysMsgNotifications: STSysMsgNotifications {
    get {return _storage._sysMsgNotifications ?? STSysMsgNotifications()}
    set {_uniqueStorage()._sysMsgNotifications = newValue}
  }
  /// Returns true if `sysMsgNotifications` has been explicitly set.
  public var hasSysMsgNotifications: Bool {return _storage._sysMsgNotifications != nil}
  /// Clears the value of `sysMsgNotifications`. Subsequent reads from it will return its default value.
  public mutating func clearSysMsgNotifications() {_uniqueStorage()._sysMsgNotifications = nil}

  public var vipNotification: STVipNotification {
    get {return _storage._vipNotification ?? STVipNotification()}
    set {_uniqueStorage()._vipNotification = newValue}
  }
  /// Returns true if `vipNotification` has been explicitly set.
  public var hasVipNotification: Bool {return _storage._vipNotification != nil}
  /// Clears the value of `vipNotification`. Subsequent reads from it will return its default value.
  public mutating func clearVipNotification() {_uniqueStorage()._vipNotification = nil}

  ///幻灵数据通知
  public var eidolonNotification: STEidolonNotification {
    get {return _storage._eidolonNotification ?? STEidolonNotification()}
    set {_uniqueStorage()._eidolonNotification = newValue}
  }
  /// Returns true if `eidolonNotification` has been explicitly set.
  public var hasEidolonNotification: Bool {return _storage._eidolonNotification != nil}
  /// Clears the value of `eidolonNotification`. Subsequent reads from it will return its default value.
  public mutating func clearEidolonNotification() {_uniqueStorage()._eidolonNotification = nil}

  ///动作表情通知
  public var expressionNotification: STExpressionNotification {
    get {return _storage._expressionNotification ?? STExpressionNotification()}
    set {_uniqueStorage()._expressionNotification = newValue}
  }
  /// Returns true if `expressionNotification` has been explicitly set.
  public var hasExpressionNotification: Bool {return _storage._expressionNotification != nil}
  /// Clears the value of `expressionNotification`. Subsequent reads from it will return its default value.
  public mutating func clearExpressionNotification() {_uniqueStorage()._expressionNotification = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case message(STMessageResponse)
    case user(STUserResponse)
    case channel(STChannelResponse)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///创建房间请求参数
public struct STCreateChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelName: String = String()

  public var channelType: STChannelType2 = .chat

  public var gameID: Int32 = 0

  public var daquID: Int32 = 0

  public var duanID: Int32 = 0

  public var gameModelID: Int32 = 0

  public var yuleID: Int32 = 0

  public var timestamp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///加入房间请求参数
public struct STJoinChannelReq: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var password: String = String()

  public var channelType: STChannelType2 = .chat

  ///H5游戏端自定义数据
  public var body: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STQuitChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STModifyChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var operateType: Int32 = 0

  public var channelName: String = String()

  public var channelPwd: String = String()

  public var welcomingSpeech: String = String()

  public var channelType: STChannelType2 = .chat

  public var gameID: Int32 = 0

  public var coverURL: String = String()

  public var daquID: Int32 = 0

  public var duanID: Int32 = 0

  public var gameModelID: Int32 = 0

  public var yuleID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///踢人请求参数
public struct STKickUserReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 被踢用户id
  public var targetUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STBackToChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STGameJoinReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 玩家游戏位置
  public var playerPosition: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STCinemaOperationReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作编号id, CinemaSnapshot快照的id为最后一次执行成功的操作id(含Play/Stop/Pause/Seek)
  public var id: Int64 = 0

  public var operation: STMediaPlayerOperation = .operationPlay

  /// 房间id
  public var channelID: String = String()

  public var videoID: Int64 = 0

  /// 当前播放的时间点(milliSecond)
  public var position: Int64 = 0

  /// 倍速, 1(0.5X), 2(0.75X), 3(1.0X), 4(1.2X), 4(1.5X), 5(2X)...
  public var speed: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///------Begin 具体业务的返回数据模型-------
public struct STUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 勋章信息
public struct STMedalInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 勋章id
  public var medalID: Int32 = 0

  /// 勋章等级
  public var medalLevelID: Int32 = 0

  /// 称号等级数值
  public var medalLevelNum: Int32 = 0

  /// 当前用户勋章累计数值
  public var empiricalValue: Int32 = 0

  /// 展示状态（0.不展示 1.展示）
  public var showState: Int32 = 0

  /// 勋章名称
  public var medalName: String = String()

  /// 称号名称
  public var medalLevelTitle: String = String()

  /// 称号icon
  public var medalLevelIcon: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 萌兔宝藏记录(banner/公屏)
public struct STRabbitRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 获得类型(0宝箱抽奖;1宝箱稀有礼物;2宝箱兑换礼物)
  public var type: Int32 = 0

  public var userID: String = String()

  public var nickname: String = String()

  public var prizeID: Int32 = 0

  public var prizeName: String = String()

  public var prizeValue: Int32 = 0

  public var prizeCount: Int32 = 0

  public var bubbleURL: String = String()

  public var prizeIconURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 口令动画信息
public struct STPhraseInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var effectURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STUserInChannel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var accountID: Int32 = 0

  public var role: STUserRole = .inBlackList

  public var externRole: STExternUserRole = .notExternalAdmin

  public var canSendAudio: Bool = false

  public var canSendMessage: Bool = false

  public var isRobot: Bool = false

  public var loveCount: Int32 = 0

  public var seatIndex: Int32 = 0

  public var gender: Int32 = 0

  public var nickName: String = String()

  ///EquipmentComponent equipment = 19; //3D人物装扮
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STCreateChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STJoinChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STKickUserRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STQuitChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STModifyChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STBackToChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STGameTerminatedRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelID: String = String()

  public var gameID: STGameId = .gameNone

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STCinemaOperationRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var snapshot: STCinemaSnapshot {
    get {return _snapshot ?? STCinemaSnapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  public var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  public mutating func clearSnapshot() {self._snapshot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _snapshot: STCinemaSnapshot? = nil
}

/// 收发礼物用户
public struct STGiftUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var accountID: Int32 = 0

  public var nickName: String = String()

  public var avatarURL: String = String()

  public var loveNum: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物配置
public struct STGiftConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  /// 礼物类型 0.普通礼物 1.装饰物
  public var type: Int32 = 0

  public var name: String = String()

  public var value: Int32 = 0

  public var iconURL: String = String()

  /// 动效
  public var effects: String = String()

  ///心动值
  public var loveNum: Int32 = 0

  /// 角标icon
  public var cornerIcon: String = String()

  ///互动礼物特效
  public var effect: STGiftEffect {
    get {return _effect ?? STGiftEffect()}
    set {_effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  public var hasEffect: Bool {return self._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  public mutating func clearEffect() {self._effect = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _effect: STGiftEffect? = nil
}

/// 宝箱游戏
public struct STBoxGame: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 当前全服累计幸运值
  public var fullServiceValue: Int32 = 0

  /// (嘉年华)触发全服幸运条件值
  public var carnivalValue: Int32 = 0

  /// (嘉年华)活动结束倒计时(单位秒)
  public var carnivalCountdown: Int32 = 0

  /// (宝箱)普通入口图标
  public var boxIcon: String = String()

  /// (嘉年华)活动入口图标
  public var carnivalIcon: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物消息推送
public struct STGiftNotification: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 横幅全服,是否全频道显示(0.否,1.是,2.)
  public var showGlobal: Int32 {
    get {return _storage._showGlobal}
    set {_uniqueStorage()._showGlobal = newValue}
  }

  /// 是否显示横幅(0.否,1.是)
  public var showBanner: Int32 {
    get {return _storage._showBanner}
    set {_uniqueStorage()._showBanner = newValue}
  }

  /// 收发礼物所在频道id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 礼物数量
  public var giftNum: Int32 {
    get {return _storage._giftNum}
    set {_uniqueStorage()._giftNum = newValue}
  }

  /// 礼物信息
  public var giftConfig: STGiftConfig {
    get {return _storage._giftConfig ?? STGiftConfig()}
    set {_uniqueStorage()._giftConfig = newValue}
  }
  /// Returns true if `giftConfig` has been explicitly set.
  public var hasGiftConfig: Bool {return _storage._giftConfig != nil}
  /// Clears the value of `giftConfig`. Subsequent reads from it will return its default value.
  public mutating func clearGiftConfig() {_uniqueStorage()._giftConfig = nil}

  /// 送礼物用户信息
  public var sendUser: STGiftUser {
    get {return _storage._sendUser ?? STGiftUser()}
    set {_uniqueStorage()._sendUser = newValue}
  }
  /// Returns true if `sendUser` has been explicitly set.
  public var hasSendUser: Bool {return _storage._sendUser != nil}
  /// Clears the value of `sendUser`. Subsequent reads from it will return its default value.
  public mutating func clearSendUser() {_uniqueStorage()._sendUser = nil}

  /// 接收礼物用户列表
  public var targetUsers: [STGiftUser] {
    get {return _storage._targetUsers}
    set {_uniqueStorage()._targetUsers = newValue}
  }

  /// 送礼物时间戳
  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  ///自定义横幅内容
  public var bannerContent: String {
    get {return _storage._bannerContent}
    set {_uniqueStorage()._bannerContent = newValue}
  }

  ///横幅背景
  public var bannerStyle: String {
    get {return _storage._bannerStyle}
    set {_uniqueStorage()._bannerStyle = newValue}
  }

  ///横幅文字样式(前端判断)0=默认样式，1=活动样式 2=全服特效样式（送礼数量）3=魔法特效样式
  public var fontStyle: Int32 {
    get {return _storage._fontStyle}
    set {_uniqueStorage()._fontStyle = newValue}
  }

  public var source: STGiftSource {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  public var sourName: String {
    get {return _storage._sourName}
    set {_uniqueStorage()._sourName = newValue}
  }

  /// (抽奖礼物)气泡样式背景url
  public var bubbleURL: String {
    get {return _storage._bubbleURL}
    set {_uniqueStorage()._bubbleURL = newValue}
  }

  public var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  /// 公屏全服,展示位置类型(1.全局,2.频道内)
  public var globalType: Int32 {
    get {return _storage._globalType}
    set {_uniqueStorage()._globalType = newValue}
  }

  ///  (公屏)气泡样式背景url
  public var bubbleURL2: String {
    get {return _storage._bubbleURL2}
    set {_uniqueStorage()._bubbleURL2 = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 活动消息
public struct STActivityNotification: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STActivityType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  ///跳转类型1=跳转房间，2=跳转网页，3=个人主页
  public var linkType: Int32 {
    get {return _storage._linkType}
    set {_uniqueStorage()._linkType = newValue}
  }

  ///跳转内容
  public var linkValue: String {
    get {return _storage._linkValue}
    set {_uniqueStorage()._linkValue = newValue}
  }

  public var lockedStatus: Int32 {
    get {return _storage._lockedStatus}
    set {_uniqueStorage()._lockedStatus = newValue}
  }

  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var rabbitRecord: STRabbitRecord {
    get {return _storage._rabbitRecord ?? STRabbitRecord()}
    set {_uniqueStorage()._rabbitRecord = newValue}
  }
  /// Returns true if `rabbitRecord` has been explicitly set.
  public var hasRabbitRecord: Bool {return _storage._rabbitRecord != nil}
  /// Clears the value of `rabbitRecord`. Subsequent reads from it will return its default value.
  public mutating func clearRabbitRecord() {_uniqueStorage()._rabbitRecord = nil}

  /// 背景图片url
  public var bgURL: String {
    get {return _storage._bgURL}
    set {_uniqueStorage()._bgURL = newValue}
  }

  /// 横幅展示停留时间(单位毫秒)
  public var bannerShowTime: Int32 {
    get {return _storage._bannerShowTime}
    set {_uniqueStorage()._bannerShowTime = newValue}
  }

  /// 全服霸屏特效
  public var fullScreenEffect: STFullScreenEffect {
    get {return _storage._fullScreenEffect ?? STFullScreenEffect()}
    set {_uniqueStorage()._fullScreenEffect = newValue}
  }
  /// Returns true if `fullScreenEffect` has been explicitly set.
  public var hasFullScreenEffect: Bool {return _storage._fullScreenEffect != nil}
  /// Clears the value of `fullScreenEffect`. Subsequent reads from it will return its default value.
  public mutating func clearFullScreenEffect() {_uniqueStorage()._fullScreenEffect = nil}

  /// 动画全屏特效
  public var animationEffect: STAnimationEffect {
    get {return _storage._animationEffect ?? STAnimationEffect()}
    set {_uniqueStorage()._animationEffect = newValue}
  }
  /// Returns true if `animationEffect` has been explicitly set.
  public var hasAnimationEffect: Bool {return _storage._animationEffect != nil}
  /// Clears the value of `animationEffect`. Subsequent reads from it will return its default value.
  public mutating func clearAnimationEffect() {_uniqueStorage()._animationEffect = nil}

  ///活动h5模块
  public var h5Module: STH5Module {
    get {return _storage._h5Module ?? STH5Module()}
    set {_uniqueStorage()._h5Module = newValue}
  }
  /// Returns true if `h5Module` has been explicitly set.
  public var hasH5Module: Bool {return _storage._h5Module != nil}
  /// Clears the value of `h5Module`. Subsequent reads from it will return its default value.
  public mutating func clearH5Module() {_uniqueStorage()._h5Module = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 宝箱游戏推送
public struct STBoxGameNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STActivityType = .common

  /// 活动记录(横幅/公屏显示通用)
  public var rabbitRecord: STRabbitRecord {
    get {return _rabbitRecord ?? STRabbitRecord()}
    set {_rabbitRecord = newValue}
  }
  /// Returns true if `rabbitRecord` has been explicitly set.
  public var hasRabbitRecord: Bool {return self._rabbitRecord != nil}
  /// Clears the value of `rabbitRecord`. Subsequent reads from it will return its default value.
  public mutating func clearRabbitRecord() {self._rabbitRecord = nil}

  /// 是否显示横幅(0.否 1.是)
  public var showBanner: Int32 = 0

  /// 是否显示在公屏(0.否 1.是)
  public var showChat: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rabbitRecord: STRabbitRecord? = nil
}

/// 签约消息
public struct STContractNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contractType: STContractType = .unreadNotify

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 支付消息
public struct STPaymentNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var paymentType: STPaymentType = .orderInfo

  public var orderNo: String = String()

  public var success: Bool = false

  public var orderTitle: String = String()

  /// round(实际金额*100)
  public var price: Int32 = 0

  public var diamondsInc: Int32 = 0

  public var diamondsTotal: Int32 = 0

  /// 支付渠道: ALIPAY, WECHAT, OTHER
  public var payChannel: String = String()

  /// 触发了获得奖品的充值条件(价格);判断浮点数相等时注意避坑
  public var prizeCondition: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 公屏消息推送
public struct STChannelChatNotification: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 频道用户信息
  public var user: STUserInChannel {
    get {return _storage._user ?? STUserInChannel()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// 挂件信息
  public var pendant: STDressUpInfo {
    get {return _storage._pendant ?? STDressUpInfo()}
    set {_uniqueStorage()._pendant = newValue}
  }
  /// Returns true if `pendant` has been explicitly set.
  public var hasPendant: Bool {return _storage._pendant != nil}
  /// Clears the value of `pendant`. Subsequent reads from it will return its default value.
  public mutating func clearPendant() {_uniqueStorage()._pendant = nil}

  /// 气泡信息
  public var bubble: STDressUpInfo {
    get {return _storage._bubble ?? STDressUpInfo()}
    set {_uniqueStorage()._bubble = newValue}
  }
  /// Returns true if `bubble` has been explicitly set.
  public var hasBubble: Bool {return _storage._bubble != nil}
  /// Clears the value of `bubble`. Subsequent reads from it will return its default value.
  public mutating func clearBubble() {_uniqueStorage()._bubble = nil}

  /// 头像框信息
  public var avatarFrame: STDressUpInfo {
    get {return _storage._avatarFrame ?? STDressUpInfo()}
    set {_uniqueStorage()._avatarFrame = newValue}
  }
  /// Returns true if `avatarFrame` has been explicitly set.
  public var hasAvatarFrame: Bool {return _storage._avatarFrame != nil}
  /// Clears the value of `avatarFrame`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarFrame() {_uniqueStorage()._avatarFrame = nil}

  /// 口令动画
  public var phrase: STPhraseInfo {
    get {return _storage._phrase ?? STPhraseInfo()}
    set {_uniqueStorage()._phrase = newValue}
  }
  /// Returns true if `phrase` has been explicitly set.
  public var hasPhrase: Bool {return _storage._phrase != nil}
  /// Clears the value of `phrase`. Subsequent reads from it will return its default value.
  public mutating func clearPhrase() {_uniqueStorage()._phrase = nil}

  /// 勋章列表
  public var userMedals: [STMedalInfo] {
    get {return _storage._userMedals}
    set {_uniqueStorage()._userMedals = newValue}
  }

  /// 具体内容 (如用户发送的公屏消息)
  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// “一起看” 操作推送
public struct STCinemaOperationNotification: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///操作
  public var operation: STMediaPlayerOperation {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  /// 操作人 (操作人为空，表示自动轮播)
  public var `operator`: STUserInChannel {
    get {return _storage._operator ?? STUserInChannel()}
    set {_uniqueStorage()._operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  public var hasOperator: Bool {return _storage._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  public mutating func clearOperator() {_uniqueStorage()._operator = nil}

  /// 快照
  public var snapshot: STCinemaSnapshot {
    get {return _storage._snapshot ?? STCinemaSnapshot()}
    set {_uniqueStorage()._snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  public var hasSnapshot: Bool {return _storage._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  public mutating func clearSnapshot() {_uniqueStorage()._snapshot = nil}

  /// 视频是否已收藏(0未知1收藏2未收藏)
  public var favorite: Int32 {
    get {return _storage._favorite}
    set {_uniqueStorage()._favorite = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 房间状态快照信息
public struct STNotifySwitch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gift: Int32 = 0

  public var activity: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STMiniGameSwitch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var menuid: Int32 = 0

  public var enable: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STFamily: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: Int32 = 0

  public var ownerAccountID: Int32 = 0

  public var memberCount: Int32 = 0

  public var channelCount: Int32 = 0

  public var id: String = String()

  public var familyID: String = String()

  public var ownerID: String = String()

  public var avatarURL: String = String()

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STChatChannelVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAccountID: Int32 = 0

  public var status: Int32 = 0

  public var pkStatus: Int32 = 0

  public var pkActive: Int32 = 0

  public var lockedStatus: Int32 = 0

  public var totalValue: Int32 = 0

  public var ratedFalseNumber: Int32 = 0

  public var fixedFalseNumber: Int32 = 0

  public var ranking: Int32 = 0

  public var channelName: String = String()

  public var channelType: String = String()

  public var ownerID: String = String()

  public var avatarURL: String = String()

  public var gameName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STChatChannelPkGameUser: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: Int32 = 0

  public var gender: Int32 = 0

  public var lovenum: Int32 = 0

  public var type: Int32 = 0

  public var createTime: Int64 = 0

  public var updateTime: Int64 = 0

  public var pkID: String = String()

  public var pkChannelID: String = String()

  public var team: String = String()

  public var userID: String = String()

  public var nickname: String = String()

  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STPkGameBossUserVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: Int32 = 0

  public var value: Int32 = 0

  public var userID: String = String()

  public var avatarURL: String = String()

  public var nickname: String = String()

  public var team: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STChatChannelPkGame: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pkRoundID: String {
    get {return _storage._pkRoundID}
    set {_uniqueStorage()._pkRoundID = newValue}
  }

  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  public var targetChannelID: String {
    get {return _storage._targetChannelID}
    set {_uniqueStorage()._targetChannelID = newValue}
  }

  public var topic: String {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  public var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  public var redTeamScore: Int32 {
    get {return _storage._redTeamScore}
    set {_uniqueStorage()._redTeamScore = newValue}
  }

  public var blueTeamScore: Int32 {
    get {return _storage._blueTeamScore}
    set {_uniqueStorage()._blueTeamScore = newValue}
  }

  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  public var endTime: Int64 {
    get {return _storage._endTime}
    set {_uniqueStorage()._endTime = newValue}
  }

  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var updateTime: Int64 {
    get {return _storage._updateTime}
    set {_uniqueStorage()._updateTime = newValue}
  }

  public var systemTime: Int64 {
    get {return _storage._systemTime}
    set {_uniqueStorage()._systemTime = newValue}
  }

  public var redChannelInfo: STChatChannelVo {
    get {return _storage._redChannelInfo ?? STChatChannelVo()}
    set {_uniqueStorage()._redChannelInfo = newValue}
  }
  /// Returns true if `redChannelInfo` has been explicitly set.
  public var hasRedChannelInfo: Bool {return _storage._redChannelInfo != nil}
  /// Clears the value of `redChannelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRedChannelInfo() {_uniqueStorage()._redChannelInfo = nil}

  public var blueChannelInfo: STChatChannelVo {
    get {return _storage._blueChannelInfo ?? STChatChannelVo()}
    set {_uniqueStorage()._blueChannelInfo = newValue}
  }
  /// Returns true if `blueChannelInfo` has been explicitly set.
  public var hasBlueChannelInfo: Bool {return _storage._blueChannelInfo != nil}
  /// Clears the value of `blueChannelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBlueChannelInfo() {_uniqueStorage()._blueChannelInfo = nil}

  public var participants: [STChatChannelPkGameUser] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  public var blueParticipants: [STChatChannelPkGameUser] {
    get {return _storage._blueParticipants}
    set {_uniqueStorage()._blueParticipants = newValue}
  }

  public var pkBossUsers: [STPkGameBossUserVo] {
    get {return _storage._pkBossUsers}
    set {_uniqueStorage()._pkBossUsers = newValue}
  }

  public var bluePkBossUsers: [STPkGameBossUserVo] {
    get {return _storage._bluePkBossUsers}
    set {_uniqueStorage()._bluePkBossUsers = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct STChannelSnapshot: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 快照编号，值越大说明快照越新
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var cinemaSnapshot: STCinemaSnapshot {
    get {return _storage._cinemaSnapshot ?? STCinemaSnapshot()}
    set {_uniqueStorage()._cinemaSnapshot = newValue}
  }
  /// Returns true if `cinemaSnapshot` has been explicitly set.
  public var hasCinemaSnapshot: Bool {return _storage._cinemaSnapshot != nil}
  /// Clears the value of `cinemaSnapshot`. Subsequent reads from it will return its default value.
  public mutating func clearCinemaSnapshot() {_uniqueStorage()._cinemaSnapshot = nil}

  public var userInSeats: [STUserInChannel] {
    get {return _storage._userInSeats}
    set {_uniqueStorage()._userInSeats = newValue}
  }

  public var onlineNumber: Int32 {
    get {return _storage._onlineNumber}
    set {_uniqueStorage()._onlineNumber = newValue}
  }

  public var falseOnlineNumber: Int32 {
    get {return _storage._falseOnlineNumber}
    set {_uniqueStorage()._falseOnlineNumber = newValue}
  }

  ///  NotifySwitch notifySwitch = 6;
  ///  repeated MiniGameSwitch miniGameSwitch = 7;
  ///  Family family = 8;
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 宝箱活动
  public var boxGame: STBoxGame {
    get {return _storage._boxGame ?? STBoxGame()}
    set {_uniqueStorage()._boxGame = newValue}
  }
  /// Returns true if `boxGame` has been explicitly set.
  public var hasBoxGame: Bool {return _storage._boxGame != nil}
  /// Clears the value of `boxGame`. Subsequent reads from it will return its default value.
  public mutating func clearBoxGame() {_uniqueStorage()._boxGame = nil}

  /// 普通
  public var commonCapsuleToys: STBoxGame {
    get {return _storage._commonCapsuleToys ?? STBoxGame()}
    set {_uniqueStorage()._commonCapsuleToys = newValue}
  }
  /// Returns true if `commonCapsuleToys` has been explicitly set.
  public var hasCommonCapsuleToys: Bool {return _storage._commonCapsuleToys != nil}
  /// Clears the value of `commonCapsuleToys`. Subsequent reads from it will return its default value.
  public mutating func clearCommonCapsuleToys() {_uniqueStorage()._commonCapsuleToys = nil}

  /// 钻石
  public var diamondCapsuleToys: STBoxGame {
    get {return _storage._diamondCapsuleToys ?? STBoxGame()}
    set {_uniqueStorage()._diamondCapsuleToys = newValue}
  }
  /// Returns true if `diamondCapsuleToys` has been explicitly set.
  public var hasDiamondCapsuleToys: Bool {return _storage._diamondCapsuleToys != nil}
  /// Clears the value of `diamondCapsuleToys`. Subsequent reads from it will return its default value.
  public mutating func clearDiamondCapsuleToys() {_uniqueStorage()._diamondCapsuleToys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 一起看房间，视频播放信息同步
public struct STVideoExtraInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var video480URL: String = String()

  public var video720URL: String = String()

  public var video1080URL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STCinemaSnapshot: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 快照编号，值越大说明快照越新
  public var id: Int64 = 0

  /// 房间id
  public var channelID: String = String()

  public var videoID: Int64 = 0

  /// 播放状态
  public var state: STMediaPlayerState = .stop

  /// 当前播放的时间点(milliSecond)
  public var position: Int64 = 0

  /// 播放进度同步间隔(毫秒)，小于此值可视为与主播同步播放
  public var syncInterval: Int32 = 0

  /// 倍速, 1(0.5X), 2(0.75X), 3(1.0X), 4(1.2X), 4(1.5X), 5(2X)...
  public var speed: Int32 = 0

  /// videoId变化时，推送新的video信息
  public var extraInfo: STVideoExtraInfo {
    get {return _extraInfo ?? STVideoExtraInfo()}
    set {_extraInfo = newValue}
  }
  /// Returns true if `extraInfo` has been explicitly set.
  public var hasExtraInfo: Bool {return self._extraInfo != nil}
  /// Clears the value of `extraInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExtraInfo() {self._extraInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _extraInfo: STVideoExtraInfo? = nil
}

/// 数据刷新提醒消息
public struct STDataRefreshNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STBusinessType = .remindFirstRecharge

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///互动礼物特效
public struct STGiftEffect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senderExpressionID: Int32 = 0

  public var acceptExpressionID: Int32 = 0

  ///用来区分 客户端怎么实现送礼效果表现
  public var interactionType: Int32 = 0

  /// 特效名字 _0 代表起始位置的特效 _1代表飞行轨迹特效  _2代表到达目的地特效
  public var effectName: String = String()

  public var sendVfx: Int32 = 0

  public var acceptVfx: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 特效展示活动消息
public struct STAnimationEffect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///动效地址
  public var effectsURL: String = String()

  ///房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///房间内活动模块（h5、原生图标）
public struct STH5Module: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///房间ID
  public var channelID: String = String()

  ///h5弹窗
  public var dialogInfo: [STActivityDialogInfo] = []

  ///活动图标
  public var iconInfo: [STActivityIconInfo] = []

  ///是否销毁之前的h5弹窗
  public var destroyPreviousDialog: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STActivityDialogInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///h5请求链接（链接参数拼接时考虑?和&两种情况拼接）
  public var h5URL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STActivityIconInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///是否展示提示
  public var showTip: Bool = false

  ///提示对应的id
  public var tipIid: Int64 = 0

  /// 提示内容.
  public var tipContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension STMessageId: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MsgNone"),
    1: .same(proto: "Create_Channel"),
    2: .same(proto: "Join_Channel"),
    3: .same(proto: "Quit_Channel"),
    4: .same(proto: "BackTo_Channel"),
    50: .same(proto: "Game_Kick_User"),
    51: .same(proto: "Game_Join"),
    52: .same(proto: "Game_Quit"),
    100: .same(proto: "Game_Ready"),
    101: .same(proto: "Game_CancelReady"),
    102: .same(proto: "Game_Start"),
    103: .same(proto: "Game_Stop"),
    104: .same(proto: "Game_Terminated"),
    105: .same(proto: "Game_Message_H5"),
    106: .same(proto: "Game_Message_Push"),
    120: .same(proto: "Cinema_Operation"),
    121: .same(proto: "Data_Refresh"),
    200: .same(proto: "Message_Gift"),
    201: .same(proto: "Message_Activity"),
    202: .same(proto: "Message_Contract"),
    203: .same(proto: "Message_Payment"),
    204: .same(proto: "Message_ChannelChat"),
    205: .same(proto: "Message_CinemaOperation"),
    207: .same(proto: "Message_BoxGame"),
    208: .same(proto: "Message_Rocket"),
    209: .same(proto: "Message_Common"),
    210: .same(proto: "Message_BubbleGame"),
    211: .same(proto: "Message_AppBanner"),
    250: .same(proto: "Message_ChannelSnapshot"),
    253: .same(proto: "Message_WishGift"),
    255: .same(proto: "Message_BosomFriend"),
    256: .same(proto: "Message_SysMsgNotifyList"),
    257: .same(proto: "Message_Vip"),
    258: .same(proto: "Message_Expression"),
    301: .same(proto: "Message_ChannelOperate"),
    302: .same(proto: "Message_DataRefresh"),
    303: .same(proto: "Message_Open_LoveNum"),
    304: .same(proto: "Message_Close_LoveNum"),
    305: .same(proto: "Chat_Message"),
    306: .same(proto: "User_Module"),
    307: .same(proto: "Message_SysMsgNotify"),
    308: .same(proto: "Channel_Module"),
    309: .same(proto: "Message_Eidolon"),
  ]
}

extension STGameId: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GameNone"),
    1: .same(proto: "DaHuaShai"),
    2: .same(proto: "ZhuoQiu"),
    3: .same(proto: "ShuiShiWoDi"),
    4: .same(proto: "WuZiQi"),
    5: .same(proto: "DaFuWeng"),
    6: .same(proto: "DouDiZhu"),
  ]
}

extension STChannelType2: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Chat"),
    1: .same(proto: "Game"),
    2: .same(proto: "MiniGame"),
  ]
}

extension STActivityType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Common"),
    1: .same(proto: "Box"),
    2: .same(proto: "Rabbit"),
    5: .same(proto: "ScreenEffect"),
    6: .same(proto: "Animation"),
    7: .same(proto: "H5"),
  ]
}

extension STContractType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnreadNotify"),
  ]
}

extension STPaymentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OrderInfo"),
    1: .same(proto: "FirstOrderInfo"),
  ]
}

extension STUserRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "InBlackList"),
    1: .same(proto: "Normal"),
    2: .same(proto: "Admin"),
    3: .same(proto: "SuperAdmin"),
    4: .same(proto: "Owner"),
    5: .same(proto: "FamilyOwner"),
    6: .same(proto: "FamilyDeputyOwner"),
  ]
}

extension STExternUserRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NotExternalAdmin"),
    1: .same(proto: "ContractFamilyOwner"),
    2: .same(proto: "NormalFamilyOwner"),
    3: .same(proto: "ContractFamilyDeputyOwner"),
    4: .same(proto: "NormalFamilyDeputyOwner"),
  ]
}

extension STMediaPlayerState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Stop"),
    1: .same(proto: "Play"),
    2: .same(proto: "Pause"),
  ]
}

extension STMediaPlayerOperation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OperationPlay"),
    1: .same(proto: "OperationPause"),
    2: .same(proto: "OperationStop"),
    3: .same(proto: "OperationSeek"),
    4: .same(proto: "OperationSync"),
  ]
}

extension STCinemaErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ErrorNone"),
    1: .same(proto: "ErrorOperationInvalid"),
    2: .same(proto: "ErrorNoPermission"),
    3: .same(proto: "ErrorUserNotEnough"),
    4: .same(proto: "ErrorVideoInvalid"),
  ]
}

extension STGiftSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GiftNone"),
    1: .same(proto: "GiftCommon"),
    2: .same(proto: "GiftLucky"),
    3: .same(proto: "GiftLottery"),
  ]
}

extension STBusinessType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RemindFirstRecharge"),
    1: .same(proto: "RefreshMission"),
  ]
}

extension STAppFlag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "YINYOU"),
    1: .same(proto: "YOMI"),
    2: .same(proto: "YUANQI"),
    3: .same(proto: "KIS"),
  ]
}

extension STAnyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AnyMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STAnyMessage, rhs: STAnyMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .same(proto: "context"),
    4: .same(proto: "token"),
    5: .same(proto: "time"),
    6: .same(proto: "sign"),
    7: .same(proto: "extra"),
    8: .standard(proto: "app_flag"),
    20: .same(proto: "message"),
    21: .same(proto: "user"),
    100: .same(proto: "createChannelReq"),
    101: .same(proto: "joinChannelReq"),
    102: .same(proto: "kickUserReq"),
    103: .same(proto: "quitChanelReq"),
    104: .same(proto: "modifyChannelReq"),
    105: .same(proto: "backToChannelReq"),
    106: .same(proto: "cinemaOperationReq"),
    200: .same(proto: "gameReadyReq"),
    201: .same(proto: "gameCancelReadyReq"),
    202: .same(proto: "gameJoinReq"),
    203: .same(proto: "gameQuitReq"),
    204: .same(proto: "gameStartReq"),
    205: .same(proto: "gameStopReq"),
    206: .same(proto: "gameTerminatedReq"),
  ]

  fileprivate class _StorageClass {
    var _id: STMessageId = .msgNone
    var _version: Int32 = 0
    var _context: Int32 = 0
    var _token: String = String()
    var _time: Int64 = 0
    var _sign: String = String()
    var _extra: Data = Data()
    var _appFlag: STAppFlag = .yinyou
    var _request: STRequest.OneOf_Request?
    var _createChannelReq: STCreateChannelReq? = nil
    var _joinChannelReq: STJoinChannelReq? = nil
    var _kickUserReq: STKickUserReq? = nil
    var _quitChanelReq: STQuitChannelReq? = nil
    var _modifyChannelReq: STModifyChannelReq? = nil
    var _backToChannelReq: STBackToChannelReq? = nil
    var _cinemaOperationReq: STCinemaOperationReq? = nil
    var _gameReadyReq: STAnyMessage? = nil
    var _gameCancelReadyReq: STAnyMessage? = nil
    var _gameJoinReq: STGameJoinReq? = nil
    var _gameQuitReq: STAnyMessage? = nil
    var _gameStartReq: STAnyMessage? = nil
    var _gameStopReq: STAnyMessage? = nil
    var _gameTerminatedReq: STAnyMessage? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _version = source._version
      _context = source._context
      _token = source._token
      _time = source._time
      _sign = source._sign
      _extra = source._extra
      _appFlag = source._appFlag
      _request = source._request
      _createChannelReq = source._createChannelReq
      _joinChannelReq = source._joinChannelReq
      _kickUserReq = source._kickUserReq
      _quitChanelReq = source._quitChanelReq
      _modifyChannelReq = source._modifyChannelReq
      _backToChannelReq = source._backToChannelReq
      _cinemaOperationReq = source._cinemaOperationReq
      _gameReadyReq = source._gameReadyReq
      _gameCancelReadyReq = source._gameCancelReadyReq
      _gameJoinReq = source._gameJoinReq
      _gameQuitReq = source._gameQuitReq
      _gameStartReq = source._gameStartReq
      _gameStopReq = source._gameStopReq
      _gameTerminatedReq = source._gameTerminatedReq
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._version) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._context) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._time) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._sign) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._extra) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._appFlag) }()
        case 20: try {
          var v: STMessageRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .message(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .message(v)
          }
        }()
        case 21: try {
          var v: STUserRequest?
          var hadOneofValue = false
          if let current = _storage._request {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._request = .user(v)
          }
        }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._createChannelReq) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._joinChannelReq) }()
        case 102: try { try decoder.decodeSingularMessageField(value: &_storage._kickUserReq) }()
        case 103: try { try decoder.decodeSingularMessageField(value: &_storage._quitChanelReq) }()
        case 104: try { try decoder.decodeSingularMessageField(value: &_storage._modifyChannelReq) }()
        case 105: try { try decoder.decodeSingularMessageField(value: &_storage._backToChannelReq) }()
        case 106: try { try decoder.decodeSingularMessageField(value: &_storage._cinemaOperationReq) }()
        case 200: try { try decoder.decodeSingularMessageField(value: &_storage._gameReadyReq) }()
        case 201: try { try decoder.decodeSingularMessageField(value: &_storage._gameCancelReadyReq) }()
        case 202: try { try decoder.decodeSingularMessageField(value: &_storage._gameJoinReq) }()
        case 203: try { try decoder.decodeSingularMessageField(value: &_storage._gameQuitReq) }()
        case 204: try { try decoder.decodeSingularMessageField(value: &_storage._gameStartReq) }()
        case 205: try { try decoder.decodeSingularMessageField(value: &_storage._gameStopReq) }()
        case 206: try { try decoder.decodeSingularMessageField(value: &_storage._gameTerminatedReq) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != .msgNone {
        try visitor.visitSingularEnumField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 2)
      }
      if _storage._context != 0 {
        try visitor.visitSingularInt32Field(value: _storage._context, fieldNumber: 3)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 4)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 5)
      }
      if !_storage._sign.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sign, fieldNumber: 6)
      }
      if !_storage._extra.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._extra, fieldNumber: 7)
      }
      if _storage._appFlag != .yinyou {
        try visitor.visitSingularEnumField(value: _storage._appFlag, fieldNumber: 8)
      }
      switch _storage._request {
      case .message?: try {
        guard case .message(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .user?: try {
        guard case .user(let v)? = _storage._request else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case nil: break
      }
      try { if let v = _storage._createChannelReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
      try { if let v = _storage._joinChannelReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
      try { if let v = _storage._kickUserReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      } }()
      try { if let v = _storage._quitChanelReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      } }()
      try { if let v = _storage._modifyChannelReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      } }()
      try { if let v = _storage._backToChannelReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      } }()
      try { if let v = _storage._cinemaOperationReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      } }()
      try { if let v = _storage._gameReadyReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
      } }()
      try { if let v = _storage._gameCancelReadyReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
      } }()
      try { if let v = _storage._gameJoinReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
      } }()
      try { if let v = _storage._gameQuitReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 203)
      } }()
      try { if let v = _storage._gameStartReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 204)
      } }()
      try { if let v = _storage._gameStopReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 205)
      } }()
      try { if let v = _storage._gameTerminatedReq {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 206)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRequest, rhs: STRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._sign != rhs_storage._sign {return false}
        if _storage._extra != rhs_storage._extra {return false}
        if _storage._appFlag != rhs_storage._appFlag {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._createChannelReq != rhs_storage._createChannelReq {return false}
        if _storage._joinChannelReq != rhs_storage._joinChannelReq {return false}
        if _storage._kickUserReq != rhs_storage._kickUserReq {return false}
        if _storage._quitChanelReq != rhs_storage._quitChanelReq {return false}
        if _storage._modifyChannelReq != rhs_storage._modifyChannelReq {return false}
        if _storage._backToChannelReq != rhs_storage._backToChannelReq {return false}
        if _storage._cinemaOperationReq != rhs_storage._cinemaOperationReq {return false}
        if _storage._gameReadyReq != rhs_storage._gameReadyReq {return false}
        if _storage._gameCancelReadyReq != rhs_storage._gameCancelReadyReq {return false}
        if _storage._gameJoinReq != rhs_storage._gameJoinReq {return false}
        if _storage._gameQuitReq != rhs_storage._gameQuitReq {return false}
        if _storage._gameStartReq != rhs_storage._gameStartReq {return false}
        if _storage._gameStopReq != rhs_storage._gameStopReq {return false}
        if _storage._gameTerminatedReq != rhs_storage._gameTerminatedReq {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .same(proto: "context"),
    4: .same(proto: "code"),
    5: .same(proto: "time"),
    6: .same(proto: "msg"),
    7: .same(proto: "extra"),
    8: .standard(proto: "app_flag"),
    20: .same(proto: "message"),
    21: .same(proto: "user"),
    22: .same(proto: "channel"),
    100: .same(proto: "createChannelRes"),
    101: .same(proto: "joinChannelRes"),
    102: .same(proto: "kickUserRes"),
    103: .same(proto: "quitChannelRes"),
    104: .same(proto: "modifyChannelRes"),
    105: .same(proto: "backToChannelRes"),
    106: .same(proto: "cinemaOperationRes"),
    200: .same(proto: "gameReadyRes"),
    201: .same(proto: "gameCancelReadyRes"),
    202: .same(proto: "gameJoinRes"),
    203: .same(proto: "gameQuitRes"),
    204: .same(proto: "gameStartRes"),
    205: .same(proto: "gameStopRes"),
    206: .same(proto: "gameTerminatedRes"),
    250: .same(proto: "channelSnapshot"),
    300: .same(proto: "giftNotification"),
    301: .same(proto: "activityNotification"),
    302: .same(proto: "contractNotification"),
    303: .same(proto: "paymentNotification"),
    304: .same(proto: "chatMessageNotification"),
    305: .same(proto: "cinemaOperationNotification"),
    306: .same(proto: "dataRefreshNotification"),
    307: .same(proto: "boxGameNotification"),
    308: .same(proto: "rocketNotification"),
    310: .same(proto: "commonNotification"),
    311: .same(proto: "lotteryNotification"),
    312: .same(proto: "appBannerNotification"),
    313: .same(proto: "wishGiftNotification"),
    314: .same(proto: "sysMsgNotification"),
    315: .same(proto: "bosomFriendDto"),
    316: .same(proto: "sysMsgNotifications"),
    317: .same(proto: "vipNotification"),
    318: .same(proto: "eidolonNotification"),
    319: .same(proto: "expressionNotification"),
  ]

  fileprivate class _StorageClass {
    var _id: STMessageId = .msgNone
    var _version: Int32 = 0
    var _context: Int32 = 0
    var _code: Int32 = 0
    var _time: Int64 = 0
    var _msg: String = String()
    var _extra: Data = Data()
    var _appFlag: STAppFlag = .yinyou
    var _response: STResponse.OneOf_Response?
    var _createChannelRes: STCreateChannelRes? = nil
    var _joinChannelRes: STJoinChannelRes? = nil
    var _kickUserRes: STKickUserRes? = nil
    var _quitChannelRes: STQuitChannelRes? = nil
    var _modifyChannelRes: STModifyChannelRes? = nil
    var _backToChannelRes: STBackToChannelRes? = nil
    var _cinemaOperationRes: STCinemaOperationRes? = nil
    var _gameReadyRes: STAnyMessage? = nil
    var _gameCancelReadyRes: STAnyMessage? = nil
    var _gameJoinRes: STAnyMessage? = nil
    var _gameQuitRes: STAnyMessage? = nil
    var _gameStartRes: STAnyMessage? = nil
    var _gameStopRes: STAnyMessage? = nil
    var _gameTerminatedRes: STGameTerminatedRes? = nil
    var _channelSnapshot: STChannelSnapshot? = nil
    var _giftNotification: STGiftNotification? = nil
    var _activityNotification: STActivityNotification? = nil
    var _contractNotification: STContractNotification? = nil
    var _paymentNotification: STPaymentNotification? = nil
    var _chatMessageNotification: STChannelChatNotification? = nil
    var _cinemaOperationNotification: STCinemaOperationNotification? = nil
    var _dataRefreshNotification: STDataRefreshNotification? = nil
    var _boxGameNotification: STBoxGameNotification? = nil
    var _rocketNotification: STRocketNotification? = nil
    var _commonNotification: STCommonNotification? = nil
    var _lotteryNotification: STLotteryNotification? = nil
    var _appBannerNotification: STAppBannerNotification? = nil
    var _wishGiftNotification: STWishGiftNotification? = nil
    var _sysMsgNotification: STSysMsgNotification? = nil
    var _bosomFriendDto: STBosomFriendDto? = nil
    var _sysMsgNotifications: STSysMsgNotifications? = nil
    var _vipNotification: STVipNotification? = nil
    var _eidolonNotification: STEidolonNotification? = nil
    var _expressionNotification: STExpressionNotification? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _version = source._version
      _context = source._context
      _code = source._code
      _time = source._time
      _msg = source._msg
      _extra = source._extra
      _appFlag = source._appFlag
      _response = source._response
      _createChannelRes = source._createChannelRes
      _joinChannelRes = source._joinChannelRes
      _kickUserRes = source._kickUserRes
      _quitChannelRes = source._quitChannelRes
      _modifyChannelRes = source._modifyChannelRes
      _backToChannelRes = source._backToChannelRes
      _cinemaOperationRes = source._cinemaOperationRes
      _gameReadyRes = source._gameReadyRes
      _gameCancelReadyRes = source._gameCancelReadyRes
      _gameJoinRes = source._gameJoinRes
      _gameQuitRes = source._gameQuitRes
      _gameStartRes = source._gameStartRes
      _gameStopRes = source._gameStopRes
      _gameTerminatedRes = source._gameTerminatedRes
      _channelSnapshot = source._channelSnapshot
      _giftNotification = source._giftNotification
      _activityNotification = source._activityNotification
      _contractNotification = source._contractNotification
      _paymentNotification = source._paymentNotification
      _chatMessageNotification = source._chatMessageNotification
      _cinemaOperationNotification = source._cinemaOperationNotification
      _dataRefreshNotification = source._dataRefreshNotification
      _boxGameNotification = source._boxGameNotification
      _rocketNotification = source._rocketNotification
      _commonNotification = source._commonNotification
      _lotteryNotification = source._lotteryNotification
      _appBannerNotification = source._appBannerNotification
      _wishGiftNotification = source._wishGiftNotification
      _sysMsgNotification = source._sysMsgNotification
      _bosomFriendDto = source._bosomFriendDto
      _sysMsgNotifications = source._sysMsgNotifications
      _vipNotification = source._vipNotification
      _eidolonNotification = source._eidolonNotification
      _expressionNotification = source._expressionNotification
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._version) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._context) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._code) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._time) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._msg) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._extra) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._appFlag) }()
        case 20: try {
          var v: STMessageResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .message(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .message(v)
          }
        }()
        case 21: try {
          var v: STUserResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .user(v)
          }
        }()
        case 22: try {
          var v: STChannelResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .channel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .channel(v)
          }
        }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._createChannelRes) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._joinChannelRes) }()
        case 102: try { try decoder.decodeSingularMessageField(value: &_storage._kickUserRes) }()
        case 103: try { try decoder.decodeSingularMessageField(value: &_storage._quitChannelRes) }()
        case 104: try { try decoder.decodeSingularMessageField(value: &_storage._modifyChannelRes) }()
        case 105: try { try decoder.decodeSingularMessageField(value: &_storage._backToChannelRes) }()
        case 106: try { try decoder.decodeSingularMessageField(value: &_storage._cinemaOperationRes) }()
        case 200: try { try decoder.decodeSingularMessageField(value: &_storage._gameReadyRes) }()
        case 201: try { try decoder.decodeSingularMessageField(value: &_storage._gameCancelReadyRes) }()
        case 202: try { try decoder.decodeSingularMessageField(value: &_storage._gameJoinRes) }()
        case 203: try { try decoder.decodeSingularMessageField(value: &_storage._gameQuitRes) }()
        case 204: try { try decoder.decodeSingularMessageField(value: &_storage._gameStartRes) }()
        case 205: try { try decoder.decodeSingularMessageField(value: &_storage._gameStopRes) }()
        case 206: try { try decoder.decodeSingularMessageField(value: &_storage._gameTerminatedRes) }()
        case 250: try { try decoder.decodeSingularMessageField(value: &_storage._channelSnapshot) }()
        case 300: try { try decoder.decodeSingularMessageField(value: &_storage._giftNotification) }()
        case 301: try { try decoder.decodeSingularMessageField(value: &_storage._activityNotification) }()
        case 302: try { try decoder.decodeSingularMessageField(value: &_storage._contractNotification) }()
        case 303: try { try decoder.decodeSingularMessageField(value: &_storage._paymentNotification) }()
        case 304: try { try decoder.decodeSingularMessageField(value: &_storage._chatMessageNotification) }()
        case 305: try { try decoder.decodeSingularMessageField(value: &_storage._cinemaOperationNotification) }()
        case 306: try { try decoder.decodeSingularMessageField(value: &_storage._dataRefreshNotification) }()
        case 307: try { try decoder.decodeSingularMessageField(value: &_storage._boxGameNotification) }()
        case 308: try { try decoder.decodeSingularMessageField(value: &_storage._rocketNotification) }()
        case 310: try { try decoder.decodeSingularMessageField(value: &_storage._commonNotification) }()
        case 311: try { try decoder.decodeSingularMessageField(value: &_storage._lotteryNotification) }()
        case 312: try { try decoder.decodeSingularMessageField(value: &_storage._appBannerNotification) }()
        case 313: try { try decoder.decodeSingularMessageField(value: &_storage._wishGiftNotification) }()
        case 314: try { try decoder.decodeSingularMessageField(value: &_storage._sysMsgNotification) }()
        case 315: try { try decoder.decodeSingularMessageField(value: &_storage._bosomFriendDto) }()
        case 316: try { try decoder.decodeSingularMessageField(value: &_storage._sysMsgNotifications) }()
        case 317: try { try decoder.decodeSingularMessageField(value: &_storage._vipNotification) }()
        case 318: try { try decoder.decodeSingularMessageField(value: &_storage._eidolonNotification) }()
        case 319: try { try decoder.decodeSingularMessageField(value: &_storage._expressionNotification) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != .msgNone {
        try visitor.visitSingularEnumField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 2)
      }
      if _storage._context != 0 {
        try visitor.visitSingularInt32Field(value: _storage._context, fieldNumber: 3)
      }
      if _storage._code != 0 {
        try visitor.visitSingularInt32Field(value: _storage._code, fieldNumber: 4)
      }
      if _storage._time != 0 {
        try visitor.visitSingularInt64Field(value: _storage._time, fieldNumber: 5)
      }
      if !_storage._msg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._msg, fieldNumber: 6)
      }
      if !_storage._extra.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._extra, fieldNumber: 7)
      }
      if _storage._appFlag != .yinyou {
        try visitor.visitSingularEnumField(value: _storage._appFlag, fieldNumber: 8)
      }
      switch _storage._response {
      case .message?: try {
        guard case .message(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .user?: try {
        guard case .user(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .channel?: try {
        guard case .channel(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case nil: break
      }
      try { if let v = _storage._createChannelRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
      try { if let v = _storage._joinChannelRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
      try { if let v = _storage._kickUserRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      } }()
      try { if let v = _storage._quitChannelRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      } }()
      try { if let v = _storage._modifyChannelRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      } }()
      try { if let v = _storage._backToChannelRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      } }()
      try { if let v = _storage._cinemaOperationRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      } }()
      try { if let v = _storage._gameReadyRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 200)
      } }()
      try { if let v = _storage._gameCancelReadyRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 201)
      } }()
      try { if let v = _storage._gameJoinRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 202)
      } }()
      try { if let v = _storage._gameQuitRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 203)
      } }()
      try { if let v = _storage._gameStartRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 204)
      } }()
      try { if let v = _storage._gameStopRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 205)
      } }()
      try { if let v = _storage._gameTerminatedRes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 206)
      } }()
      try { if let v = _storage._channelSnapshot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 250)
      } }()
      try { if let v = _storage._giftNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 300)
      } }()
      try { if let v = _storage._activityNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      } }()
      try { if let v = _storage._contractNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 302)
      } }()
      try { if let v = _storage._paymentNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 303)
      } }()
      try { if let v = _storage._chatMessageNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 304)
      } }()
      try { if let v = _storage._cinemaOperationNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 305)
      } }()
      try { if let v = _storage._dataRefreshNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 306)
      } }()
      try { if let v = _storage._boxGameNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 307)
      } }()
      try { if let v = _storage._rocketNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 308)
      } }()
      try { if let v = _storage._commonNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 310)
      } }()
      try { if let v = _storage._lotteryNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 311)
      } }()
      try { if let v = _storage._appBannerNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 312)
      } }()
      try { if let v = _storage._wishGiftNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 313)
      } }()
      try { if let v = _storage._sysMsgNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 314)
      } }()
      try { if let v = _storage._bosomFriendDto {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 315)
      } }()
      try { if let v = _storage._sysMsgNotifications {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 316)
      } }()
      try { if let v = _storage._vipNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 317)
      } }()
      try { if let v = _storage._eidolonNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 318)
      } }()
      try { if let v = _storage._expressionNotification {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 319)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STResponse, rhs: STResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._msg != rhs_storage._msg {return false}
        if _storage._extra != rhs_storage._extra {return false}
        if _storage._appFlag != rhs_storage._appFlag {return false}
        if _storage._response != rhs_storage._response {return false}
        if _storage._createChannelRes != rhs_storage._createChannelRes {return false}
        if _storage._joinChannelRes != rhs_storage._joinChannelRes {return false}
        if _storage._kickUserRes != rhs_storage._kickUserRes {return false}
        if _storage._quitChannelRes != rhs_storage._quitChannelRes {return false}
        if _storage._modifyChannelRes != rhs_storage._modifyChannelRes {return false}
        if _storage._backToChannelRes != rhs_storage._backToChannelRes {return false}
        if _storage._cinemaOperationRes != rhs_storage._cinemaOperationRes {return false}
        if _storage._gameReadyRes != rhs_storage._gameReadyRes {return false}
        if _storage._gameCancelReadyRes != rhs_storage._gameCancelReadyRes {return false}
        if _storage._gameJoinRes != rhs_storage._gameJoinRes {return false}
        if _storage._gameQuitRes != rhs_storage._gameQuitRes {return false}
        if _storage._gameStartRes != rhs_storage._gameStartRes {return false}
        if _storage._gameStopRes != rhs_storage._gameStopRes {return false}
        if _storage._gameTerminatedRes != rhs_storage._gameTerminatedRes {return false}
        if _storage._channelSnapshot != rhs_storage._channelSnapshot {return false}
        if _storage._giftNotification != rhs_storage._giftNotification {return false}
        if _storage._activityNotification != rhs_storage._activityNotification {return false}
        if _storage._contractNotification != rhs_storage._contractNotification {return false}
        if _storage._paymentNotification != rhs_storage._paymentNotification {return false}
        if _storage._chatMessageNotification != rhs_storage._chatMessageNotification {return false}
        if _storage._cinemaOperationNotification != rhs_storage._cinemaOperationNotification {return false}
        if _storage._dataRefreshNotification != rhs_storage._dataRefreshNotification {return false}
        if _storage._boxGameNotification != rhs_storage._boxGameNotification {return false}
        if _storage._rocketNotification != rhs_storage._rocketNotification {return false}
        if _storage._commonNotification != rhs_storage._commonNotification {return false}
        if _storage._lotteryNotification != rhs_storage._lotteryNotification {return false}
        if _storage._appBannerNotification != rhs_storage._appBannerNotification {return false}
        if _storage._wishGiftNotification != rhs_storage._wishGiftNotification {return false}
        if _storage._sysMsgNotification != rhs_storage._sysMsgNotification {return false}
        if _storage._bosomFriendDto != rhs_storage._bosomFriendDto {return false}
        if _storage._sysMsgNotifications != rhs_storage._sysMsgNotifications {return false}
        if _storage._vipNotification != rhs_storage._vipNotification {return false}
        if _storage._eidolonNotification != rhs_storage._eidolonNotification {return false}
        if _storage._expressionNotification != rhs_storage._expressionNotification {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCreateChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CreateChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelName"),
    2: .same(proto: "channelType"),
    3: .same(proto: "gameId"),
    4: .same(proto: "daquId"),
    5: .same(proto: "duanId"),
    6: .same(proto: "gameModelId"),
    7: .same(proto: "yuleId"),
    8: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.gameID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.daquID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.duanID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.gameModelID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.yuleID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 1)
    }
    if self.channelType != .chat {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 2)
    }
    if self.gameID != 0 {
      try visitor.visitSingularInt32Field(value: self.gameID, fieldNumber: 3)
    }
    if self.daquID != 0 {
      try visitor.visitSingularInt32Field(value: self.daquID, fieldNumber: 4)
    }
    if self.duanID != 0 {
      try visitor.visitSingularInt32Field(value: self.duanID, fieldNumber: 5)
    }
    if self.gameModelID != 0 {
      try visitor.visitSingularInt32Field(value: self.gameModelID, fieldNumber: 6)
    }
    if self.yuleID != 0 {
      try visitor.visitSingularInt32Field(value: self.yuleID, fieldNumber: 7)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCreateChannelReq, rhs: STCreateChannelReq) -> Bool {
    if lhs.channelName != rhs.channelName {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.gameID != rhs.gameID {return false}
    if lhs.daquID != rhs.daquID {return false}
    if lhs.duanID != rhs.duanID {return false}
    if lhs.gameModelID != rhs.gameModelID {return false}
    if lhs.yuleID != rhs.yuleID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STJoinChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "JoinChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "password"),
    3: .same(proto: "channelType"),
    4: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if self.channelType != .chat {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 3)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STJoinChannelReq, rhs: STJoinChannelReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STQuitChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "QuitChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STQuitChannelReq, rhs: STQuitChannelReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STModifyChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ModifyChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "operateType"),
    3: .same(proto: "channelName"),
    4: .same(proto: "channelPwd"),
    5: .same(proto: "welcomingSpeech"),
    6: .same(proto: "channelType"),
    7: .same(proto: "gameId"),
    8: .same(proto: "coverUrl"),
    9: .same(proto: "daquId"),
    10: .same(proto: "duanId"),
    11: .same(proto: "gameModelId"),
    12: .same(proto: "yuleId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.operateType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelPwd) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.welcomingSpeech) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.gameID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.coverURL) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.daquID) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.duanID) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.gameModelID) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.yuleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.operateType != 0 {
      try visitor.visitSingularInt32Field(value: self.operateType, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if !self.channelPwd.isEmpty {
      try visitor.visitSingularStringField(value: self.channelPwd, fieldNumber: 4)
    }
    if !self.welcomingSpeech.isEmpty {
      try visitor.visitSingularStringField(value: self.welcomingSpeech, fieldNumber: 5)
    }
    if self.channelType != .chat {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 6)
    }
    if self.gameID != 0 {
      try visitor.visitSingularInt32Field(value: self.gameID, fieldNumber: 7)
    }
    if !self.coverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coverURL, fieldNumber: 8)
    }
    if self.daquID != 0 {
      try visitor.visitSingularInt32Field(value: self.daquID, fieldNumber: 9)
    }
    if self.duanID != 0 {
      try visitor.visitSingularInt32Field(value: self.duanID, fieldNumber: 10)
    }
    if self.gameModelID != 0 {
      try visitor.visitSingularInt32Field(value: self.gameModelID, fieldNumber: 11)
    }
    if self.yuleID != 0 {
      try visitor.visitSingularInt32Field(value: self.yuleID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STModifyChannelReq, rhs: STModifyChannelReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.operateType != rhs.operateType {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.channelPwd != rhs.channelPwd {return false}
    if lhs.welcomingSpeech != rhs.welcomingSpeech {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.gameID != rhs.gameID {return false}
    if lhs.coverURL != rhs.coverURL {return false}
    if lhs.daquID != rhs.daquID {return false}
    if lhs.duanID != rhs.duanID {return false}
    if lhs.gameModelID != rhs.gameModelID {return false}
    if lhs.yuleID != rhs.yuleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STKickUserReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "KickUserReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetUserId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUserID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STKickUserReq, rhs: STKickUserReq) -> Bool {
    if lhs.targetUserID != rhs.targetUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STBackToChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BackToChannelReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STBackToChannelReq, rhs: STBackToChannelReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STGameJoinReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GameJoinReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "playerPosition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.playerPosition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.playerPosition != 0 {
      try visitor.visitSingularInt32Field(value: self.playerPosition, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STGameJoinReq, rhs: STGameJoinReq) -> Bool {
    if lhs.playerPosition != rhs.playerPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCinemaOperationReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CinemaOperationReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "operation"),
    3: .same(proto: "channelId"),
    4: .same(proto: "videoId"),
    5: .same(proto: "position"),
    6: .same(proto: "speed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.videoID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.position) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.speed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.operation != .operationPlay {
      try visitor.visitSingularEnumField(value: self.operation, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    if self.videoID != 0 {
      try visitor.visitSingularInt64Field(value: self.videoID, fieldNumber: 4)
    }
    if self.position != 0 {
      try visitor.visitSingularInt64Field(value: self.position, fieldNumber: 5)
    }
    if self.speed != 0 {
      try visitor.visitSingularInt32Field(value: self.speed, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCinemaOperationReq, rhs: STCinemaOperationReq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.videoID != rhs.videoID {return false}
    if lhs.position != rhs.position {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "User"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STUser, rhs: STUser) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMedalInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MedalInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "medalId"),
    2: .same(proto: "medalLevelId"),
    4: .same(proto: "medalLevelNum"),
    5: .same(proto: "empiricalValue"),
    6: .same(proto: "showState"),
    7: .same(proto: "medalName"),
    8: .same(proto: "medalLevelTitle"),
    9: .same(proto: "medalLevelIcon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.medalID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.medalLevelID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.medalLevelNum) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.empiricalValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.showState) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.medalName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.medalLevelTitle) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.medalLevelIcon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.medalID != 0 {
      try visitor.visitSingularInt32Field(value: self.medalID, fieldNumber: 1)
    }
    if self.medalLevelID != 0 {
      try visitor.visitSingularInt32Field(value: self.medalLevelID, fieldNumber: 2)
    }
    if self.medalLevelNum != 0 {
      try visitor.visitSingularInt32Field(value: self.medalLevelNum, fieldNumber: 4)
    }
    if self.empiricalValue != 0 {
      try visitor.visitSingularInt32Field(value: self.empiricalValue, fieldNumber: 5)
    }
    if self.showState != 0 {
      try visitor.visitSingularInt32Field(value: self.showState, fieldNumber: 6)
    }
    if !self.medalName.isEmpty {
      try visitor.visitSingularStringField(value: self.medalName, fieldNumber: 7)
    }
    if !self.medalLevelTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.medalLevelTitle, fieldNumber: 8)
    }
    if !self.medalLevelIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.medalLevelIcon, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMedalInfo, rhs: STMedalInfo) -> Bool {
    if lhs.medalID != rhs.medalID {return false}
    if lhs.medalLevelID != rhs.medalLevelID {return false}
    if lhs.medalLevelNum != rhs.medalLevelNum {return false}
    if lhs.empiricalValue != rhs.empiricalValue {return false}
    if lhs.showState != rhs.showState {return false}
    if lhs.medalName != rhs.medalName {return false}
    if lhs.medalLevelTitle != rhs.medalLevelTitle {return false}
    if lhs.medalLevelIcon != rhs.medalLevelIcon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRabbitRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RabbitRecord"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "userId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "prizeId"),
    5: .same(proto: "prizeName"),
    6: .same(proto: "prizeValue"),
    7: .same(proto: "prizeCount"),
    8: .same(proto: "bubbleUrl"),
    9: .same(proto: "prizeIconUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.prizeID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.prizeName) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.prizeValue) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.prizeCount) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.bubbleURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.prizeIconURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if self.prizeID != 0 {
      try visitor.visitSingularInt32Field(value: self.prizeID, fieldNumber: 4)
    }
    if !self.prizeName.isEmpty {
      try visitor.visitSingularStringField(value: self.prizeName, fieldNumber: 5)
    }
    if self.prizeValue != 0 {
      try visitor.visitSingularInt32Field(value: self.prizeValue, fieldNumber: 6)
    }
    if self.prizeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.prizeCount, fieldNumber: 7)
    }
    if !self.bubbleURL.isEmpty {
      try visitor.visitSingularStringField(value: self.bubbleURL, fieldNumber: 8)
    }
    if !self.prizeIconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.prizeIconURL, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRabbitRecord, rhs: STRabbitRecord) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.prizeID != rhs.prizeID {return false}
    if lhs.prizeName != rhs.prizeName {return false}
    if lhs.prizeValue != rhs.prizeValue {return false}
    if lhs.prizeCount != rhs.prizeCount {return false}
    if lhs.bubbleURL != rhs.bubbleURL {return false}
    if lhs.prizeIconURL != rhs.prizeIconURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STPhraseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PhraseInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "effectUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STPhraseInfo, rhs: STPhraseInfo) -> Bool {
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STUserInChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserInChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "role"),
    4: .same(proto: "externRole"),
    5: .same(proto: "canSendAudio"),
    6: .same(proto: "canSendMessage"),
    7: .same(proto: "isRobot"),
    8: .same(proto: "loveCount"),
    9: .same(proto: "seatIndex"),
    10: .same(proto: "gender"),
    11: .same(proto: "nickName"),
    12: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.externRole) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.canSendAudio) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.canSendMessage) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isRobot) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.loveCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.gender) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.nickName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if self.role != .inBlackList {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 3)
    }
    if self.externRole != .notExternalAdmin {
      try visitor.visitSingularEnumField(value: self.externRole, fieldNumber: 4)
    }
    if self.canSendAudio != false {
      try visitor.visitSingularBoolField(value: self.canSendAudio, fieldNumber: 5)
    }
    if self.canSendMessage != false {
      try visitor.visitSingularBoolField(value: self.canSendMessage, fieldNumber: 6)
    }
    if self.isRobot != false {
      try visitor.visitSingularBoolField(value: self.isRobot, fieldNumber: 7)
    }
    if self.loveCount != 0 {
      try visitor.visitSingularInt32Field(value: self.loveCount, fieldNumber: 8)
    }
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 9)
    }
    if self.gender != 0 {
      try visitor.visitSingularInt32Field(value: self.gender, fieldNumber: 10)
    }
    if !self.nickName.isEmpty {
      try visitor.visitSingularStringField(value: self.nickName, fieldNumber: 11)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STUserInChannel, rhs: STUserInChannel) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.externRole != rhs.externRole {return false}
    if lhs.canSendAudio != rhs.canSendAudio {return false}
    if lhs.canSendMessage != rhs.canSendMessage {return false}
    if lhs.isRobot != rhs.isRobot {return false}
    if lhs.loveCount != rhs.loveCount {return false}
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.nickName != rhs.nickName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCreateChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CreateChannelRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCreateChannelRes, rhs: STCreateChannelRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STJoinChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "JoinChannelRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STJoinChannelRes, rhs: STJoinChannelRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STKickUserRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "KickUserRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STKickUserRes, rhs: STKickUserRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STQuitChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "QuitChannelRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STQuitChannelRes, rhs: STQuitChannelRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STModifyChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ModifyChannelRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STModifyChannelRes, rhs: STModifyChannelRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STBackToChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BackToChannelRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STBackToChannelRes, rhs: STBackToChannelRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STGameTerminatedRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GameTerminatedRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "gameId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gameID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.gameID != .gameNone {
      try visitor.visitSingularEnumField(value: self.gameID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STGameTerminatedRes, rhs: STGameTerminatedRes) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.gameID != rhs.gameID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCinemaOperationRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CinemaOperationRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCinemaOperationRes, rhs: STCinemaOperationRes) -> Bool {
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STGiftUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GiftUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "loveNum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.loveNum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickName.isEmpty {
      try visitor.visitSingularStringField(value: self.nickName, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.loveNum != 0 {
      try visitor.visitSingularInt32Field(value: self.loveNum, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STGiftUser, rhs: STGiftUser) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickName != rhs.nickName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.loveNum != rhs.loveNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STGiftConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GiftConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "value"),
    5: .same(proto: "iconUrl"),
    6: .same(proto: "effects"),
    7: .same(proto: "loveNum"),
    8: .same(proto: "cornerIcon"),
    9: .same(proto: "effect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.effects) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.loveNum) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.cornerIcon) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._effect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 4)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 5)
    }
    if !self.effects.isEmpty {
      try visitor.visitSingularStringField(value: self.effects, fieldNumber: 6)
    }
    if self.loveNum != 0 {
      try visitor.visitSingularInt32Field(value: self.loveNum, fieldNumber: 7)
    }
    if !self.cornerIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.cornerIcon, fieldNumber: 8)
    }
    try { if let v = self._effect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STGiftConfig, rhs: STGiftConfig) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.loveNum != rhs.loveNum {return false}
    if lhs.cornerIcon != rhs.cornerIcon {return false}
    if lhs._effect != rhs._effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STBoxGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BoxGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullServiceValue"),
    2: .same(proto: "carnivalValue"),
    3: .same(proto: "carnivalCountdown"),
    4: .same(proto: "boxIcon"),
    5: .same(proto: "carnivalIcon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.fullServiceValue) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.carnivalValue) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.carnivalCountdown) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.boxIcon) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.carnivalIcon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fullServiceValue != 0 {
      try visitor.visitSingularInt32Field(value: self.fullServiceValue, fieldNumber: 1)
    }
    if self.carnivalValue != 0 {
      try visitor.visitSingularInt32Field(value: self.carnivalValue, fieldNumber: 2)
    }
    if self.carnivalCountdown != 0 {
      try visitor.visitSingularInt32Field(value: self.carnivalCountdown, fieldNumber: 3)
    }
    if !self.boxIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.boxIcon, fieldNumber: 4)
    }
    if !self.carnivalIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.carnivalIcon, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STBoxGame, rhs: STBoxGame) -> Bool {
    if lhs.fullServiceValue != rhs.fullServiceValue {return false}
    if lhs.carnivalValue != rhs.carnivalValue {return false}
    if lhs.carnivalCountdown != rhs.carnivalCountdown {return false}
    if lhs.boxIcon != rhs.boxIcon {return false}
    if lhs.carnivalIcon != rhs.carnivalIcon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STGiftNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GiftNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "showGlobal"),
    2: .same(proto: "showBanner"),
    3: .same(proto: "channelId"),
    4: .same(proto: "giftNum"),
    5: .same(proto: "giftConfig"),
    6: .same(proto: "sendUser"),
    7: .same(proto: "targetUsers"),
    8: .same(proto: "timestamp"),
    9: .same(proto: "bannerContent"),
    10: .same(proto: "bannerStyle"),
    11: .same(proto: "fontStyle"),
    12: .same(proto: "source"),
    13: .same(proto: "sourName"),
    14: .same(proto: "bubbleUrl"),
    15: .same(proto: "channelName"),
    16: .same(proto: "globalType"),
    17: .same(proto: "bubbleUrl2"),
  ]

  fileprivate class _StorageClass {
    var _showGlobal: Int32 = 0
    var _showBanner: Int32 = 0
    var _channelID: String = String()
    var _giftNum: Int32 = 0
    var _giftConfig: STGiftConfig? = nil
    var _sendUser: STGiftUser? = nil
    var _targetUsers: [STGiftUser] = []
    var _timestamp: Int64 = 0
    var _bannerContent: String = String()
    var _bannerStyle: String = String()
    var _fontStyle: Int32 = 0
    var _source: STGiftSource = .giftNone
    var _sourName: String = String()
    var _bubbleURL: String = String()
    var _channelName: String = String()
    var _globalType: Int32 = 0
    var _bubbleURL2: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _showGlobal = source._showGlobal
      _showBanner = source._showBanner
      _channelID = source._channelID
      _giftNum = source._giftNum
      _giftConfig = source._giftConfig
      _sendUser = source._sendUser
      _targetUsers = source._targetUsers
      _timestamp = source._timestamp
      _bannerContent = source._bannerContent
      _bannerStyle = source._bannerStyle
      _fontStyle = source._fontStyle
      _source = source._source
      _sourName = source._sourName
      _bubbleURL = source._bubbleURL
      _channelName = source._channelName
      _globalType = source._globalType
      _bubbleURL2 = source._bubbleURL2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._showGlobal) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._showBanner) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._giftNum) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._giftConfig) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sendUser) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._targetUsers) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._bannerContent) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._bannerStyle) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._fontStyle) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._source) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._sourName) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._bubbleURL) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._channelName) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._globalType) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._bubbleURL2) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._showGlobal != 0 {
        try visitor.visitSingularInt32Field(value: _storage._showGlobal, fieldNumber: 1)
      }
      if _storage._showBanner != 0 {
        try visitor.visitSingularInt32Field(value: _storage._showBanner, fieldNumber: 2)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 3)
      }
      if _storage._giftNum != 0 {
        try visitor.visitSingularInt32Field(value: _storage._giftNum, fieldNumber: 4)
      }
      try { if let v = _storage._giftConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sendUser {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._targetUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._targetUsers, fieldNumber: 7)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 8)
      }
      if !_storage._bannerContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bannerContent, fieldNumber: 9)
      }
      if !_storage._bannerStyle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bannerStyle, fieldNumber: 10)
      }
      if _storage._fontStyle != 0 {
        try visitor.visitSingularInt32Field(value: _storage._fontStyle, fieldNumber: 11)
      }
      if _storage._source != .giftNone {
        try visitor.visitSingularEnumField(value: _storage._source, fieldNumber: 12)
      }
      if !_storage._sourName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sourName, fieldNumber: 13)
      }
      if !_storage._bubbleURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bubbleURL, fieldNumber: 14)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 15)
      }
      if _storage._globalType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._globalType, fieldNumber: 16)
      }
      if !_storage._bubbleURL2.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bubbleURL2, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STGiftNotification, rhs: STGiftNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._showGlobal != rhs_storage._showGlobal {return false}
        if _storage._showBanner != rhs_storage._showBanner {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._giftNum != rhs_storage._giftNum {return false}
        if _storage._giftConfig != rhs_storage._giftConfig {return false}
        if _storage._sendUser != rhs_storage._sendUser {return false}
        if _storage._targetUsers != rhs_storage._targetUsers {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._bannerContent != rhs_storage._bannerContent {return false}
        if _storage._bannerStyle != rhs_storage._bannerStyle {return false}
        if _storage._fontStyle != rhs_storage._fontStyle {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._sourName != rhs_storage._sourName {return false}
        if _storage._bubbleURL != rhs_storage._bubbleURL {return false}
        if _storage._channelName != rhs_storage._channelName {return false}
        if _storage._globalType != rhs_storage._globalType {return false}
        if _storage._bubbleURL2 != rhs_storage._bubbleURL2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STActivityNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ActivityNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "linkType"),
    3: .same(proto: "linkValue"),
    4: .same(proto: "lockedStatus"),
    5: .same(proto: "content"),
    6: .same(proto: "title"),
    7: .same(proto: "rabbitRecord"),
    8: .same(proto: "bgUrl"),
    9: .same(proto: "bannerShowTime"),
    12: .same(proto: "fullScreenEffect"),
    13: .same(proto: "animationEffect"),
    14: .same(proto: "h5Module"),
  ]

  fileprivate class _StorageClass {
    var _type: STActivityType = .common
    var _linkType: Int32 = 0
    var _linkValue: String = String()
    var _lockedStatus: Int32 = 0
    var _content: String = String()
    var _title: String = String()
    var _rabbitRecord: STRabbitRecord? = nil
    var _bgURL: String = String()
    var _bannerShowTime: Int32 = 0
    var _fullScreenEffect: STFullScreenEffect? = nil
    var _animationEffect: STAnimationEffect? = nil
    var _h5Module: STH5Module? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _linkType = source._linkType
      _linkValue = source._linkValue
      _lockedStatus = source._lockedStatus
      _content = source._content
      _title = source._title
      _rabbitRecord = source._rabbitRecord
      _bgURL = source._bgURL
      _bannerShowTime = source._bannerShowTime
      _fullScreenEffect = source._fullScreenEffect
      _animationEffect = source._animationEffect
      _h5Module = source._h5Module
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._linkType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._linkValue) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._lockedStatus) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._rabbitRecord) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._bgURL) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._bannerShowTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._fullScreenEffect) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._animationEffect) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._h5Module) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .common {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._linkType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._linkType, fieldNumber: 2)
      }
      if !_storage._linkValue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._linkValue, fieldNumber: 3)
      }
      if _storage._lockedStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lockedStatus, fieldNumber: 4)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 5)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 6)
      }
      try { if let v = _storage._rabbitRecord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._bgURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bgURL, fieldNumber: 8)
      }
      if _storage._bannerShowTime != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bannerShowTime, fieldNumber: 9)
      }
      try { if let v = _storage._fullScreenEffect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._animationEffect {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._h5Module {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STActivityNotification, rhs: STActivityNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._linkType != rhs_storage._linkType {return false}
        if _storage._linkValue != rhs_storage._linkValue {return false}
        if _storage._lockedStatus != rhs_storage._lockedStatus {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._rabbitRecord != rhs_storage._rabbitRecord {return false}
        if _storage._bgURL != rhs_storage._bgURL {return false}
        if _storage._bannerShowTime != rhs_storage._bannerShowTime {return false}
        if _storage._fullScreenEffect != rhs_storage._fullScreenEffect {return false}
        if _storage._animationEffect != rhs_storage._animationEffect {return false}
        if _storage._h5Module != rhs_storage._h5Module {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STBoxGameNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "BoxGameNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rabbitRecord"),
    3: .same(proto: "showBanner"),
    4: .same(proto: "showChat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rabbitRecord) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.showBanner) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.showChat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .common {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._rabbitRecord {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.showBanner != 0 {
      try visitor.visitSingularInt32Field(value: self.showBanner, fieldNumber: 3)
    }
    if self.showChat != 0 {
      try visitor.visitSingularInt32Field(value: self.showChat, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STBoxGameNotification, rhs: STBoxGameNotification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._rabbitRecord != rhs._rabbitRecord {return false}
    if lhs.showBanner != rhs.showBanner {return false}
    if lhs.showChat != rhs.showChat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STContractNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ContractNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contractType"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contractType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contractType != .unreadNotify {
      try visitor.visitSingularEnumField(value: self.contractType, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STContractNotification, rhs: STContractNotification) -> Bool {
    if lhs.contractType != rhs.contractType {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STPaymentNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PaymentNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "paymentType"),
    2: .same(proto: "orderNo"),
    3: .same(proto: "success"),
    4: .same(proto: "orderTitle"),
    5: .same(proto: "price"),
    6: .same(proto: "diamondsInc"),
    7: .same(proto: "diamondsTotal"),
    8: .same(proto: "payChannel"),
    9: .same(proto: "prizeCondition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.paymentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orderNo) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderTitle) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.price) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.diamondsInc) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.diamondsTotal) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.payChannel) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.prizeCondition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.paymentType != .orderInfo {
      try visitor.visitSingularEnumField(value: self.paymentType, fieldNumber: 1)
    }
    if !self.orderNo.isEmpty {
      try visitor.visitSingularStringField(value: self.orderNo, fieldNumber: 2)
    }
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    if !self.orderTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.orderTitle, fieldNumber: 4)
    }
    if self.price != 0 {
      try visitor.visitSingularInt32Field(value: self.price, fieldNumber: 5)
    }
    if self.diamondsInc != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsInc, fieldNumber: 6)
    }
    if self.diamondsTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsTotal, fieldNumber: 7)
    }
    if !self.payChannel.isEmpty {
      try visitor.visitSingularStringField(value: self.payChannel, fieldNumber: 8)
    }
    if self.prizeCondition.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.prizeCondition, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STPaymentNotification, rhs: STPaymentNotification) -> Bool {
    if lhs.paymentType != rhs.paymentType {return false}
    if lhs.orderNo != rhs.orderNo {return false}
    if lhs.success != rhs.success {return false}
    if lhs.orderTitle != rhs.orderTitle {return false}
    if lhs.price != rhs.price {return false}
    if lhs.diamondsInc != rhs.diamondsInc {return false}
    if lhs.diamondsTotal != rhs.diamondsTotal {return false}
    if lhs.payChannel != rhs.payChannel {return false}
    if lhs.prizeCondition != rhs.prizeCondition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelChatNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelChatNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "pendant"),
    3: .same(proto: "bubble"),
    4: .same(proto: "avatarFrame"),
    5: .same(proto: "phrase"),
    6: .same(proto: "userMedals"),
    7: .same(proto: "content"),
  ]

  fileprivate class _StorageClass {
    var _user: STUserInChannel? = nil
    var _pendant: STDressUpInfo? = nil
    var _bubble: STDressUpInfo? = nil
    var _avatarFrame: STDressUpInfo? = nil
    var _phrase: STPhraseInfo? = nil
    var _userMedals: [STMedalInfo] = []
    var _content: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _pendant = source._pendant
      _bubble = source._bubble
      _avatarFrame = source._avatarFrame
      _phrase = source._phrase
      _userMedals = source._userMedals
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._pendant) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bubble) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._avatarFrame) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._phrase) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._userMedals) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pendant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._bubble {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._avatarFrame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._phrase {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._userMedals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userMedals, fieldNumber: 6)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelChatNotification, rhs: STChannelChatNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._pendant != rhs_storage._pendant {return false}
        if _storage._bubble != rhs_storage._bubble {return false}
        if _storage._avatarFrame != rhs_storage._avatarFrame {return false}
        if _storage._phrase != rhs_storage._phrase {return false}
        if _storage._userMedals != rhs_storage._userMedals {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCinemaOperationNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CinemaOperationNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "operator"),
    3: .same(proto: "snapshot"),
    4: .same(proto: "favorite"),
  ]

  fileprivate class _StorageClass {
    var _operation: STMediaPlayerOperation = .operationPlay
    var _operator: STUserInChannel? = nil
    var _snapshot: STCinemaSnapshot? = nil
    var _favorite: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _operation = source._operation
      _operator = source._operator
      _snapshot = source._snapshot
      _favorite = source._favorite
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._operation) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._operator) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._snapshot) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._favorite) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._operation != .operationPlay {
        try visitor.visitSingularEnumField(value: _storage._operation, fieldNumber: 1)
      }
      try { if let v = _storage._operator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._snapshot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._favorite != 0 {
        try visitor.visitSingularInt32Field(value: _storage._favorite, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCinemaOperationNotification, rhs: STCinemaOperationNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._snapshot != rhs_storage._snapshot {return false}
        if _storage._favorite != rhs_storage._favorite {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STNotifySwitch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NotifySwitch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gift"),
    2: .same(proto: "activity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.gift) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.activity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gift != 0 {
      try visitor.visitSingularInt32Field(value: self.gift, fieldNumber: 1)
    }
    if self.activity != 0 {
      try visitor.visitSingularInt32Field(value: self.activity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STNotifySwitch, rhs: STNotifySwitch) -> Bool {
    if lhs.gift != rhs.gift {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMiniGameSwitch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MiniGameSwitch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuid"),
    2: .same(proto: "enable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.enable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuid != 0 {
      try visitor.visitSingularInt32Field(value: self.menuid, fieldNumber: 1)
    }
    if self.enable != 0 {
      try visitor.visitSingularInt32Field(value: self.enable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMiniGameSwitch, rhs: STMiniGameSwitch) -> Bool {
    if lhs.menuid != rhs.menuid {return false}
    if lhs.enable != rhs.enable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Family"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
    2: .same(proto: "ownerAccountId"),
    3: .same(proto: "memberCount"),
    4: .same(proto: "channelCount"),
    5: .same(proto: "id"),
    6: .same(proto: "familyId"),
    7: .same(proto: "ownerId"),
    8: .same(proto: "avatarUrl"),
    9: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.ownerAccountID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.memberCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.channelCount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.familyID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    if self.ownerAccountID != 0 {
      try visitor.visitSingularInt32Field(value: self.ownerAccountID, fieldNumber: 2)
    }
    if self.memberCount != 0 {
      try visitor.visitSingularInt32Field(value: self.memberCount, fieldNumber: 3)
    }
    if self.channelCount != 0 {
      try visitor.visitSingularInt32Field(value: self.channelCount, fieldNumber: 4)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 5)
    }
    if !self.familyID.isEmpty {
      try visitor.visitSingularStringField(value: self.familyID, fieldNumber: 6)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 7)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 8)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFamily, rhs: STFamily) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.ownerAccountID != rhs.ownerAccountID {return false}
    if lhs.memberCount != rhs.memberCount {return false}
    if lhs.channelCount != rhs.channelCount {return false}
    if lhs.id != rhs.id {return false}
    if lhs.familyID != rhs.familyID {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChatChannelVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatChannelVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ownerAccountId"),
    2: .same(proto: "status"),
    3: .same(proto: "pkStatus"),
    4: .same(proto: "pkActive"),
    5: .same(proto: "lockedStatus"),
    6: .same(proto: "totalValue"),
    7: .same(proto: "ratedFalseNumber"),
    8: .same(proto: "fixedFalseNumber"),
    9: .same(proto: "ranking"),
    10: .same(proto: "channelName"),
    11: .same(proto: "channelType"),
    12: .same(proto: "ownerId"),
    13: .same(proto: "avatarUrl"),
    14: .same(proto: "gameName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ownerAccountID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.status) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pkStatus) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pkActive) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.totalValue) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.ratedFalseNumber) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.fixedFalseNumber) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.ranking) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.channelType) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.gameName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ownerAccountID != 0 {
      try visitor.visitSingularInt32Field(value: self.ownerAccountID, fieldNumber: 1)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 2)
    }
    if self.pkStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.pkStatus, fieldNumber: 3)
    }
    if self.pkActive != 0 {
      try visitor.visitSingularInt32Field(value: self.pkActive, fieldNumber: 4)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 5)
    }
    if self.totalValue != 0 {
      try visitor.visitSingularInt32Field(value: self.totalValue, fieldNumber: 6)
    }
    if self.ratedFalseNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.ratedFalseNumber, fieldNumber: 7)
    }
    if self.fixedFalseNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.fixedFalseNumber, fieldNumber: 8)
    }
    if self.ranking != 0 {
      try visitor.visitSingularInt32Field(value: self.ranking, fieldNumber: 9)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 10)
    }
    if !self.channelType.isEmpty {
      try visitor.visitSingularStringField(value: self.channelType, fieldNumber: 11)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 12)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 13)
    }
    if !self.gameName.isEmpty {
      try visitor.visitSingularStringField(value: self.gameName, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChatChannelVo, rhs: STChatChannelVo) -> Bool {
    if lhs.ownerAccountID != rhs.ownerAccountID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.pkStatus != rhs.pkStatus {return false}
    if lhs.pkActive != rhs.pkActive {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.totalValue != rhs.totalValue {return false}
    if lhs.ratedFalseNumber != rhs.ratedFalseNumber {return false}
    if lhs.fixedFalseNumber != rhs.fixedFalseNumber {return false}
    if lhs.ranking != rhs.ranking {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gameName != rhs.gameName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChatChannelPkGameUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatChannelPkGameUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
    2: .same(proto: "gender"),
    3: .same(proto: "lovenum"),
    4: .same(proto: "type"),
    5: .same(proto: "createTime"),
    6: .same(proto: "updateTime"),
    7: .same(proto: "pkId"),
    8: .same(proto: "pkChannelId"),
    9: .same(proto: "team"),
    10: .same(proto: "userId"),
    11: .same(proto: "nickname"),
    12: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.gender) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.updateTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.pkID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.pkChannelID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.team) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    if self.gender != 0 {
      try visitor.visitSingularInt32Field(value: self.gender, fieldNumber: 2)
    }
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 3)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if self.updateTime != 0 {
      try visitor.visitSingularInt64Field(value: self.updateTime, fieldNumber: 6)
    }
    if !self.pkID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkID, fieldNumber: 7)
    }
    if !self.pkChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkChannelID, fieldNumber: 8)
    }
    if !self.team.isEmpty {
      try visitor.visitSingularStringField(value: self.team, fieldNumber: 9)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 10)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 11)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChatChannelPkGameUser, rhs: STChatChannelPkGameUser) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.type != rhs.type {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.updateTime != rhs.updateTime {return false}
    if lhs.pkID != rhs.pkID {return false}
    if lhs.pkChannelID != rhs.pkChannelID {return false}
    if lhs.team != rhs.team {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STPkGameBossUserVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PkGameBossUserVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
    2: .same(proto: "value"),
    3: .same(proto: "userId"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "nickname"),
    6: .same(proto: "team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.team) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 5)
    }
    if !self.team.isEmpty {
      try visitor.visitSingularStringField(value: self.team, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STPkGameBossUserVo, rhs: STPkGameBossUserVo) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.value != rhs.value {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.team != rhs.team {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChatChannelPkGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatChannelPkGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkRoundId"),
    2: .same(proto: "channelId"),
    3: .same(proto: "targetChannelId"),
    4: .same(proto: "topic"),
    5: .same(proto: "type"),
    6: .same(proto: "duration"),
    7: .same(proto: "redTeamScore"),
    8: .same(proto: "blueTeamScore"),
    9: .same(proto: "createTime"),
    10: .same(proto: "endTime"),
    11: .same(proto: "status"),
    12: .same(proto: "updateTime"),
    13: .same(proto: "systemTime"),
    14: .same(proto: "redChannelInfo"),
    15: .same(proto: "blueChannelInfo"),
    16: .same(proto: "participants"),
    17: .same(proto: "blueParticipants"),
    18: .same(proto: "pkBossUsers"),
    19: .same(proto: "bluePkBossUsers"),
  ]

  fileprivate class _StorageClass {
    var _pkRoundID: String = String()
    var _channelID: String = String()
    var _targetChannelID: String = String()
    var _topic: String = String()
    var _type: Int32 = 0
    var _duration: Int32 = 0
    var _redTeamScore: Int32 = 0
    var _blueTeamScore: Int32 = 0
    var _createTime: Int64 = 0
    var _endTime: Int64 = 0
    var _status: Int32 = 0
    var _updateTime: Int64 = 0
    var _systemTime: Int64 = 0
    var _redChannelInfo: STChatChannelVo? = nil
    var _blueChannelInfo: STChatChannelVo? = nil
    var _participants: [STChatChannelPkGameUser] = []
    var _blueParticipants: [STChatChannelPkGameUser] = []
    var _pkBossUsers: [STPkGameBossUserVo] = []
    var _bluePkBossUsers: [STPkGameBossUserVo] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _pkRoundID = source._pkRoundID
      _channelID = source._channelID
      _targetChannelID = source._targetChannelID
      _topic = source._topic
      _type = source._type
      _duration = source._duration
      _redTeamScore = source._redTeamScore
      _blueTeamScore = source._blueTeamScore
      _createTime = source._createTime
      _endTime = source._endTime
      _status = source._status
      _updateTime = source._updateTime
      _systemTime = source._systemTime
      _redChannelInfo = source._redChannelInfo
      _blueChannelInfo = source._blueChannelInfo
      _participants = source._participants
      _blueParticipants = source._blueParticipants
      _pkBossUsers = source._pkBossUsers
      _bluePkBossUsers = source._bluePkBossUsers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._pkRoundID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._targetChannelID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._type) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._redTeamScore) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._blueTeamScore) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._endTime) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._updateTime) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._systemTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._redChannelInfo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._blueChannelInfo) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._participants) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._blueParticipants) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._pkBossUsers) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._bluePkBossUsers) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._pkRoundID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pkRoundID, fieldNumber: 1)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 2)
      }
      if !_storage._targetChannelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetChannelID, fieldNumber: 3)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._topic, fieldNumber: 4)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt32Field(value: _storage._type, fieldNumber: 5)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 6)
      }
      if _storage._redTeamScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._redTeamScore, fieldNumber: 7)
      }
      if _storage._blueTeamScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blueTeamScore, fieldNumber: 8)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 9)
      }
      if _storage._endTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._endTime, fieldNumber: 10)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 11)
      }
      if _storage._updateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._updateTime, fieldNumber: 12)
      }
      if _storage._systemTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._systemTime, fieldNumber: 13)
      }
      try { if let v = _storage._redChannelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._blueChannelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._participants, fieldNumber: 16)
      }
      if !_storage._blueParticipants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blueParticipants, fieldNumber: 17)
      }
      if !_storage._pkBossUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pkBossUsers, fieldNumber: 18)
      }
      if !_storage._bluePkBossUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bluePkBossUsers, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChatChannelPkGame, rhs: STChatChannelPkGame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pkRoundID != rhs_storage._pkRoundID {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._targetChannelID != rhs_storage._targetChannelID {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._redTeamScore != rhs_storage._redTeamScore {return false}
        if _storage._blueTeamScore != rhs_storage._blueTeamScore {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._systemTime != rhs_storage._systemTime {return false}
        if _storage._redChannelInfo != rhs_storage._redChannelInfo {return false}
        if _storage._blueChannelInfo != rhs_storage._blueChannelInfo {return false}
        if _storage._participants != rhs_storage._participants {return false}
        if _storage._blueParticipants != rhs_storage._blueParticipants {return false}
        if _storage._pkBossUsers != rhs_storage._pkBossUsers {return false}
        if _storage._bluePkBossUsers != rhs_storage._bluePkBossUsers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "cinemaSnapshot"),
    3: .same(proto: "userInSeats"),
    4: .same(proto: "onlineNumber"),
    5: .same(proto: "falseOnlineNumber"),
    9: .same(proto: "channelId"),
    10: .same(proto: "boxGame"),
    11: .same(proto: "commonCapsuleToys"),
    12: .same(proto: "diamondCapsuleToys"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _cinemaSnapshot: STCinemaSnapshot? = nil
    var _userInSeats: [STUserInChannel] = []
    var _onlineNumber: Int32 = 0
    var _falseOnlineNumber: Int32 = 0
    var _channelID: String = String()
    var _boxGame: STBoxGame? = nil
    var _commonCapsuleToys: STBoxGame? = nil
    var _diamondCapsuleToys: STBoxGame? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _cinemaSnapshot = source._cinemaSnapshot
      _userInSeats = source._userInSeats
      _onlineNumber = source._onlineNumber
      _falseOnlineNumber = source._falseOnlineNumber
      _channelID = source._channelID
      _boxGame = source._boxGame
      _commonCapsuleToys = source._commonCapsuleToys
      _diamondCapsuleToys = source._diamondCapsuleToys
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cinemaSnapshot) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._userInSeats) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._onlineNumber) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._falseOnlineNumber) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._boxGame) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._commonCapsuleToys) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._diamondCapsuleToys) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      try { if let v = _storage._cinemaSnapshot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._userInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._userInSeats, fieldNumber: 3)
      }
      if _storage._onlineNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._onlineNumber, fieldNumber: 4)
      }
      if _storage._falseOnlineNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._falseOnlineNumber, fieldNumber: 5)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 9)
      }
      try { if let v = _storage._boxGame {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._commonCapsuleToys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._diamondCapsuleToys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelSnapshot, rhs: STChannelSnapshot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._cinemaSnapshot != rhs_storage._cinemaSnapshot {return false}
        if _storage._userInSeats != rhs_storage._userInSeats {return false}
        if _storage._onlineNumber != rhs_storage._onlineNumber {return false}
        if _storage._falseOnlineNumber != rhs_storage._falseOnlineNumber {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._boxGame != rhs_storage._boxGame {return false}
        if _storage._commonCapsuleToys != rhs_storage._commonCapsuleToys {return false}
        if _storage._diamondCapsuleToys != rhs_storage._diamondCapsuleToys {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STVideoExtraInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "VideoExtraInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "video480Url"),
    3: .same(proto: "video720Url"),
    4: .same(proto: "video1080Url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.video480URL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.video720URL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.video1080URL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.video480URL.isEmpty {
      try visitor.visitSingularStringField(value: self.video480URL, fieldNumber: 2)
    }
    if !self.video720URL.isEmpty {
      try visitor.visitSingularStringField(value: self.video720URL, fieldNumber: 3)
    }
    if !self.video1080URL.isEmpty {
      try visitor.visitSingularStringField(value: self.video1080URL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STVideoExtraInfo, rhs: STVideoExtraInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.video480URL != rhs.video480URL {return false}
    if lhs.video720URL != rhs.video720URL {return false}
    if lhs.video1080URL != rhs.video1080URL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCinemaSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CinemaSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "channelId"),
    3: .same(proto: "videoId"),
    4: .same(proto: "state"),
    5: .same(proto: "position"),
    6: .same(proto: "syncInterval"),
    7: .same(proto: "speed"),
    8: .same(proto: "extraInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.videoID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.position) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.syncInterval) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.speed) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._extraInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if self.videoID != 0 {
      try visitor.visitSingularInt64Field(value: self.videoID, fieldNumber: 3)
    }
    if self.state != .stop {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.position != 0 {
      try visitor.visitSingularInt64Field(value: self.position, fieldNumber: 5)
    }
    if self.syncInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.syncInterval, fieldNumber: 6)
    }
    if self.speed != 0 {
      try visitor.visitSingularInt32Field(value: self.speed, fieldNumber: 7)
    }
    try { if let v = self._extraInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCinemaSnapshot, rhs: STCinemaSnapshot) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.videoID != rhs.videoID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.position != rhs.position {return false}
    if lhs.syncInterval != rhs.syncInterval {return false}
    if lhs.speed != rhs.speed {return false}
    if lhs._extraInfo != rhs._extraInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STDataRefreshNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DataRefreshNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .remindFirstRecharge {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STDataRefreshNotification, rhs: STDataRefreshNotification) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STGiftEffect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GiftEffect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderExpressionId"),
    2: .same(proto: "acceptExpressionId"),
    3: .same(proto: "interactionType"),
    4: .same(proto: "effectName"),
    5: .same(proto: "sendVFX"),
    6: .same(proto: "acceptVFX"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.senderExpressionID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.acceptExpressionID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.interactionType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.effectName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.sendVfx) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.acceptVfx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.senderExpressionID != 0 {
      try visitor.visitSingularInt32Field(value: self.senderExpressionID, fieldNumber: 1)
    }
    if self.acceptExpressionID != 0 {
      try visitor.visitSingularInt32Field(value: self.acceptExpressionID, fieldNumber: 2)
    }
    if self.interactionType != 0 {
      try visitor.visitSingularInt32Field(value: self.interactionType, fieldNumber: 3)
    }
    if !self.effectName.isEmpty {
      try visitor.visitSingularStringField(value: self.effectName, fieldNumber: 4)
    }
    if self.sendVfx != 0 {
      try visitor.visitSingularInt32Field(value: self.sendVfx, fieldNumber: 5)
    }
    if self.acceptVfx != 0 {
      try visitor.visitSingularInt32Field(value: self.acceptVfx, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STGiftEffect, rhs: STGiftEffect) -> Bool {
    if lhs.senderExpressionID != rhs.senderExpressionID {return false}
    if lhs.acceptExpressionID != rhs.acceptExpressionID {return false}
    if lhs.interactionType != rhs.interactionType {return false}
    if lhs.effectName != rhs.effectName {return false}
    if lhs.sendVfx != rhs.sendVfx {return false}
    if lhs.acceptVfx != rhs.acceptVfx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STAnimationEffect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AnimationEffect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "effectsUrl"),
    2: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.effectsURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.effectsURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectsURL, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STAnimationEffect, rhs: STAnimationEffect) -> Bool {
    if lhs.effectsURL != rhs.effectsURL {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STH5Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "H5Module"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "dialogInfo"),
    3: .same(proto: "iconInfo"),
    4: .same(proto: "destroyPreviousDialog"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dialogInfo) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.iconInfo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.destroyPreviousDialog) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.dialogInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dialogInfo, fieldNumber: 2)
    }
    if !self.iconInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iconInfo, fieldNumber: 3)
    }
    if self.destroyPreviousDialog != false {
      try visitor.visitSingularBoolField(value: self.destroyPreviousDialog, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STH5Module, rhs: STH5Module) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.dialogInfo != rhs.dialogInfo {return false}
    if lhs.iconInfo != rhs.iconInfo {return false}
    if lhs.destroyPreviousDialog != rhs.destroyPreviousDialog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STActivityDialogInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ActivityDialogInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "h5Url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.h5URL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.h5URL.isEmpty {
      try visitor.visitSingularStringField(value: self.h5URL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STActivityDialogInfo, rhs: STActivityDialogInfo) -> Bool {
    if lhs.h5URL != rhs.h5URL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STActivityIconInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ActivityIconInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "showTip"),
    2: .same(proto: "tipIId"),
    3: .same(proto: "tipContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.showTip) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.tipIid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tipContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.showTip != false {
      try visitor.visitSingularBoolField(value: self.showTip, fieldNumber: 1)
    }
    if self.tipIid != 0 {
      try visitor.visitSingularInt64Field(value: self.tipIid, fieldNumber: 2)
    }
    if !self.tipContent.isEmpty {
      try visitor.visitSingularStringField(value: self.tipContent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STActivityIconInfo, rhs: STActivityIconInfo) -> Bool {
    if lhs.showTip != rhs.showTip {return false}
    if lhs.tipIid != rhs.tipIid {return false}
    if lhs.tipContent != rhs.tipContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
