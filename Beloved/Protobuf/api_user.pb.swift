// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_user.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 粉丝团-徽章操作类型
public enum OSFansOperateType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 佩戴徽章
  case wearing // = 0

  /// 卸下徽章
  case removing // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .wearing
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .wearing
    case 1: self = .removing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .wearing: return 0
    case .removing: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSFansOperateType] = [
    .wearing,
    .removing,
  ]

}

/// 粉丝团-排行榜类型
public enum OSFansRanksType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 全部
  case fansRange0 // = 0

  /// 日榜
  case fansRange1 // = 1

  /// 周榜
  case fansRange2 // = 2

  /// 月榜
  case fansRange3 // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .fansRange0
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fansRange0
    case 1: self = .fansRange1
    case 2: self = .fansRange2
    case 3: self = .fansRange3
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fansRange0: return 0
    case .fansRange1: return 1
    case .fansRange2: return 2
    case .fansRange3: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSFansRanksType] = [
    .fansRange0,
    .fansRange1,
    .fansRange2,
    .fansRange3,
  ]

}

/// 用户相关请求
public struct OSUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSUserRequest.OneOf_Body? = nil

  /// 登录请求
  public var loginReq: OSLoginReq {
    get {
      if case .loginReq(let v)? = body {return v}
      return OSLoginReq()
    }
    set {body = .loginReq(newValue)}
  }

  /// 查看用户个人信息请求
  public var viewReq: OSViewReq {
    get {
      if case .viewReq(let v)? = body {return v}
      return OSViewReq()
    }
    set {body = .viewReq(newValue)}
  }

  /// 编辑用户信息请求
  public var editUserReq: OSEditUserReq {
    get {
      if case .editUserReq(let v)? = body {return v}
      return OSEditUserReq()
    }
    set {body = .editUserReq(newValue)}
  }

  /// 查看用户照片墙请求
  public var userPhotoReq: OSUserPhotoReq {
    get {
      if case .userPhotoReq(let v)? = body {return v}
      return OSUserPhotoReq()
    }
    set {body = .userPhotoReq(newValue)}
  }

  /// 上传(单张)照片墙请求
  public var uploadPhotoReq: OSUploadPhotoReq {
    get {
      if case .uploadPhotoReq(let v)? = body {return v}
      return OSUploadPhotoReq()
    }
    set {body = .uploadPhotoReq(newValue)}
  }

  /// 上传(多张)照片墙请求
  public var uploadPhotoListReq: OSUploadPhotoListReq {
    get {
      if case .uploadPhotoListReq(let v)? = body {return v}
      return OSUploadPhotoListReq()
    }
    set {body = .uploadPhotoListReq(newValue)}
  }

  /// 删除(单张)照片墙请求
  public var deletePhotoReq: OSDeletePhotoReq {
    get {
      if case .deletePhotoReq(let v)? = body {return v}
      return OSDeletePhotoReq()
    }
    set {body = .deletePhotoReq(newValue)}
  }

  /// 删除(多张)照片墙请求
  public var deletePhotoListReq: OSDeletePhotoListReq {
    get {
      if case .deletePhotoListReq(let v)? = body {return v}
      return OSDeletePhotoListReq()
    }
    set {body = .deletePhotoListReq(newValue)}
  }

  /// 获取签到信息请求
  public var signinInfoReq: OSSigninInfoReq {
    get {
      if case .signinInfoReq(let v)? = body {return v}
      return OSSigninInfoReq()
    }
    set {body = .signinInfoReq(newValue)}
  }

  /// 用户签到请求
  public var userSigninReq: OSUserSigninReq {
    get {
      if case .userSigninReq(let v)? = body {return v}
      return OSUserSigninReq()
    }
    set {body = .userSigninReq(newValue)}
  }

  /// 获取装扮标签请求
  public var dressUpTagsReq: OSDressUpTagsReq {
    get {
      if case .dressUpTagsReq(let v)? = body {return v}
      return OSDressUpTagsReq()
    }
    set {body = .dressUpTagsReq(newValue)}
  }

  /// 获取用户装扮请求
  public var userDressUpReq: OSUserDressUpReq {
    get {
      if case .userDressUpReq(let v)? = body {return v}
      return OSUserDressUpReq()
    }
    set {body = .userDressUpReq(newValue)}
  }

  /// 装扮操作请求
  public var dressUpOperateReq: OSDressUpOperateReq {
    get {
      if case .dressUpOperateReq(let v)? = body {return v}
      return OSDressUpOperateReq()
    }
    set {body = .dressUpOperateReq(newValue)}
  }

  /// 获取用户礼物墙请求
  public var userGiftWallReq: OSUserGiftWallReq {
    get {
      if case .userGiftWallReq(let v)? = body {return v}
      return OSUserGiftWallReq()
    }
    set {body = .userGiftWallReq(newValue)}
  }

  /// 查看用户收礼/送礼请求
  public var giftDetailsReq: OSGiftDetailsReq {
    get {
      if case .giftDetailsReq(let v)? = body {return v}
      return OSGiftDetailsReq()
    }
    set {body = .giftDetailsReq(newValue)}
  }

  /// 用户最近访问房间请求
  public var lastJoinChannelReq: OSLastJoinChannelReq {
    get {
      if case .lastJoinChannelReq(let v)? = body {return v}
      return OSLastJoinChannelReq()
    }
    set {body = .lastJoinChannelReq(newValue)}
  }

  /// 获取账户安全等级信息请求
  public var accountSecurityReq: OSAccountSecurityReq {
    get {
      if case .accountSecurityReq(let v)? = body {return v}
      return OSAccountSecurityReq()
    }
    set {body = .accountSecurityReq(newValue)}
  }

  /// 获取第三方绑定的账号列表请求
  public var thirdPartyAccountReq: OSThirdPartyAccountReq {
    get {
      if case .thirdPartyAccountReq(let v)? = body {return v}
      return OSThirdPartyAccountReq()
    }
    set {body = .thirdPartyAccountReq(newValue)}
  }

  /// 绑定手机请求
  public var bindMobileReq: OSBindMobileReq {
    get {
      if case .bindMobileReq(let v)? = body {return v}
      return OSBindMobileReq()
    }
    set {body = .bindMobileReq(newValue)}
  }

  /// 开启/关闭/校验青少年模式密码请求
  public var adolescentSettingReq: OSAdolescentSettingReq {
    get {
      if case .adolescentSettingReq(let v)? = body {return v}
      return OSAdolescentSettingReq()
    }
    set {body = .adolescentSettingReq(newValue)}
  }

  /// 用户实名认证请求
  public var authenticationReq: OSAuthenticationReq {
    get {
      if case .authenticationReq(let v)? = body {return v}
      return OSAuthenticationReq()
    }
    set {body = .authenticationReq(newValue)}
  }

  /// 设置密码请求
  public var settingPasswordReq: OSSettingPasswordReq {
    get {
      if case .settingPasswordReq(let v)? = body {return v}
      return OSSettingPasswordReq()
    }
    set {body = .settingPasswordReq(newValue)}
  }

  /// 修改密码请求
  public var updatePasswordReq: OSUpdatePasswordReq {
    get {
      if case .updatePasswordReq(let v)? = body {return v}
      return OSUpdatePasswordReq()
    }
    set {body = .updatePasswordReq(newValue)}
  }

  /// 重置密码请求
  public var resetPasswordReq: OSResetPasswordReq {
    get {
      if case .resetPasswordReq(let v)? = body {return v}
      return OSResetPasswordReq()
    }
    set {body = .resetPasswordReq(newValue)}
  }

  /// 实名认证验证绑定手机号码请求
  public var authenticationVerifyMobileReq: OSAuthenticationVerifyMobileReq {
    get {
      if case .authenticationVerifyMobileReq(let v)? = body {return v}
      return OSAuthenticationVerifyMobileReq()
    }
    set {body = .authenticationVerifyMobileReq(newValue)}
  }

  /// 绑定手机验证原手机号请求
  public var bindVerifyMobileReq: OSBindVerifyMobileReq {
    get {
      if case .bindVerifyMobileReq(let v)? = body {return v}
      return OSBindVerifyMobileReq()
    }
    set {body = .bindVerifyMobileReq(newValue)}
  }

  /// 关注用户请求
  public var followReq: OSFollowReq {
    get {
      if case .followReq(let v)? = body {return v}
      return OSFollowReq()
    }
    set {body = .followReq(newValue)}
  }

  /// 取消关注请求
  public var unfollowReq: OSUnfollowReq {
    get {
      if case .unfollowReq(let v)? = body {return v}
      return OSUnfollowReq()
    }
    set {body = .unfollowReq(newValue)}
  }

  /// 退出登录请求
  public var logoutReq: OSLogoutReq {
    get {
      if case .logoutReq(let v)? = body {return v}
      return OSLogoutReq()
    }
    set {body = .logoutReq(newValue)}
  }

  /// 举报用户/房间请求
  public var reportReq: OSReportReq {
    get {
      if case .reportReq(let v)? = body {return v}
      return OSReportReq()
    }
    set {body = .reportReq(newValue)}
  }

  /// 加入黑名单请求
  public var joinBlacklistReq: OSJoinBlacklistReq {
    get {
      if case .joinBlacklistReq(let v)? = body {return v}
      return OSJoinBlacklistReq()
    }
    set {body = .joinBlacklistReq(newValue)}
  }

  /// 移除黑名单请求
  public var removeBlacklistReq: OSRemoveBlacklistReq {
    get {
      if case .removeBlacklistReq(let v)? = body {return v}
      return OSRemoveBlacklistReq()
    }
    set {body = .removeBlacklistReq(newValue)}
  }

  /// 关注列表请求
  public var followingsListReq: OSFollowingsListReq {
    get {
      if case .followingsListReq(let v)? = body {return v}
      return OSFollowingsListReq()
    }
    set {body = .followingsListReq(newValue)}
  }

  /// 粉丝列表请求
  public var followersListReq: OSFollowersListReq {
    get {
      if case .followersListReq(let v)? = body {return v}
      return OSFollowersListReq()
    }
    set {body = .followersListReq(newValue)}
  }

  /// 用户反馈请求
  public var userFeedbackReq: OSUserFeedbackReq {
    get {
      if case .userFeedbackReq(let v)? = body {return v}
      return OSUserFeedbackReq()
    }
    set {body = .userFeedbackReq(newValue)}
  }

  /// 搜索请求
  public var searchReq: OSSearchReq {
    get {
      if case .searchReq(let v)? = body {return v}
      return OSSearchReq()
    }
    set {body = .searchReq(newValue)}
  }

  /// 获取注册头像请求
  public var signInAvatarReq: OSSignInAvatarReq {
    get {
      if case .signInAvatarReq(let v)? = body {return v}
      return OSSignInAvatarReq()
    }
    set {body = .signInAvatarReq(newValue)}
  }

  /// 用户钱包请求
  public var userWalletReq: OSUserWalletReq {
    get {
      if case .userWalletReq(let v)? = body {return v}
      return OSUserWalletReq()
    }
    set {body = .userWalletReq(newValue)}
  }

  /// 身份证识别请求
  public var idCardRecognitionReq: OSIdCardRecognitionReq {
    get {
      if case .idCardRecognitionReq(let v)? = body {return v}
      return OSIdCardRecognitionReq()
    }
    set {body = .idCardRecognitionReq(newValue)}
  }

  /// 用户注销请求
  public var logoffReq: OSLogoffReq {
    get {
      if case .logoffReq(let v)? = body {return v}
      return OSLogoffReq()
    }
    set {body = .logoffReq(newValue)}
  }

  /// 用户勋章列表请求
  public var userMedalListReq: OSUserMedalListReq {
    get {
      if case .userMedalListReq(let v)? = body {return v}
      return OSUserMedalListReq()
    }
    set {body = .userMedalListReq(newValue)}
  }

  /// 装扮商城列表请求
  public var dressUpMallReq: OSDressUpMallReq {
    get {
      if case .dressUpMallReq(let v)? = body {return v}
      return OSDressUpMallReq()
    }
    set {body = .dressUpMallReq(newValue)}
  }

  /// 购买装扮请求
  public var buyDressUpReq: OSBuyDressUpReq {
    get {
      if case .buyDressUpReq(let v)? = body {return v}
      return OSBuyDressUpReq()
    }
    set {body = .buyDressUpReq(newValue)}
  }

  /// 邀请码、补码请求
  public var inviteReq: OSInviteReq {
    get {
      if case .inviteReq(let v)? = body {return v}
      return OSInviteReq()
    }
    set {body = .inviteReq(newValue)}
  }

  /// 赠送装扮请求
  public var giveDressUpReq: OSGiveDressUpReq {
    get {
      if case .giveDressUpReq(let v)? = body {return v}
      return OSGiveDressUpReq()
    }
    set {body = .giveDressUpReq(newValue)}
  }

  /// 好友列表请求
  public var myFriendsReq: OSMyFriendsReq {
    get {
      if case .myFriendsReq(let v)? = body {return v}
      return OSMyFriendsReq()
    }
    set {body = .myFriendsReq(newValue)}
  }

  /// 访客记录
  public var visitRecordReq: OSVisitRecordReq {
    get {
      if case .visitRecordReq(let v)? = body {return v}
      return OSVisitRecordReq()
    }
    set {body = .visitRecordReq(newValue)}
  }

  ///幻灵操作
  public var eidolonOperationReq: OSEidolonOperationReq {
    get {
      if case .eidolonOperationReq(let v)? = body {return v}
      return OSEidolonOperationReq()
    }
    set {body = .eidolonOperationReq(newValue)}
  }

  /// 黑名单列表
  public var loadBlacklistReq: OSLoadBlacklistReq {
    get {
      if case .loadBlacklistReq(let v)? = body {return v}
      return OSLoadBlacklistReq()
    }
    set {body = .loadBlacklistReq(newValue)}
  }

  /// 贵宾卡列表请求
  public var honouredGuestCardsReq: OSHonouredGuestCardsReq {
    get {
      if case .honouredGuestCardsReq(let v)? = body {return v}
      return OSHonouredGuestCardsReq()
    }
    set {body = .honouredGuestCardsReq(newValue)}
  }

  /// 粉丝团徽章列表请求
  public var fansClubBadgesReq: OSFansClubBadgesReq {
    get {
      if case .fansClubBadgesReq(let v)? = body {return v}
      return OSFansClubBadgesReq()
    }
    set {body = .fansClubBadgesReq(newValue)}
  }

  /// 粉丝团-佩戴或卸下徽章请求
  public var wearAndRemoveBadgeReq: OSWearAndRemoveBadgeReq {
    get {
      if case .wearAndRemoveBadgeReq(let v)? = body {return v}
      return OSWearAndRemoveBadgeReq()
    }
    set {body = .wearAndRemoveBadgeReq(newValue)}
  }

  /// 粉丝团-粉丝榜请求
  public var fansClubRanksReq: OSFansClubRanksReq {
    get {
      if case .fansClubRanksReq(let v)? = body {return v}
      return OSFansClubRanksReq()
    }
    set {body = .fansClubRanksReq(newValue)}
  }

  /// 粉丝团-退出粉丝团请求
  public var fansClubExitReq: OSFansClubExitReq {
    get {
      if case .fansClubExitReq(let v)? = body {return v}
      return OSFansClubExitReq()
    }
    set {body = .fansClubExitReq(newValue)}
  }

  /// 人脸认证请求
  public var faceVerifyReq: OSFaceVerifyReq {
    get {
      if case .faceVerifyReq(let v)? = body {return v}
      return OSFaceVerifyReq()
    }
    set {body = .faceVerifyReq(newValue)}
  }

  /// 人脸认证结果查询请求
  public var faceVerifyResultReq: OSFaceVerifyResultReq {
    get {
      if case .faceVerifyResultReq(let v)? = body {return v}
      return OSFaceVerifyResultReq()
    }
    set {body = .faceVerifyResultReq(newValue)}
  }

  /// 声音介绍 换一换请求
  public var userVoiceDialogueReportReq: OSUserVoiceDialogueReportReq {
    get {
      if case .userVoiceDialogueReportReq(let v)? = body {return v}
      return OSUserVoiceDialogueReportReq()
    }
    set {body = .userVoiceDialogueReportReq(newValue)}
  }

  /// 删除声音介绍请求
  public var userVoiceSoftDeleteReq: OSUserVoiceSoftDeleteReq {
    get {
      if case .userVoiceSoftDeleteReq(let v)? = body {return v}
      return OSUserVoiceSoftDeleteReq()
    }
    set {body = .userVoiceSoftDeleteReq(newValue)}
  }

  /// 提交审核请求
  public var userVoiceSubmitReq: OSUserVoiceSubmitReq {
    get {
      if case .userVoiceSubmitReq(let v)? = body {return v}
      return OSUserVoiceSubmitReq()
    }
    set {body = .userVoiceSubmitReq(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 登录请求
    case loginReq(OSLoginReq)
    /// 查看用户个人信息请求
    case viewReq(OSViewReq)
    /// 编辑用户信息请求
    case editUserReq(OSEditUserReq)
    /// 查看用户照片墙请求
    case userPhotoReq(OSUserPhotoReq)
    /// 上传(单张)照片墙请求
    case uploadPhotoReq(OSUploadPhotoReq)
    /// 上传(多张)照片墙请求
    case uploadPhotoListReq(OSUploadPhotoListReq)
    /// 删除(单张)照片墙请求
    case deletePhotoReq(OSDeletePhotoReq)
    /// 删除(多张)照片墙请求
    case deletePhotoListReq(OSDeletePhotoListReq)
    /// 获取签到信息请求
    case signinInfoReq(OSSigninInfoReq)
    /// 用户签到请求
    case userSigninReq(OSUserSigninReq)
    /// 获取装扮标签请求
    case dressUpTagsReq(OSDressUpTagsReq)
    /// 获取用户装扮请求
    case userDressUpReq(OSUserDressUpReq)
    /// 装扮操作请求
    case dressUpOperateReq(OSDressUpOperateReq)
    /// 获取用户礼物墙请求
    case userGiftWallReq(OSUserGiftWallReq)
    /// 查看用户收礼/送礼请求
    case giftDetailsReq(OSGiftDetailsReq)
    /// 用户最近访问房间请求
    case lastJoinChannelReq(OSLastJoinChannelReq)
    /// 获取账户安全等级信息请求
    case accountSecurityReq(OSAccountSecurityReq)
    /// 获取第三方绑定的账号列表请求
    case thirdPartyAccountReq(OSThirdPartyAccountReq)
    /// 绑定手机请求
    case bindMobileReq(OSBindMobileReq)
    /// 开启/关闭/校验青少年模式密码请求
    case adolescentSettingReq(OSAdolescentSettingReq)
    /// 用户实名认证请求
    case authenticationReq(OSAuthenticationReq)
    /// 设置密码请求
    case settingPasswordReq(OSSettingPasswordReq)
    /// 修改密码请求
    case updatePasswordReq(OSUpdatePasswordReq)
    /// 重置密码请求
    case resetPasswordReq(OSResetPasswordReq)
    /// 实名认证验证绑定手机号码请求
    case authenticationVerifyMobileReq(OSAuthenticationVerifyMobileReq)
    /// 绑定手机验证原手机号请求
    case bindVerifyMobileReq(OSBindVerifyMobileReq)
    /// 关注用户请求
    case followReq(OSFollowReq)
    /// 取消关注请求
    case unfollowReq(OSUnfollowReq)
    /// 退出登录请求
    case logoutReq(OSLogoutReq)
    /// 举报用户/房间请求
    case reportReq(OSReportReq)
    /// 加入黑名单请求
    case joinBlacklistReq(OSJoinBlacklistReq)
    /// 移除黑名单请求
    case removeBlacklistReq(OSRemoveBlacklistReq)
    /// 关注列表请求
    case followingsListReq(OSFollowingsListReq)
    /// 粉丝列表请求
    case followersListReq(OSFollowersListReq)
    /// 用户反馈请求
    case userFeedbackReq(OSUserFeedbackReq)
    /// 搜索请求
    case searchReq(OSSearchReq)
    /// 获取注册头像请求
    case signInAvatarReq(OSSignInAvatarReq)
    /// 用户钱包请求
    case userWalletReq(OSUserWalletReq)
    /// 身份证识别请求
    case idCardRecognitionReq(OSIdCardRecognitionReq)
    /// 用户注销请求
    case logoffReq(OSLogoffReq)
    /// 用户勋章列表请求
    case userMedalListReq(OSUserMedalListReq)
    /// 装扮商城列表请求
    case dressUpMallReq(OSDressUpMallReq)
    /// 购买装扮请求
    case buyDressUpReq(OSBuyDressUpReq)
    /// 邀请码、补码请求
    case inviteReq(OSInviteReq)
    /// 赠送装扮请求
    case giveDressUpReq(OSGiveDressUpReq)
    /// 好友列表请求
    case myFriendsReq(OSMyFriendsReq)
    /// 访客记录
    case visitRecordReq(OSVisitRecordReq)
    ///幻灵操作
    case eidolonOperationReq(OSEidolonOperationReq)
    /// 黑名单列表
    case loadBlacklistReq(OSLoadBlacklistReq)
    /// 贵宾卡列表请求
    case honouredGuestCardsReq(OSHonouredGuestCardsReq)
    /// 粉丝团徽章列表请求
    case fansClubBadgesReq(OSFansClubBadgesReq)
    /// 粉丝团-佩戴或卸下徽章请求
    case wearAndRemoveBadgeReq(OSWearAndRemoveBadgeReq)
    /// 粉丝团-粉丝榜请求
    case fansClubRanksReq(OSFansClubRanksReq)
    /// 粉丝团-退出粉丝团请求
    case fansClubExitReq(OSFansClubExitReq)
    /// 人脸认证请求
    case faceVerifyReq(OSFaceVerifyReq)
    /// 人脸认证结果查询请求
    case faceVerifyResultReq(OSFaceVerifyResultReq)
    /// 声音介绍 换一换请求
    case userVoiceDialogueReportReq(OSUserVoiceDialogueReportReq)
    /// 删除声音介绍请求
    case userVoiceSoftDeleteReq(OSUserVoiceSoftDeleteReq)
    /// 提交审核请求
    case userVoiceSubmitReq(OSUserVoiceSubmitReq)

  }

  public init() {}
}

/// 用户相关响应
public struct OSUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSUserResponse.OneOf_Body? = nil

  /// 登录响应
  public var loginRes: OSLoginRes {
    get {
      if case .loginRes(let v)? = body {return v}
      return OSLoginRes()
    }
    set {body = .loginRes(newValue)}
  }

  /// 查看用户个人信息响应
  public var viewRes: OSViewRes {
    get {
      if case .viewRes(let v)? = body {return v}
      return OSViewRes()
    }
    set {body = .viewRes(newValue)}
  }

  /// 编辑用户信息响应
  public var editUserRes: OSEditUserRes {
    get {
      if case .editUserRes(let v)? = body {return v}
      return OSEditUserRes()
    }
    set {body = .editUserRes(newValue)}
  }

  /// 查看用户照片墙响应
  public var userPhotoReq: OSUserPhotoRes {
    get {
      if case .userPhotoReq(let v)? = body {return v}
      return OSUserPhotoRes()
    }
    set {body = .userPhotoReq(newValue)}
  }

  /// 上传(单张)照片墙响应
  public var uploadPhotoRes: OSUploadPhotoRes {
    get {
      if case .uploadPhotoRes(let v)? = body {return v}
      return OSUploadPhotoRes()
    }
    set {body = .uploadPhotoRes(newValue)}
  }

  /// 上传(多张)照片墙响应
  public var uploadPhotoListRes: OSUploadPhotoListRes {
    get {
      if case .uploadPhotoListRes(let v)? = body {return v}
      return OSUploadPhotoListRes()
    }
    set {body = .uploadPhotoListRes(newValue)}
  }

  /// 删除(单张)照片墙响应
  public var deletePhotoRes: OSDeletePhotoRes {
    get {
      if case .deletePhotoRes(let v)? = body {return v}
      return OSDeletePhotoRes()
    }
    set {body = .deletePhotoRes(newValue)}
  }

  /// 删除(多张)照片墙响应
  public var deletePhotoListRes: OSDeletePhotoListRes {
    get {
      if case .deletePhotoListRes(let v)? = body {return v}
      return OSDeletePhotoListRes()
    }
    set {body = .deletePhotoListRes(newValue)}
  }

  /// 获取签到信息响应
  public var signinInfoRes: OSSigninInfoRes {
    get {
      if case .signinInfoRes(let v)? = body {return v}
      return OSSigninInfoRes()
    }
    set {body = .signinInfoRes(newValue)}
  }

  /// 用户签到响应
  public var userSigninRes: OSUserSigninRes {
    get {
      if case .userSigninRes(let v)? = body {return v}
      return OSUserSigninRes()
    }
    set {body = .userSigninRes(newValue)}
  }

  /// 获取装扮标签响应
  public var dressUpTagsRes: OSDressUpTagsRes {
    get {
      if case .dressUpTagsRes(let v)? = body {return v}
      return OSDressUpTagsRes()
    }
    set {body = .dressUpTagsRes(newValue)}
  }

  /// 获取用户装扮响应
  public var userDressUpRes: OSUserDressUpRes {
    get {
      if case .userDressUpRes(let v)? = body {return v}
      return OSUserDressUpRes()
    }
    set {body = .userDressUpRes(newValue)}
  }

  /// 装扮操作响应
  public var dressUpOperateRes: OSDressUpOperateRes {
    get {
      if case .dressUpOperateRes(let v)? = body {return v}
      return OSDressUpOperateRes()
    }
    set {body = .dressUpOperateRes(newValue)}
  }

  /// 获取用户礼物墙响应
  public var userGiftWallRes: OSUserGiftWallRes {
    get {
      if case .userGiftWallRes(let v)? = body {return v}
      return OSUserGiftWallRes()
    }
    set {body = .userGiftWallRes(newValue)}
  }

  /// 查看用户收礼/送礼响应
  public var giftDetailsRes: OSGiftDetailsRes {
    get {
      if case .giftDetailsRes(let v)? = body {return v}
      return OSGiftDetailsRes()
    }
    set {body = .giftDetailsRes(newValue)}
  }

  /// 用户最近访问房间响应
  public var lastJoinChannelRes: OSLastJoinChannelRes {
    get {
      if case .lastJoinChannelRes(let v)? = body {return v}
      return OSLastJoinChannelRes()
    }
    set {body = .lastJoinChannelRes(newValue)}
  }

  /// 获取账户安全等级信息响应
  public var accountSecurityRes: OSAccountSecurityRes {
    get {
      if case .accountSecurityRes(let v)? = body {return v}
      return OSAccountSecurityRes()
    }
    set {body = .accountSecurityRes(newValue)}
  }

  /// 获取第三方绑定的账号列表响应
  public var thirdPartyAccountRes: OSThirdPartyAccountRes {
    get {
      if case .thirdPartyAccountRes(let v)? = body {return v}
      return OSThirdPartyAccountRes()
    }
    set {body = .thirdPartyAccountRes(newValue)}
  }

  /// 绑定手机响应
  public var bindMobileRes: OSBindMobileRes {
    get {
      if case .bindMobileRes(let v)? = body {return v}
      return OSBindMobileRes()
    }
    set {body = .bindMobileRes(newValue)}
  }

  /// 开启/关闭/校验青少年模式密码响应
  public var adolescentSettingRes: OSAdolescentSettingRes {
    get {
      if case .adolescentSettingRes(let v)? = body {return v}
      return OSAdolescentSettingRes()
    }
    set {body = .adolescentSettingRes(newValue)}
  }

  /// 用户实名认证响应
  public var authenticationRes: OSAuthenticationRes {
    get {
      if case .authenticationRes(let v)? = body {return v}
      return OSAuthenticationRes()
    }
    set {body = .authenticationRes(newValue)}
  }

  /// 设置密码响应
  public var settingPasswordRes: OSSettingPasswordRes {
    get {
      if case .settingPasswordRes(let v)? = body {return v}
      return OSSettingPasswordRes()
    }
    set {body = .settingPasswordRes(newValue)}
  }

  /// 修改密码响应
  public var updatePasswordRes: OSUpdatePasswordRes {
    get {
      if case .updatePasswordRes(let v)? = body {return v}
      return OSUpdatePasswordRes()
    }
    set {body = .updatePasswordRes(newValue)}
  }

  /// 重置密码响应
  public var resetPasswordRes: OSResetPasswordRes {
    get {
      if case .resetPasswordRes(let v)? = body {return v}
      return OSResetPasswordRes()
    }
    set {body = .resetPasswordRes(newValue)}
  }

  /// 实名认证验证绑定手机号码响应
  public var authenticationVerifyMobileRes: OSAuthenticationVerifyMobileRes {
    get {
      if case .authenticationVerifyMobileRes(let v)? = body {return v}
      return OSAuthenticationVerifyMobileRes()
    }
    set {body = .authenticationVerifyMobileRes(newValue)}
  }

  /// 绑定手机验证原手机号响应
  public var bindVerifyMobileRes: OSBindVerifyMobileRes {
    get {
      if case .bindVerifyMobileRes(let v)? = body {return v}
      return OSBindVerifyMobileRes()
    }
    set {body = .bindVerifyMobileRes(newValue)}
  }

  /// 关注用户响应
  public var followRes: OSFollowRes {
    get {
      if case .followRes(let v)? = body {return v}
      return OSFollowRes()
    }
    set {body = .followRes(newValue)}
  }

  /// 请求关注响应
  public var unfollowRes: OSUnfollowRes {
    get {
      if case .unfollowRes(let v)? = body {return v}
      return OSUnfollowRes()
    }
    set {body = .unfollowRes(newValue)}
  }

  /// 退出登录响应
  public var logoutRes: OSLogoutRes {
    get {
      if case .logoutRes(let v)? = body {return v}
      return OSLogoutRes()
    }
    set {body = .logoutRes(newValue)}
  }

  /// 举报用户/房间响应
  public var reportRes: OSReportRes {
    get {
      if case .reportRes(let v)? = body {return v}
      return OSReportRes()
    }
    set {body = .reportRes(newValue)}
  }

  /// 加入黑名单响应
  public var joinBlacklistRes: OSJoinBlacklistRes {
    get {
      if case .joinBlacklistRes(let v)? = body {return v}
      return OSJoinBlacklistRes()
    }
    set {body = .joinBlacklistRes(newValue)}
  }

  /// 移除黑名单响应
  public var removeBlacklistRes: OSRemoveBlacklistRes {
    get {
      if case .removeBlacklistRes(let v)? = body {return v}
      return OSRemoveBlacklistRes()
    }
    set {body = .removeBlacklistRes(newValue)}
  }

  /// 关注列表响应
  public var followingsListRes: OSFollowingsListRes {
    get {
      if case .followingsListRes(let v)? = body {return v}
      return OSFollowingsListRes()
    }
    set {body = .followingsListRes(newValue)}
  }

  /// 粉丝列表响应
  public var followersListRes: OSFollowersListRes {
    get {
      if case .followersListRes(let v)? = body {return v}
      return OSFollowersListRes()
    }
    set {body = .followersListRes(newValue)}
  }

  /// 用户反馈响应
  public var userFeedbackRes: OSUserFeedbackRes {
    get {
      if case .userFeedbackRes(let v)? = body {return v}
      return OSUserFeedbackRes()
    }
    set {body = .userFeedbackRes(newValue)}
  }

  /// 搜索响应
  public var searchRes: OSSearchRes {
    get {
      if case .searchRes(let v)? = body {return v}
      return OSSearchRes()
    }
    set {body = .searchRes(newValue)}
  }

  /// 获取注册头像响应
  public var signInAvatarRes: OSSignInAvatarRes {
    get {
      if case .signInAvatarRes(let v)? = body {return v}
      return OSSignInAvatarRes()
    }
    set {body = .signInAvatarRes(newValue)}
  }

  /// 用户钱包响应
  public var userWalletRes: OSUserWalletRes {
    get {
      if case .userWalletRes(let v)? = body {return v}
      return OSUserWalletRes()
    }
    set {body = .userWalletRes(newValue)}
  }

  /// 身份证识别响应
  public var idCardRecognitionRes: OSIdCardRecognitionRes {
    get {
      if case .idCardRecognitionRes(let v)? = body {return v}
      return OSIdCardRecognitionRes()
    }
    set {body = .idCardRecognitionRes(newValue)}
  }

  /// 用户注销响应
  public var logoffRes: OSLogoffRes {
    get {
      if case .logoffRes(let v)? = body {return v}
      return OSLogoffRes()
    }
    set {body = .logoffRes(newValue)}
  }

  /// 用户勋章列表响应
  public var userMedalListRes: OSUserMedalListRes {
    get {
      if case .userMedalListRes(let v)? = body {return v}
      return OSUserMedalListRes()
    }
    set {body = .userMedalListRes(newValue)}
  }

  /// 装扮商城列表响应
  public var dressUpMallRes: OSDressUpMallRes {
    get {
      if case .dressUpMallRes(let v)? = body {return v}
      return OSDressUpMallRes()
    }
    set {body = .dressUpMallRes(newValue)}
  }

  /// 购买装扮响应
  public var buyDressUpRes: OSBuyDressUpRes {
    get {
      if case .buyDressUpRes(let v)? = body {return v}
      return OSBuyDressUpRes()
    }
    set {body = .buyDressUpRes(newValue)}
  }

  /// 邀请码、补码响应
  public var inviteRes: OSInviteRes {
    get {
      if case .inviteRes(let v)? = body {return v}
      return OSInviteRes()
    }
    set {body = .inviteRes(newValue)}
  }

  /// 赠送装扮响应
  public var giveDressUpRes: OSGiveDressUpRes {
    get {
      if case .giveDressUpRes(let v)? = body {return v}
      return OSGiveDressUpRes()
    }
    set {body = .giveDressUpRes(newValue)}
  }

  /// 好友列表请求
  public var myFriendsRes: OSMyFriendsRes {
    get {
      if case .myFriendsRes(let v)? = body {return v}
      return OSMyFriendsRes()
    }
    set {body = .myFriendsRes(newValue)}
  }

  /// 访客记录
  public var visitRecordRes: OSVisitRecordRes {
    get {
      if case .visitRecordRes(let v)? = body {return v}
      return OSVisitRecordRes()
    }
    set {body = .visitRecordRes(newValue)}
  }

  ///幻灵操作
  public var eidolonOperationRes: OSEidolonOperationRes {
    get {
      if case .eidolonOperationRes(let v)? = body {return v}
      return OSEidolonOperationRes()
    }
    set {body = .eidolonOperationRes(newValue)}
  }

  /// 黑名单列表
  public var loadBlacklistRes: OSLoadBlacklistRes {
    get {
      if case .loadBlacklistRes(let v)? = body {return v}
      return OSLoadBlacklistRes()
    }
    set {body = .loadBlacklistRes(newValue)}
  }

  /// 贵宾卡列表响应
  public var honouredGuestCardsRes: OSHonouredGuestCardsRes {
    get {
      if case .honouredGuestCardsRes(let v)? = body {return v}
      return OSHonouredGuestCardsRes()
    }
    set {body = .honouredGuestCardsRes(newValue)}
  }

  /// 粉丝团徽章列表响应
  public var fansClubBadgesRes: OSFansClubBadgesRes {
    get {
      if case .fansClubBadgesRes(let v)? = body {return v}
      return OSFansClubBadgesRes()
    }
    set {body = .fansClubBadgesRes(newValue)}
  }

  /// 粉丝团-佩戴或卸下徽章响应
  public var wearAndRemoveBadgeRes: OSWearAndRemoveBadgeRes {
    get {
      if case .wearAndRemoveBadgeRes(let v)? = body {return v}
      return OSWearAndRemoveBadgeRes()
    }
    set {body = .wearAndRemoveBadgeRes(newValue)}
  }

  /// 粉丝团-粉丝榜响应
  public var fansClubRanksRes: OSFansClubRanksRes {
    get {
      if case .fansClubRanksRes(let v)? = body {return v}
      return OSFansClubRanksRes()
    }
    set {body = .fansClubRanksRes(newValue)}
  }

  /// 粉丝团-退出粉丝团响应
  public var fansClubExitRes: OSFansClubExitRes {
    get {
      if case .fansClubExitRes(let v)? = body {return v}
      return OSFansClubExitRes()
    }
    set {body = .fansClubExitRes(newValue)}
  }

  /// 人脸认证响应
  public var faceVerifyRes: OSFaceVerifyRes {
    get {
      if case .faceVerifyRes(let v)? = body {return v}
      return OSFaceVerifyRes()
    }
    set {body = .faceVerifyRes(newValue)}
  }

  /// 人脸认证结果查询响应
  public var faceVerifyResultRes: OSFaceVerifyResultRes {
    get {
      if case .faceVerifyResultRes(let v)? = body {return v}
      return OSFaceVerifyResultRes()
    }
    set {body = .faceVerifyResultRes(newValue)}
  }

  /// 声音介绍 换一换响应
  public var userVoiceDialogueReportRes: OSUserVoiceDialogueReportRes {
    get {
      if case .userVoiceDialogueReportRes(let v)? = body {return v}
      return OSUserVoiceDialogueReportRes()
    }
    set {body = .userVoiceDialogueReportRes(newValue)}
  }

  /// 删除声音介绍响应
  public var userVoiceSoftDeleteRes: OSUserVoiceSoftDeleteRes {
    get {
      if case .userVoiceSoftDeleteRes(let v)? = body {return v}
      return OSUserVoiceSoftDeleteRes()
    }
    set {body = .userVoiceSoftDeleteRes(newValue)}
  }

  /// 提交审核响应
  public var userVoiceSubmitRes: OSUserVoiceSubmitRes {
    get {
      if case .userVoiceSubmitRes(let v)? = body {return v}
      return OSUserVoiceSubmitRes()
    }
    set {body = .userVoiceSubmitRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 登录响应
    case loginRes(OSLoginRes)
    /// 查看用户个人信息响应
    case viewRes(OSViewRes)
    /// 编辑用户信息响应
    case editUserRes(OSEditUserRes)
    /// 查看用户照片墙响应
    case userPhotoReq(OSUserPhotoRes)
    /// 上传(单张)照片墙响应
    case uploadPhotoRes(OSUploadPhotoRes)
    /// 上传(多张)照片墙响应
    case uploadPhotoListRes(OSUploadPhotoListRes)
    /// 删除(单张)照片墙响应
    case deletePhotoRes(OSDeletePhotoRes)
    /// 删除(多张)照片墙响应
    case deletePhotoListRes(OSDeletePhotoListRes)
    /// 获取签到信息响应
    case signinInfoRes(OSSigninInfoRes)
    /// 用户签到响应
    case userSigninRes(OSUserSigninRes)
    /// 获取装扮标签响应
    case dressUpTagsRes(OSDressUpTagsRes)
    /// 获取用户装扮响应
    case userDressUpRes(OSUserDressUpRes)
    /// 装扮操作响应
    case dressUpOperateRes(OSDressUpOperateRes)
    /// 获取用户礼物墙响应
    case userGiftWallRes(OSUserGiftWallRes)
    /// 查看用户收礼/送礼响应
    case giftDetailsRes(OSGiftDetailsRes)
    /// 用户最近访问房间响应
    case lastJoinChannelRes(OSLastJoinChannelRes)
    /// 获取账户安全等级信息响应
    case accountSecurityRes(OSAccountSecurityRes)
    /// 获取第三方绑定的账号列表响应
    case thirdPartyAccountRes(OSThirdPartyAccountRes)
    /// 绑定手机响应
    case bindMobileRes(OSBindMobileRes)
    /// 开启/关闭/校验青少年模式密码响应
    case adolescentSettingRes(OSAdolescentSettingRes)
    /// 用户实名认证响应
    case authenticationRes(OSAuthenticationRes)
    /// 设置密码响应
    case settingPasswordRes(OSSettingPasswordRes)
    /// 修改密码响应
    case updatePasswordRes(OSUpdatePasswordRes)
    /// 重置密码响应
    case resetPasswordRes(OSResetPasswordRes)
    /// 实名认证验证绑定手机号码响应
    case authenticationVerifyMobileRes(OSAuthenticationVerifyMobileRes)
    /// 绑定手机验证原手机号响应
    case bindVerifyMobileRes(OSBindVerifyMobileRes)
    /// 关注用户响应
    case followRes(OSFollowRes)
    /// 请求关注响应
    case unfollowRes(OSUnfollowRes)
    /// 退出登录响应
    case logoutRes(OSLogoutRes)
    /// 举报用户/房间响应
    case reportRes(OSReportRes)
    /// 加入黑名单响应
    case joinBlacklistRes(OSJoinBlacklistRes)
    /// 移除黑名单响应
    case removeBlacklistRes(OSRemoveBlacklistRes)
    /// 关注列表响应
    case followingsListRes(OSFollowingsListRes)
    /// 粉丝列表响应
    case followersListRes(OSFollowersListRes)
    /// 用户反馈响应
    case userFeedbackRes(OSUserFeedbackRes)
    /// 搜索响应
    case searchRes(OSSearchRes)
    /// 获取注册头像响应
    case signInAvatarRes(OSSignInAvatarRes)
    /// 用户钱包响应
    case userWalletRes(OSUserWalletRes)
    /// 身份证识别响应
    case idCardRecognitionRes(OSIdCardRecognitionRes)
    /// 用户注销响应
    case logoffRes(OSLogoffRes)
    /// 用户勋章列表响应
    case userMedalListRes(OSUserMedalListRes)
    /// 装扮商城列表响应
    case dressUpMallRes(OSDressUpMallRes)
    /// 购买装扮响应
    case buyDressUpRes(OSBuyDressUpRes)
    /// 邀请码、补码响应
    case inviteRes(OSInviteRes)
    /// 赠送装扮响应
    case giveDressUpRes(OSGiveDressUpRes)
    /// 好友列表请求
    case myFriendsRes(OSMyFriendsRes)
    /// 访客记录
    case visitRecordRes(OSVisitRecordRes)
    ///幻灵操作
    case eidolonOperationRes(OSEidolonOperationRes)
    /// 黑名单列表
    case loadBlacklistRes(OSLoadBlacklistRes)
    /// 贵宾卡列表响应
    case honouredGuestCardsRes(OSHonouredGuestCardsRes)
    /// 粉丝团徽章列表响应
    case fansClubBadgesRes(OSFansClubBadgesRes)
    /// 粉丝团-佩戴或卸下徽章响应
    case wearAndRemoveBadgeRes(OSWearAndRemoveBadgeRes)
    /// 粉丝团-粉丝榜响应
    case fansClubRanksRes(OSFansClubRanksRes)
    /// 粉丝团-退出粉丝团响应
    case fansClubExitRes(OSFansClubExitRes)
    /// 人脸认证响应
    case faceVerifyRes(OSFaceVerifyRes)
    /// 人脸认证结果查询响应
    case faceVerifyResultRes(OSFaceVerifyResultRes)
    /// 声音介绍 换一换响应
    case userVoiceDialogueReportRes(OSUserVoiceDialogueReportRes)
    /// 删除声音介绍响应
    case userVoiceSoftDeleteRes(OSUserVoiceSoftDeleteRes)
    /// 提交审核响应
    case userVoiceSubmitRes(OSUserVoiceSubmitRes)

  }

  public init() {}
}

/// 登录请求
public struct OSLoginReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 根据登录类型不同，定义不同(自动登录:用户ID;手机登录:手机号;微信登录:authCode;QQ:unionId)
  public var identifier: String = String()

  /// 根据登录类型不同，定义不同(自动登录:用户TOKEN;手机登录:手机验证码;微信登录:无;QQ:accessToken)
  public var credential: String = String()

  /// 登录类型
  public var identityType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 登录响应
public struct OSLoginRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// token
  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// 房间信息
  public var myChannel: OSChannelVo {
    get {return _storage._myChannel ?? OSChannelVo()}
    set {_uniqueStorage()._myChannel = newValue}
  }
  /// Returns true if `myChannel` has been explicitly set.
  public var hasMyChannel: Bool {return _storage._myChannel != nil}
  /// Clears the value of `myChannel`. Subsequent reads from it will return its default value.
  public mutating func clearMyChannel() {_uniqueStorage()._myChannel = nil}

  /// 用户信息
  public var user: OSUserVo {
    get {return _storage._user ?? OSUserVo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// 用户设置信息
  public var userSetting: OSUserSetting {
    get {return _storage._userSetting ?? OSUserSetting()}
    set {_uniqueStorage()._userSetting = newValue}
  }
  /// Returns true if `userSetting` has been explicitly set.
  public var hasUserSetting: Bool {return _storage._userSetting != nil}
  /// Clears the value of `userSetting`. Subsequent reads from it will return its default value.
  public mutating func clearUserSetting() {_uniqueStorage()._userSetting = nil}

  /// 签到信息,yoni用
  public var signinInfo: OSSigninInfo {
    get {return _storage._signinInfo ?? OSSigninInfo()}
    set {_uniqueStorage()._signinInfo = newValue}
  }
  /// Returns true if `signinInfo` has been explicitly set.
  public var hasSigninInfo: Bool {return _storage._signinInfo != nil}
  /// Clears the value of `signinInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSigninInfo() {_uniqueStorage()._signinInfo = nil}

  /// 签到信息,逗趣和元气用
  public var signinInfo2: OSSigninInfo2 {
    get {return _storage._signinInfo2 ?? OSSigninInfo2()}
    set {_uniqueStorage()._signinInfo2 = newValue}
  }
  /// Returns true if `signinInfo2` has been explicitly set.
  public var hasSigninInfo2: Bool {return _storage._signinInfo2 != nil}
  /// Clears the value of `signinInfo2`. Subsequent reads from it will return its default value.
  public mutating func clearSigninInfo2() {_uniqueStorage()._signinInfo2 = nil}

  /// 勋章等级列表
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 绑定手机相关
  public var bindMobile: OSBindMobile {
    get {return _storage._bindMobile ?? OSBindMobile()}
    set {_uniqueStorage()._bindMobile = newValue}
  }
  /// Returns true if `bindMobile` has been explicitly set.
  public var hasBindMobile: Bool {return _storage._bindMobile != nil}
  /// Clears the value of `bindMobile`. Subsequent reads from it will return its default value.
  public mutating func clearBindMobile() {_uniqueStorage()._bindMobile = nil}

  /// 邀请码配置信息
  public var inviteConfig: OSInviteConfig {
    get {return _storage._inviteConfig ?? OSInviteConfig()}
    set {_uniqueStorage()._inviteConfig = newValue}
  }
  /// Returns true if `inviteConfig` has been explicitly set.
  public var hasInviteConfig: Bool {return _storage._inviteConfig != nil}
  /// Clears the value of `inviteConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInviteConfig() {_uniqueStorage()._inviteConfig = nil}

  /// 是否新注册用户
  public var isNew: Int32 {
    get {return _storage._isNew}
    set {_uniqueStorage()._isNew = newValue}
  }

  /// 声网私聊频道token
  public var privateChannelToken: String {
    get {return _storage._privateChannelToken}
    set {_uniqueStorage()._privateChannelToken = newValue}
  }

  /// 是否已编辑过个人信息 0：未编辑,1：已编辑
  public var hasEdit_p: Int32 {
    get {return _storage._hasEdit_p}
    set {_uniqueStorage()._hasEdit_p = newValue}
  }

  /// 是否强制开启青少年模式 0:否 1:是
  public var openAdolescentModel: Int32 {
    get {return _storage._openAdolescentModel}
    set {_uniqueStorage()._openAdolescentModel = newValue}
  }

  /// 幻灵数据
  public var eidolonInfo: OSEidolonInfo {
    get {return _storage._eidolonInfo ?? OSEidolonInfo()}
    set {_uniqueStorage()._eidolonInfo = newValue}
  }
  /// Returns true if `eidolonInfo` has been explicitly set.
  public var hasEidolonInfo: Bool {return _storage._eidolonInfo != nil}
  /// Clears the value of `eidolonInfo`. Subsequent reads from it will return its default value.
  public mutating func clearEidolonInfo() {_uniqueStorage()._eidolonInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 签到信息,yoni用
public struct OSSigninInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 签到信息
  public var secondPrompt: String = String()

  /// 礼物图标
  public var giftIcon: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 签到信息,逗趣和元气用
public struct OSSigninInfo2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 签到列表
  public var prizeList: [OSPrizeList] = []

  /// 签到说明，如：明日签到更多好礼哦
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 签到列表
public struct OSPrizeList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 名称
  public var name: String = String()

  /// 图片地址
  public var iconURL: String = String()

  /// 数量
  public var count: Int32 = 0

  /// 奖励类型，1：免费礼物，2：普通礼物，3：坐骑，4：麦位框
  public var prizeType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///绑定手机相关
public struct OSBindMobile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否已绑定手机,0=未绑定,1=已绑定
  public var isBindMobile: Int32 = 0

  /// 创建房间限制,0=无权限,1=有权限
  public var createChannelAuth: Int32 = 0

  /// 公屏发言限制,0=无权限,1=有权限
  public var publicChatAuth: Int32 = 0

  /// 动态限制,0=无权限,1=有权限
  public var momentAuth: Int32 = 0

  /// 上麦限制,0=无权限,1=有权限
  public var upSeatAuth: Int32 = 0

  /// 评论限制,0=无权限,1=有权限
  public var commentAuth: Int32 = 0

  /// 手机号(已做脱敏处理)
  public var displayMobile: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 邀请码配置信息
public struct OSInviteConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 跳转类型(0.不跳转 1.跳转房间)
  public var skipType: Int32 = 0

  /// 跳转房间Id
  public var skipChannelID: String = String()

  /// 是否密码房(0.否 1.是)
  public var lockRoom: Int32 = 0

  /// 用户是否已填写邀请码(0:未填写 1:已填写)
  public var invitationStatus: Int32 = 0

  /// 用户设置-填写邀请码入口（0隐藏1显示）
  public var editCodeEntrance: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 查看用户个人信息请求
public struct OSViewReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 目标用户id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 查看用户个人信息响应
public struct OSViewRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户信息
  public var user: OSUserVo {
    get {return _storage._user ?? OSUserVo()}
    set {_uniqueStorage()._user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return _storage._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {_uniqueStorage()._user = nil}

  /// 勋章列表信息
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 装扮信息
  public var dressUpInfo: OSDressUpInfo {
    get {return _storage._dressUpInfo ?? OSDressUpInfo()}
    set {_uniqueStorage()._dressUpInfo = newValue}
  }
  /// Returns true if `dressUpInfo` has been explicitly set.
  public var hasDressUpInfo: Bool {return _storage._dressUpInfo != nil}
  /// Clears the value of `dressUpInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDressUpInfo() {_uniqueStorage()._dressUpInfo = nil}

  /// 家族信息
  public var family: OSFamily {
    get {return _storage._family ?? OSFamily()}
    set {_uniqueStorage()._family = newValue}
  }
  /// Returns true if `family` has been explicitly set.
  public var hasFamily: Bool {return _storage._family != nil}
  /// Clears the value of `family`. Subsequent reads from it will return its default value.
  public mutating func clearFamily() {_uniqueStorage()._family = nil}

  /// 其他消息
  public var other: OSOther {
    get {return _storage._other ?? OSOther()}
    set {_uniqueStorage()._other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return _storage._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {_uniqueStorage()._other = nil}

  /// 当前所在房间信息
  public var currentLocation: OSChannelVo {
    get {return _storage._currentLocation ?? OSChannelVo()}
    set {_uniqueStorage()._currentLocation = newValue}
  }
  /// Returns true if `currentLocation` has been explicitly set.
  public var hasCurrentLocation: Bool {return _storage._currentLocation != nil}
  /// Clears the value of `currentLocation`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentLocation() {_uniqueStorage()._currentLocation = nil}

  /// 是否关注了对方
  public var following: Int32 {
    get {return _storage._following}
    set {_uniqueStorage()._following = newValue}
  }

  /// 黑名单状态 0未拉黑 1已拉黑
  public var blacklistStatus: Int32 {
    get {return _storage._blacklistStatus}
    set {_uniqueStorage()._blacklistStatus = newValue}
  }

  /// 是否显示水晶（提现）入口,0：不显示，1：显示
  public var withdrawSwitch: Int32 {
    get {return _storage._withdrawSwitch}
    set {_uniqueStorage()._withdrawSwitch = newValue}
  }

  /// 是否显示钱包入口,0：不显示 1：显示
  public var walletSwitch: Int32 {
    get {return _storage._walletSwitch}
    set {_uniqueStorage()._walletSwitch = newValue}
  }

  /// 校验码
  public var checkCode: String {
    get {return _storage._checkCode}
    set {_uniqueStorage()._checkCode = newValue}
  }

  /// 贵宾卡列表信息
  public var honouredGuestCards: [OSHonouredGuestCard] {
    get {return _storage._honouredGuestCards}
    set {_uniqueStorage()._honouredGuestCards = newValue}
  }

  /// 粉丝团徽章列表信息
  public var fansClubs: [OSFansClubBadge] {
    get {return _storage._fansClubs}
    set {_uniqueStorage()._fansClubs = newValue}
  }

  /// 粉丝团徽章信息
  public var fansBadge: OSFansClubVo {
    get {return _storage._fansBadge ?? OSFansClubVo()}
    set {_uniqueStorage()._fansBadge = newValue}
  }
  /// Returns true if `fansBadge` has been explicitly set.
  public var hasFansBadge: Bool {return _storage._fansBadge != nil}
  /// Clears the value of `fansBadge`. Subsequent reads from it will return its default value.
  public mutating func clearFansBadge() {_uniqueStorage()._fansBadge = nil}

  /// 用户礼物藏馆信息
  public var collectHallInfo: OSCollectionHallVo {
    get {return _storage._collectHallInfo ?? OSCollectionHallVo()}
    set {_uniqueStorage()._collectHallInfo = newValue}
  }
  /// Returns true if `collectHallInfo` has been explicitly set.
  public var hasCollectHallInfo: Bool {return _storage._collectHallInfo != nil}
  /// Clears the value of `collectHallInfo`. Subsequent reads from it will return its default value.
  public mutating func clearCollectHallInfo() {_uniqueStorage()._collectHallInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 家族信息
public struct OSFamily: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 家族系统ID
  public var familyID: String = String()

  /// 家族ID(显示用)
  public var familyAccountID: Int32 = 0

  /// 家族名称
  public var familyName: String = String()

  /// 家族头像
  public var familyAvatarURL: String = String()

  /// 家族消息数量
  public var familyMessage: Int32 = 0

  /// 权限类型 1：族长，2：签约成员，3：普通成员
  public var type: Int32 = 0

  /// 家族签约邀请;0=不显示,1=正常显示,2=显示但没实名，3=主播使用版本过低，5=该用户的其他实名账号已签约
  public var familySignInvite: Int32 = 0

  /// 家族权限
  public var powerType: String = String()

  /// 签约记录id
  public var familySignRecordID: Int64 = 0

  /// 来源;0=族长发起,1=主播申请
  public var source: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 其他消息
public struct OSOther: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户关注数量
  public var following: Int32 = 0

  /// 粉丝数量
  public var followers: Int32 = 0

  /// 用户好友数量
  public var friends: Int32 = 0

  /// 是否显示邀请入口
  public var invitation: Int32 = 0

  /// 用户动态数量
  public var momentCount: Int32 = 0

  /// 足迹数量
  public var footprint: Int32 = 0

  /// 是否可编辑性别 0否 1是
  public var isGenderModify: Int32 = 0

  /// 访客数量
  public var visitCount: Int32 = 0

  /// 是否实名认证 -1.已实名（未上传身份证照片） 0.未实名 1.已实名
  public var hasCertification_p: Int32 = 0

  /// 人脸认证
  public var faceVerification: Int32 = 0

  /// 显示实名姓名（加星）
  public var displayName: String = String()

  /// 显示身份证号码（加星）
  public var displayNumber: String = String()

  /// 我的粉丝团状态 0未满足条件/粉丝团未创建或失效 1已创建/正在申请粉丝团
  public var myFansClubState: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///用户粉丝团徽章信息
public struct OSFansClubBadge: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 粉丝团Id
  public var clubID: Int64 = 0

  /// 粉丝徽章等级
  public var level: Int32 = 0

  /// 徽章名称
  public var badgeName: String = String()

  /// 徽章图标
  public var badgeIcon: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 编辑用户信息请求
public struct OSEditUserReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 昵称
  public var nickname: String = String()

  /// 性别,1男 2女
  public var gender: OSGender = .unknown

  /// 头像地址
  public var avatarURL: String = String()

  /// 生日
  public var birthday: String = String()

  /// 个性签名
  public var signature: String = String()

  /// 邀请码
  public var inviteCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 编辑用户信息响应
public struct OSEditUserRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户自己的频道
  public var channelID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 生日
  public var birthday: String = String()

  /// 个性签名
  public var signature: String = String()

  /// 粉丝
  public var followers: Int32 = 0

  /// 关注
  public var following: Int32 = 0

  /// 超管标识
  public var adminFlag: Int32 = 0

  /// 填写邀请码需要跳转的房间配置信息
  public var inviteConfig: OSInviteConfig {
    get {return _inviteConfig ?? OSInviteConfig()}
    set {_inviteConfig = newValue}
  }
  /// Returns true if `inviteConfig` has been explicitly set.
  public var hasInviteConfig: Bool {return self._inviteConfig != nil}
  /// Clears the value of `inviteConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInviteConfig() {self._inviteConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inviteConfig: OSInviteConfig? = nil
}

/// 查看用户照片墙请求
public struct OSUserPhotoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户id
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 查看用户照片墙响应
public struct OSUserPhotoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户照片墙列表
  public var userPhotoList: [OSUserPhotoVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户照片信息
public struct OSUserPhotoVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 照片id
  public var id: Int32 = 0

  /// 用户系统id
  public var userID: String = String()

  /// 照片地址
  public var url: String = String()

  /// 是否是默认照片,0:否 1:是
  public var defaultPhoto: Int32 = 0

  /// 排序
  public var sort: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 上传(单张)照片墙请求
public struct OSUploadPhotoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 图片地址
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 上传(单张)照片墙响应
public struct OSUploadPhotoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// 用户系统id
  public var userID: String = String()

  /// 图片地址
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 上传(多张)照片墙请求
public struct OSUploadPhotoListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 图片地址列表
  public var urlList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 上传(多张)照片墙响应
public struct OSUploadPhotoListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除(单张)照片墙请求
public struct OSDeletePhotoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 照片id
  public var id: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除(单张)照片墙响应
public struct OSDeletePhotoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 下一个照片墙id
  public var id: Int64 = 0

  /// 用户系统id
  public var userID: String = String()

  /// 图片地址
  public var url: String = String()

  /// 是否是默认照片墙 0:否 1:是
  public var defaultPhoto: Int32 = 0

  /// 排序
  public var sort: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除(多张)照片墙请求
public struct OSDeletePhotoListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 照片墙id列表
  public var idList: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除(多张)照片墙响应
public struct OSDeletePhotoListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取签到信息请求
public struct OSSigninInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取签到信息响应
public struct OSSigninInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 连续签到天数
  public var seriesDay: Int32 = 0

  /// 今天签到状态 0未签到 1已签到
  public var signinStatus: Int32 = 0

  /// 签到月份时间戳/毫秒
  public var monthTimestamp: Int64 = 0

  /// 我的签到列表
  public var signinList: [OSSigninList] = []

  /// 连续签到礼物列表
  public var seriesGiftList: [OSSeriesGiftList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 我的签到列表
public struct OSSigninList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 日期时间戳
  public var dateTimestamp: Int64 = 0

  /// 签到时间戳(签到才返回)
  public var signinTimestamp: Int64 = 0

  /// 签到展示礼物图标(签到才返回)
  public var showIcon: String = String()

  /// 签到状态(0未签到 1已签到)
  public var signinStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 连续签到礼物列表
public struct OSSeriesGiftList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物名称
  public var giftName: String = String()

  /// 礼物图标
  public var giftIcon: String = String()

  /// 礼物获得天数范围 (0表示整月)
  public var signinScope: Int32 = 0

  /// 礼物描述
  public var remark: String = String()

  /// 获得条件
  public var acquire: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户签到请求
public struct OSUserSigninReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户签到响应
public struct OSUserSigninRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 签到提示
  public var prompt: String = String()

  /// 二级提示
  public var secondPrompt: String = String()

  /// 签到礼物列表
  public var signinGifts: [OSSigninGifts] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 签到礼物列表
public struct OSSigninGifts: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物名称
  public var giftName: String = String()

  /// 礼物图片
  public var giftIcon: String = String()

  /// 礼物数量
  public var count: Int32 = 0

  /// 礼物描述
  public var remark: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取装扮标签请求
public struct OSDressUpTagsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 标签入口 1商城 2我的
  public var dressUpSource: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取装扮标签响应
public struct OSDressUpTagsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮标签列表
  public var dressUpTagList: [OSDressUpTagVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮标签信息
public struct OSDressUpTagVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 搜索类型
  public var searchType: OSDressUpTagType = .mount

  /// 名称
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取用户装扮请求
public struct OSUserDressUpReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 搜索类型
  public var searchType: OSDressUpTagType = .mount

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取用户装扮响应
public struct OSUserDressUpRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 装扮信息
  public var records: [OSDressUpVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮信息
public struct OSDressUpVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  /// 用户装扮id
  public var userDressUpID: Int32 = 0

  /// 装扮名称
  public var dressUpName: String = String()

  /// 装扮静态图
  public var dressUpIcon: String = String()

  /// 装扮动态svga,动态图,如果为空字符串则使用dressIcon展示
  public var dressIconSvga: String = String()

  /// 装扮佩戴状态 0未佩戴 1佩戴
  public var dressUpStatus: OSDressUpStatus = .unWear

  /// 剩余时间,0为永久
  public var duration: Int32 = 0

  /// 装扮类型
  public var dressUpType: Int32 = 0

  /// 搜索类型
  public var searchType: OSDressUpTagType = .mount

  /// 备注
  public var dressUpRemark: String = String()

  /// 生效时间时间戳
  public var effectiveTime: Int64 = 0

  /// 过期时间时间戳
  public var expireTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮操作请求
public struct OSDressUpOperateReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 类型 0取消佩戴 1佩戴
  public var operateType: OSDressUpStatus = .unWear

  /// 用户装扮id
  public var userDressUpID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮操作响应
public struct OSDressUpOperateRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取用户礼物墙请求
public struct OSUserGiftWallReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 目标用户id
  public var targetID: String = String()

  /// 目标房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取用户礼物墙响应
public struct OSUserGiftWallRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 礼物墙信息
  public var records: [OSGiftWallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物墙信息
public struct OSGiftWallVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物id
  public var giftID: Int32 = 0

  /// 礼物名称
  public var giftName: String = String()

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 礼物icon
  public var giftIconURL: String = String()

  /// 礼物总价值
  public var totalGiftValue: Int32 = 0

  /// 是否显示限时角标 0.不显示 1.显示
  public var timedCornerMark: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 查看用户收礼/送礼请求
public struct OSGiftDetailsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 类型 0:收礼,1:送礼
  public var type: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 查看用户收礼/送礼响应
public struct OSGiftDetailsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼物详情
  public var giftDetails: OSGiftDetails {
    get {return _giftDetails ?? OSGiftDetails()}
    set {_giftDetails = newValue}
  }
  /// Returns true if `giftDetails` has been explicitly set.
  public var hasGiftDetails: Bool {return self._giftDetails != nil}
  /// Clears the value of `giftDetails`. Subsequent reads from it will return its default value.
  public mutating func clearGiftDetails() {self._giftDetails = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _giftDetails: OSGiftDetails? = nil
}

/// 礼物详情
public struct OSGiftDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 送礼/收礼信息
  public var records: [OSUserGiftVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送礼/收礼信息
public struct OSUserGiftVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 账号id
  public var accountID: Int32 = 0

  /// 用户昵称
  public var nickname: String = String()

  /// 用户头像
  public var avatarURL: String = String()

  /// 礼物名称
  public var giftName: String = String()

  /// 礼物图标
  public var giftIconURL: String = String()

  /// 礼物数量
  public var giftCount: Int32 = 0

  /// 礼物价值
  public var totalGiftValue: Int32 = 0

  /// 日期
  public var createTime: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户最近访问房间请求
public struct OSLastJoinChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户最近访问房间响应
public struct OSLastJoinChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 房间信息
  public var records: [OSChannelVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取账户安全等级信息请求
public struct OSAccountSecurityReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取账户安全等级信息响应
public struct OSAccountSecurityRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 绑定手机（有绑定时返回）
  public var mobile: String = String()

  /// 绑定手机提示
  public var bindMobileMsg: String = String()

  /// 实名认证提示,如已认证、未认证
  public var authenticationMsg: String = String()

  /// 0:未设置过密码,1:已设置过密码
  public var exitPassword: Int32 = 0

  /// 安全等级,1：低,2:中,3:高
  public var securityLevel: Int32 = 0

  /// 安全等级提示
  public var securityMsg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取第三方绑定的账号列表请求
public struct OSThirdPartyAccountReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取第三方绑定的账号列表响应
public struct OSThirdPartyAccountRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// QQ绑定状态
  public var qqBindState: Int32 = 0

  /// 微信绑定状态
  public var wechatBindState: Int32 = 0

  /// 苹果绑定状态,安卓设备不返回该字段,苹果设备返回该字段
  public var appleBindState: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 绑定手机请求
public struct OSBindMobileReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 手机号码
  public var mobile: String = String()

  /// 验证码
  public var verifyCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 绑定手机响应
public struct OSBindMobileRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 新手机号码
  public var mobile: String = String()

  /// 展示手机号码
  public var displayMobile: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 开启/关闭/校验青少年模式密码请求
public struct OSAdolescentSettingReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 类型 1开启青少年密码 0关闭青少年密码 2校验青少年密码
  public var adolescentModel: Int32 = 0

  /// 密码，四位数
  public var adolescentPwd: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 开启/关闭/校验青少年模式密码响应
public struct OSAdolescentSettingRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户实名认证请求
public struct OSAuthenticationReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 身份证号码
  public var idCardNo: String = String()

  /// 真实姓名
  public var realName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户实名认证响应
public struct OSAuthenticationRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户设置信息
  public var userSetting: OSUserSetting {
    get {return _userSetting ?? OSUserSetting()}
    set {_userSetting = newValue}
  }
  /// Returns true if `userSetting` has been explicitly set.
  public var hasUserSetting: Bool {return self._userSetting != nil}
  /// Clears the value of `userSetting`. Subsequent reads from it will return its default value.
  public mutating func clearUserSetting() {self._userSetting = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userSetting: OSUserSetting? = nil
}

/// 设置密码请求
public struct OSSettingPasswordReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// md5加密后的密码
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 设置密码响应
public struct OSSettingPasswordRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 修改密码请求
public struct OSUpdatePasswordReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// md5加密后的旧密码
  public var oldPassword: String = String()

  /// md5加密后的新密码
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 修改密码响应
public struct OSUpdatePasswordRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 重置密码请求
public struct OSResetPasswordReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 账号id
  public var accountID: Int32 = 0

  /// md5加密后的密码
  public var password: String = String()

  /// 手机号码
  public var mobilePhone: String = String()

  /// 验证码
  public var verifyCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 重置密码响应
public struct OSResetPasswordRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 实名认证验证绑定手机号码请求
public struct OSAuthenticationVerifyMobileReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 手机号码
  public var mobile: String = String()

  /// 验证码
  public var verifyCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 实名认证验证绑定手机号码响应
public struct OSAuthenticationVerifyMobileRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 绑定手机验证原手机号请求
public struct OSBindVerifyMobileReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 验证码
  public var verifyCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 绑定手机验证原手机号响应
public struct OSBindVerifyMobileRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关注用户请求
public struct OSFollowReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 关注人的用户系统id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关注用户响应
public struct OSFollowRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 关注状态,0:未关注,1:已关注,2:互相关注
  public var followStatus: OSFollowStatus = .unfollow

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 请求关注请求
public struct OSUnfollowReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 目标用户系统id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 请求关注响应
public struct OSUnfollowRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退出登录请求
public struct OSLogoutReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退出登录响应
public struct OSLogoutRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 举报用户/房间/动态请求
public struct OSReportReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 举报目标id(房主id或用户id)
  public var targetID: String = String()

  /// 举报原因
  public var reason: String = String()

  /// 举报类型(0:用户 1:房间 2:动态 3：动态评论)
  public var type: Int32 = 0

  /// 图片列表
  public var pictureUrls: [String] = []

  ///动态Id
  public var momentID: Int64 = 0

  ///动态评论Id
  public var commentID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 举报用户/房间响应
public struct OSReportRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加入黑名单请求
public struct OSJoinBlacklistReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 举报目标id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加入黑名单响应
public struct OSJoinBlacklistRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加载黑名单列表请求
public struct OSLoadBlacklistReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///分页
  public var page: OSPageReq {
    get {return _page ?? OSPageReq()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: OSPageReq? = nil
}

/// 加载黑名单列表响应
public struct OSLoadBlacklistRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 黑名单用户信息
  public var records: [OSBlacklistVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 移除黑名单请求
public struct OSRemoveBlacklistReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 举报目标id
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 移除黑名单响应
public struct OSRemoveBlacklistRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关注列表请求
public struct OSFollowingsListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关注列表响应
public struct OSFollowingsListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 关注用户数据
  public var records: [OSUserFollowVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 幻灵操作请求
public struct OSEidolonOperationReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///操作类型,CARRY=携带
  public var operateType: String = String()

  ///用户幻灵id
  public var id: Int64 = 0

  ///携带
  public var carry: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 幻灵操作响应
public struct OSEidolonOperationRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 访客记录请求
public struct OSVisitRecordReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 访客记录响应
public struct OSVisitRecordRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 访客者数据
  public var records: [OSUserVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 好友列表请求
public struct OSMyFriendsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  ///查询条件
  public var searchStr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 好友列表响应
public struct OSMyFriendsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 关注用户数据
  public var records: [OSUserFollowVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关注用户信息
public struct OSUserFollowVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// 关注用户系统id
  public var followingUserID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 头像
  public var avatarURL: String = String()

  /// 昵称
  public var nickname: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 备注
  public var alias: String = String()

  /// 描述
  public var description_p: String = String()

  /// 关系 1单向关注 2双向关注
  public var bothStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝列表请求
public struct OSFollowersListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝列表响应
public struct OSFollowersListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 粉丝用户数据
  public var records: [OSUserFollowersVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝用户信息
public struct OSUserFollowersVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// 关注用户系统id
  public var followedUserID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 头像
  public var avatarURL: String = String()

  /// 昵称
  public var nickname: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 关系 1单向关注 2双向关注
  public var bothStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户反馈请求
public struct OSUserFeedbackReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 描述内容
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户反馈响应
public struct OSUserFeedbackRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 搜索请求
public struct OSSearchReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 搜索关键字
  public var searchStr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 搜索响应
public struct OSSearchRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户列表
  public var user: [OSUserVo] = []

  /// 房间列表
  public var chatchannel: [OSSearchChannelVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 搜索房间信息
public struct OSSearchChannelVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间号,展示用
  public var channelNo: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  /// 房间名称
  public var channelName: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 类型
  public var channelType: String = String()

  /// 房主id
  public var ownerID: String = String()

  /// 在线人数
  public var onlineNumber: Int32 = 0

  /// 是否上锁 0:未上锁 1:已上锁
  public var lockedStatus: Int32 = 0

  /// 标签名
  public var labelName: String = String()

  /// 麦位用户信息
  public var userInSeats: [OSUserInSeats] = []

  /// 房间角标
  public var labelBackgroundImg: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取注册头像请求
public struct OSSignInAvatarReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取注册头像响应
public struct OSSignInAvatarRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 注册头像信息列表
  public var avatarList: [OSUserAvatarVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 注册头像信息
public struct OSUserAvatarVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 头像名称
  public var avatarName: String = String()

  /// 头像地址
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户钱包请求
public struct OSUserWalletReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户钱包响应
public struct OSUserWalletRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 钻石数量
  public var diamondsAmount: Int32 = 0

  /// 水晶数量
  public var crystalAmount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 身份证识别请求
public struct OSIdCardRecognitionReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 身份证正面
  public var idCardFaceURL: String = String()

  /// 身份证反面
  public var idCardBackURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 身份证识别响应
public struct OSIdCardRecognitionRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 实名状态 0未实名 1已实名
  public var hasCertification_p: Int32 = 0

  /// 展示名称(已做星号处理)
  public var displayName: String = String()

  /// 展示身份证号(已做星号处理)
  public var displayNumber: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户注销请求
public struct OSLogoffReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户注销响应
public struct OSLogoffRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户勋章列表请求
public struct OSUserMedalListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户勋章列表响应
public struct OSUserMedalListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 勋章信息
  public var medalList: [OSMedalList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮商城列表请求
public struct OSDressUpMallReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  /// 搜索类型
  public var searchType: OSDressUpTagType = .mount

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮商城列表响应
public struct OSDressUpMallRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 装扮商城信息
  public var records: [OSDressUpMallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 装扮商城信息
public struct OSDressUpMallVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  /// 装扮名称
  public var dressUpName: String = String()

  /// 装扮图标
  public var dressUpIcon: String = String()

  /// 装扮价格
  public var dressUpPrice: Int32 = 0

  /// 备注
  public var dressUpRemark: String = String()

  /// 天数
  public var duration: Int32 = 0

  /// 限定类型(限定类型 0:普通装扮;1:勋章限定;2:活动)
  public var limitedType: Int32 = 0

  /// 装扮动效
  public var dressIconSvga: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 购买装扮请求
public struct OSBuyDressUpReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 购买装扮响应
public struct OSBuyDressUpRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 赠送装扮请求
public struct OSGiveDressUpReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  ///赠送装扮目标用户的accountId
  public var targetAccountID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 赠送装扮响应
public struct OSGiveDressUpRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///目标用户id
  public var targetID: String = String()

  ///装扮名称
  public var dressUpName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 邀请码请求
public struct OSInviteReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 邀请码
  public var inviteCode: String = String()

  /// 渠道Id(不是房间Id)
  public var channelIDCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 邀请码响应
public struct OSInviteRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 黑名单用户信息
public struct OSBlacklistVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id
  public var id: Int32 = 0

  /// 黑名单用户系统id
  public var blackListedUserID: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 昵称
  public var nickname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 贵宾卡列表请求
public struct OSHonouredGuestCardsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///查看目标用户Id(不传默认查看自己的)
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 贵宾卡列表响应
public struct OSHonouredGuestCardsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 贵宾卡列表信息
  public var honouredGuestCards: [OSHonouredGuestCard] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝团徽章列表请求
public struct OSFansClubBadgesReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///查看目标用户Id(不传默认查看自己的)
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝团徽章列表响应
public struct OSFansClubBadgesRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fansClubBadges: [OSFansClubBadges] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///粉丝团徽章列表
public struct OSFansClubBadges: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  /// 账号id
  public var accountID: Int32 {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  /// 昵称
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  /// 头像
  public var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  /// 粉丝团Id
  public var clubID: Int64 {
    get {return _storage._clubID}
    set {_uniqueStorage()._clubID = newValue}
  }

  /// 房间Id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// 粉丝团勋章名称
  public var badgeName: String {
    get {return _storage._badgeName}
    set {_uniqueStorage()._badgeName = newValue}
  }

  /// 粉丝团勋章等级icon
  public var badgeIcon: String {
    get {return _storage._badgeIcon}
    set {_uniqueStorage()._badgeIcon = newValue}
  }

  /// 粉丝团勋章等级
  public var badgeLevel: String {
    get {return _storage._badgeLevel}
    set {_uniqueStorage()._badgeLevel = newValue}
  }

  /// 穿戴状态 0卸下1佩戴
  public var wearStatus: Int32 {
    get {return _storage._wearStatus}
    set {_uniqueStorage()._wearStatus = newValue}
  }

  ///粉丝团等级
  public var level: Int32 {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  ///下一等级
  public var nextLevel: Int32 {
    get {return _storage._nextLevel}
    set {_uniqueStorage()._nextLevel = newValue}
  }

  ///下一等级阀值
  public var nextLevelValue: Int64 {
    get {return _storage._nextLevelValue}
    set {_uniqueStorage()._nextLevelValue = newValue}
  }

  ///当前等级亲密值
  public var currentValue: Int64 {
    get {return _storage._currentValue}
    set {_uniqueStorage()._currentValue = newValue}
  }

  /// 今日亲密度信息
  public var todayIntimacyInfo: OSIntimacyVo {
    get {return _storage._todayIntimacyInfo ?? OSIntimacyVo()}
    set {_uniqueStorage()._todayIntimacyInfo = newValue}
  }
  /// Returns true if `todayIntimacyInfo` has been explicitly set.
  public var hasTodayIntimacyInfo: Bool {return _storage._todayIntimacyInfo != nil}
  /// Clears the value of `todayIntimacyInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTodayIntimacyInfo() {_uniqueStorage()._todayIntimacyInfo = nil}

  ///最大等级亲密值
  public var maxLevelValue: Int64 {
    get {return _storage._maxLevelValue}
    set {_uniqueStorage()._maxLevelValue = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 佩戴/卸下粉丝徽章请求
public struct OSWearAndRemoveBadgeReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///粉丝团Id
  public var clubID: Int64 = 0

  ///操作类型
  public var operateType: OSFansOperateType = .wearing

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 佩戴/卸下粉丝徽章响应
public struct OSWearAndRemoveBadgeRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝榜请求
public struct OSFansClubRanksReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///粉丝团Id
  public var clubID: Int64 = 0

  ///操作类型
  public var searchType: OSFansRanksType = .fansRange0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 粉丝榜响应
public struct OSFansClubRanksRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 获取粉丝榜列表
  public var ranks: [OSFansClubRankVo] = []

  /// 自己的排名、与上一名的差距
  public var myRank: OSFansClubRankVo {
    get {return _myRank ?? OSFansClubRankVo()}
    set {_myRank = newValue}
  }
  /// Returns true if `myRank` has been explicitly set.
  public var hasMyRank: Bool {return self._myRank != nil}
  /// Clears the value of `myRank`. Subsequent reads from it will return its default value.
  public mutating func clearMyRank() {self._myRank = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _myRank: OSFansClubRankVo? = nil
}

/// 粉丝团信息
public struct OSFansClubRankVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  ///当前等级亲密值
  public var totalValue: Int64 = 0

  ///排名 0未上榜
  public var rank: Int32 = 0

  ///粉丝团等级
  public var level: Int32 = 0

  /// 粉丝团勋章名称
  public var badgeName: String = String()

  /// 粉丝团勋章等级icon
  public var badgeIcon: String = String()

  ///和上一名相差亲密值
  public var gapValue: Int32 = 0

  /// 性别,1男 2女
  public var gender: OSGender = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退出粉丝团请求
public struct OSFansClubExitReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///粉丝团Id
  public var clubID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 退出粉丝团响应
public struct OSFansClubExitRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 人脸认证请求
public struct OSFaceVerifyReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///真实姓名
  public var realName: String = String()

  ///身份证号
  public var idCardNo: String = String()

  ///前端回调页面跳转地址
  public var returnURL: String = String()

  ///人脸认证场景码
  public var bizCode: String = String()

  ///类型 0充值人脸认证 1APP人脸认证（默认0）
  public var authType: Int32 = 0

  ///验证码(authType=0必传)
  public var verifyCode: String = String()

  ///手机号(authType=0必传)
  public var mobile: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 人脸认证响应
public struct OSFaceVerifyRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///真实姓名
  public var realName: String = String()

  ///身份证号
  public var idCardNo: String = String()

  ///人脸认证记录ID
  public var certifyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 人脸认证结果查询请求
public struct OSFaceVerifyResultReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///人脸认证记录ID
  public var certifyID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 人脸认证结果查询响应
public struct OSFaceVerifyResultRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户认证信息
  public var userSetting: OSUserSetting {
    get {return _userSetting ?? OSUserSetting()}
    set {_userSetting = newValue}
  }
  /// Returns true if `userSetting` has been explicitly set.
  public var hasUserSetting: Bool {return self._userSetting != nil}
  /// Clears the value of `userSetting`. Subsequent reads from it will return its default value.
  public mutating func clearUserSetting() {self._userSetting = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userSetting: OSUserSetting? = nil
}

/// 声音介绍 换一换请求
public struct OSUserVoiceDialogueReportReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 声音介绍 换一换响应
public struct OSUserVoiceDialogueReportRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userVoices: [OSUserVoiceDialogueReportVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 声音介绍审核记录
public struct OSUserVoiceDialogueReportVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 审核记录id
  public var id: Int64 = 0

  /// 台词文案
  public var word: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除声音介绍请求请求
public struct OSUserVoiceSoftDeleteReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除声音介绍请求响应
public struct OSUserVoiceSoftDeleteRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 提交审核请求
public struct OSUserVoiceSubmitReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 声音url
  public var voice: String = String()

  /// 声音时长(毫秒)
  public var duration: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 提交审核响应
public struct OSUserVoiceSubmitRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSFansOperateType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WEARING"),
    1: .same(proto: "REMOVING"),
  ]
}

extension OSFansRanksType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FANS_RANGE_0"),
    1: .same(proto: "FANS_RANGE_1"),
    2: .same(proto: "FANS_RANGE_2"),
    3: .same(proto: "FANS_RANGE_3"),
  ]
}

extension OSUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loginReq"),
    2: .same(proto: "viewReq"),
    3: .same(proto: "editUserReq"),
    4: .same(proto: "userPhotoReq"),
    5: .same(proto: "uploadPhotoReq"),
    6: .same(proto: "uploadPhotoListReq"),
    7: .same(proto: "deletePhotoReq"),
    8: .same(proto: "deletePhotoListReq"),
    9: .same(proto: "signinInfoReq"),
    10: .same(proto: "userSigninReq"),
    11: .same(proto: "dressUpTagsReq"),
    12: .same(proto: "userDressUpReq"),
    13: .same(proto: "dressUpOperateReq"),
    14: .same(proto: "userGiftWallReq"),
    15: .same(proto: "giftDetailsReq"),
    16: .same(proto: "lastJoinChannelReq"),
    17: .same(proto: "accountSecurityReq"),
    18: .same(proto: "thirdPartyAccountReq"),
    19: .same(proto: "bindMobileReq"),
    20: .same(proto: "adolescentSettingReq"),
    21: .same(proto: "authenticationReq"),
    22: .same(proto: "settingPasswordReq"),
    23: .same(proto: "updatePasswordReq"),
    24: .same(proto: "resetPasswordReq"),
    25: .same(proto: "authenticationVerifyMobileReq"),
    26: .same(proto: "bindVerifyMobileReq"),
    27: .same(proto: "followReq"),
    28: .same(proto: "unfollowReq"),
    29: .same(proto: "logoutReq"),
    30: .same(proto: "reportReq"),
    31: .same(proto: "joinBlacklistReq"),
    32: .same(proto: "removeBlacklistReq"),
    33: .same(proto: "followingsListReq"),
    34: .same(proto: "followersListReq"),
    35: .same(proto: "userFeedbackReq"),
    36: .same(proto: "searchReq"),
    37: .same(proto: "signInAvatarReq"),
    38: .same(proto: "userWalletReq"),
    39: .same(proto: "idCardRecognitionReq"),
    40: .same(proto: "logoffReq"),
    41: .same(proto: "userMedalListReq"),
    42: .same(proto: "dressUpMallReq"),
    43: .same(proto: "buyDressUpReq"),
    44: .same(proto: "inviteReq"),
    45: .same(proto: "giveDressUpReq"),
    46: .same(proto: "myFriendsReq"),
    47: .same(proto: "visitRecordReq"),
    48: .same(proto: "eidolonOperationReq"),
    49: .same(proto: "loadBlacklistReq"),
    50: .same(proto: "honouredGuestCardsReq"),
    51: .same(proto: "fansClubBadgesReq"),
    52: .same(proto: "wearAndRemoveBadgeReq"),
    53: .same(proto: "fansClubRanksReq"),
    54: .same(proto: "fansClubExitReq"),
    55: .same(proto: "FaceVerifyReq"),
    56: .same(proto: "faceVerifyResultReq"),
    57: .same(proto: "userVoiceDialogueReportReq"),
    58: .same(proto: "userVoiceSoftDeleteReq"),
    59: .same(proto: "userVoiceSubmitReq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSLoginReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loginReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loginReq(v)
        }
      }()
      case 2: try {
        var v: OSViewReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .viewReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .viewReq(v)
        }
      }()
      case 3: try {
        var v: OSEditUserReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .editUserReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .editUserReq(v)
        }
      }()
      case 4: try {
        var v: OSUserPhotoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userPhotoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userPhotoReq(v)
        }
      }()
      case 5: try {
        var v: OSUploadPhotoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .uploadPhotoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .uploadPhotoReq(v)
        }
      }()
      case 6: try {
        var v: OSUploadPhotoListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .uploadPhotoListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .uploadPhotoListReq(v)
        }
      }()
      case 7: try {
        var v: OSDeletePhotoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deletePhotoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deletePhotoReq(v)
        }
      }()
      case 8: try {
        var v: OSDeletePhotoListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deletePhotoListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deletePhotoListReq(v)
        }
      }()
      case 9: try {
        var v: OSSigninInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .signinInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .signinInfoReq(v)
        }
      }()
      case 10: try {
        var v: OSUserSigninReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userSigninReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userSigninReq(v)
        }
      }()
      case 11: try {
        var v: OSDressUpTagsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .dressUpTagsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .dressUpTagsReq(v)
        }
      }()
      case 12: try {
        var v: OSUserDressUpReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userDressUpReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userDressUpReq(v)
        }
      }()
      case 13: try {
        var v: OSDressUpOperateReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .dressUpOperateReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .dressUpOperateReq(v)
        }
      }()
      case 14: try {
        var v: OSUserGiftWallReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userGiftWallReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userGiftWallReq(v)
        }
      }()
      case 15: try {
        var v: OSGiftDetailsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giftDetailsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giftDetailsReq(v)
        }
      }()
      case 16: try {
        var v: OSLastJoinChannelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lastJoinChannelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lastJoinChannelReq(v)
        }
      }()
      case 17: try {
        var v: OSAccountSecurityReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .accountSecurityReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .accountSecurityReq(v)
        }
      }()
      case 18: try {
        var v: OSThirdPartyAccountReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .thirdPartyAccountReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .thirdPartyAccountReq(v)
        }
      }()
      case 19: try {
        var v: OSBindMobileReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .bindMobileReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .bindMobileReq(v)
        }
      }()
      case 20: try {
        var v: OSAdolescentSettingReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .adolescentSettingReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .adolescentSettingReq(v)
        }
      }()
      case 21: try {
        var v: OSAuthenticationReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .authenticationReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .authenticationReq(v)
        }
      }()
      case 22: try {
        var v: OSSettingPasswordReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .settingPasswordReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .settingPasswordReq(v)
        }
      }()
      case 23: try {
        var v: OSUpdatePasswordReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .updatePasswordReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .updatePasswordReq(v)
        }
      }()
      case 24: try {
        var v: OSResetPasswordReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .resetPasswordReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .resetPasswordReq(v)
        }
      }()
      case 25: try {
        var v: OSAuthenticationVerifyMobileReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .authenticationVerifyMobileReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .authenticationVerifyMobileReq(v)
        }
      }()
      case 26: try {
        var v: OSBindVerifyMobileReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .bindVerifyMobileReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .bindVerifyMobileReq(v)
        }
      }()
      case 27: try {
        var v: OSFollowReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .followReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .followReq(v)
        }
      }()
      case 28: try {
        var v: OSUnfollowReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unfollowReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unfollowReq(v)
        }
      }()
      case 29: try {
        var v: OSLogoutReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .logoutReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .logoutReq(v)
        }
      }()
      case 30: try {
        var v: OSReportReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .reportReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .reportReq(v)
        }
      }()
      case 31: try {
        var v: OSJoinBlacklistReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinBlacklistReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinBlacklistReq(v)
        }
      }()
      case 32: try {
        var v: OSRemoveBlacklistReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .removeBlacklistReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .removeBlacklistReq(v)
        }
      }()
      case 33: try {
        var v: OSFollowingsListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .followingsListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .followingsListReq(v)
        }
      }()
      case 34: try {
        var v: OSFollowersListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .followersListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .followersListReq(v)
        }
      }()
      case 35: try {
        var v: OSUserFeedbackReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userFeedbackReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userFeedbackReq(v)
        }
      }()
      case 36: try {
        var v: OSSearchReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .searchReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .searchReq(v)
        }
      }()
      case 37: try {
        var v: OSSignInAvatarReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .signInAvatarReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .signInAvatarReq(v)
        }
      }()
      case 38: try {
        var v: OSUserWalletReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userWalletReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userWalletReq(v)
        }
      }()
      case 39: try {
        var v: OSIdCardRecognitionReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .idCardRecognitionReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .idCardRecognitionReq(v)
        }
      }()
      case 40: try {
        var v: OSLogoffReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .logoffReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .logoffReq(v)
        }
      }()
      case 41: try {
        var v: OSUserMedalListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userMedalListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userMedalListReq(v)
        }
      }()
      case 42: try {
        var v: OSDressUpMallReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .dressUpMallReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .dressUpMallReq(v)
        }
      }()
      case 43: try {
        var v: OSBuyDressUpReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .buyDressUpReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .buyDressUpReq(v)
        }
      }()
      case 44: try {
        var v: OSInviteReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .inviteReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .inviteReq(v)
        }
      }()
      case 45: try {
        var v: OSGiveDressUpReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giveDressUpReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giveDressUpReq(v)
        }
      }()
      case 46: try {
        var v: OSMyFriendsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .myFriendsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .myFriendsReq(v)
        }
      }()
      case 47: try {
        var v: OSVisitRecordReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .visitRecordReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .visitRecordReq(v)
        }
      }()
      case 48: try {
        var v: OSEidolonOperationReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .eidolonOperationReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .eidolonOperationReq(v)
        }
      }()
      case 49: try {
        var v: OSLoadBlacklistReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadBlacklistReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadBlacklistReq(v)
        }
      }()
      case 50: try {
        var v: OSHonouredGuestCardsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .honouredGuestCardsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .honouredGuestCardsReq(v)
        }
      }()
      case 51: try {
        var v: OSFansClubBadgesReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .fansClubBadgesReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .fansClubBadgesReq(v)
        }
      }()
      case 52: try {
        var v: OSWearAndRemoveBadgeReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wearAndRemoveBadgeReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wearAndRemoveBadgeReq(v)
        }
      }()
      case 53: try {
        var v: OSFansClubRanksReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .fansClubRanksReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .fansClubRanksReq(v)
        }
      }()
      case 54: try {
        var v: OSFansClubExitReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .fansClubExitReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .fansClubExitReq(v)
        }
      }()
      case 55: try {
        var v: OSFaceVerifyReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .faceVerifyReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .faceVerifyReq(v)
        }
      }()
      case 56: try {
        var v: OSFaceVerifyResultReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .faceVerifyResultReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .faceVerifyResultReq(v)
        }
      }()
      case 57: try {
        var v: OSUserVoiceDialogueReportReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userVoiceDialogueReportReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userVoiceDialogueReportReq(v)
        }
      }()
      case 58: try {
        var v: OSUserVoiceSoftDeleteReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userVoiceSoftDeleteReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userVoiceSoftDeleteReq(v)
        }
      }()
      case 59: try {
        var v: OSUserVoiceSubmitReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userVoiceSubmitReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userVoiceSubmitReq(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .loginReq?: try {
      guard case .loginReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .viewReq?: try {
      guard case .viewReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .editUserReq?: try {
      guard case .editUserReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .userPhotoReq?: try {
      guard case .userPhotoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .uploadPhotoReq?: try {
      guard case .uploadPhotoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .uploadPhotoListReq?: try {
      guard case .uploadPhotoListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deletePhotoReq?: try {
      guard case .deletePhotoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deletePhotoListReq?: try {
      guard case .deletePhotoListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .signinInfoReq?: try {
      guard case .signinInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .userSigninReq?: try {
      guard case .userSigninReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .dressUpTagsReq?: try {
      guard case .dressUpTagsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .userDressUpReq?: try {
      guard case .userDressUpReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .dressUpOperateReq?: try {
      guard case .dressUpOperateReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .userGiftWallReq?: try {
      guard case .userGiftWallReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .giftDetailsReq?: try {
      guard case .giftDetailsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .lastJoinChannelReq?: try {
      guard case .lastJoinChannelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .accountSecurityReq?: try {
      guard case .accountSecurityReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .thirdPartyAccountReq?: try {
      guard case .thirdPartyAccountReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .bindMobileReq?: try {
      guard case .bindMobileReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .adolescentSettingReq?: try {
      guard case .adolescentSettingReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .authenticationReq?: try {
      guard case .authenticationReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .settingPasswordReq?: try {
      guard case .settingPasswordReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .updatePasswordReq?: try {
      guard case .updatePasswordReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .resetPasswordReq?: try {
      guard case .resetPasswordReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .authenticationVerifyMobileReq?: try {
      guard case .authenticationVerifyMobileReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .bindVerifyMobileReq?: try {
      guard case .bindVerifyMobileReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .followReq?: try {
      guard case .followReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .unfollowReq?: try {
      guard case .unfollowReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .logoutReq?: try {
      guard case .logoutReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .reportReq?: try {
      guard case .reportReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .joinBlacklistReq?: try {
      guard case .joinBlacklistReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .removeBlacklistReq?: try {
      guard case .removeBlacklistReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .followingsListReq?: try {
      guard case .followingsListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .followersListReq?: try {
      guard case .followersListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .userFeedbackReq?: try {
      guard case .userFeedbackReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .searchReq?: try {
      guard case .searchReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .signInAvatarReq?: try {
      guard case .signInAvatarReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .userWalletReq?: try {
      guard case .userWalletReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .idCardRecognitionReq?: try {
      guard case .idCardRecognitionReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .logoffReq?: try {
      guard case .logoffReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .userMedalListReq?: try {
      guard case .userMedalListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .dressUpMallReq?: try {
      guard case .dressUpMallReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .buyDressUpReq?: try {
      guard case .buyDressUpReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .inviteReq?: try {
      guard case .inviteReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .giveDressUpReq?: try {
      guard case .giveDressUpReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .myFriendsReq?: try {
      guard case .myFriendsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .visitRecordReq?: try {
      guard case .visitRecordReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .eidolonOperationReq?: try {
      guard case .eidolonOperationReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .loadBlacklistReq?: try {
      guard case .loadBlacklistReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .honouredGuestCardsReq?: try {
      guard case .honouredGuestCardsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .fansClubBadgesReq?: try {
      guard case .fansClubBadgesReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .wearAndRemoveBadgeReq?: try {
      guard case .wearAndRemoveBadgeReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .fansClubRanksReq?: try {
      guard case .fansClubRanksReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .fansClubExitReq?: try {
      guard case .fansClubExitReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .faceVerifyReq?: try {
      guard case .faceVerifyReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .faceVerifyResultReq?: try {
      guard case .faceVerifyResultReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .userVoiceDialogueReportReq?: try {
      guard case .userVoiceDialogueReportReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .userVoiceSoftDeleteReq?: try {
      guard case .userVoiceSoftDeleteReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .userVoiceSubmitReq?: try {
      guard case .userVoiceSubmitReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserRequest, rhs: OSUserRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loginRes"),
    2: .same(proto: "viewRes"),
    3: .same(proto: "editUserRes"),
    4: .same(proto: "userPhotoReq"),
    5: .same(proto: "uploadPhotoRes"),
    6: .same(proto: "uploadPhotoListRes"),
    7: .same(proto: "deletePhotoRes"),
    8: .same(proto: "deletePhotoListRes"),
    9: .same(proto: "signinInfoRes"),
    10: .same(proto: "userSigninRes"),
    11: .same(proto: "dressUpTagsRes"),
    12: .same(proto: "userDressUpRes"),
    13: .same(proto: "dressUpOperateRes"),
    14: .same(proto: "userGiftWallRes"),
    15: .same(proto: "giftDetailsRes"),
    16: .same(proto: "lastJoinChannelRes"),
    17: .same(proto: "accountSecurityRes"),
    18: .same(proto: "thirdPartyAccountRes"),
    19: .same(proto: "bindMobileRes"),
    20: .same(proto: "adolescentSettingRes"),
    21: .same(proto: "authenticationRes"),
    22: .same(proto: "settingPasswordRes"),
    23: .same(proto: "updatePasswordRes"),
    24: .same(proto: "resetPasswordRes"),
    25: .same(proto: "authenticationVerifyMobileRes"),
    26: .same(proto: "bindVerifyMobileRes"),
    27: .same(proto: "followRes"),
    28: .same(proto: "unfollowRes"),
    29: .same(proto: "logoutRes"),
    30: .same(proto: "reportRes"),
    31: .same(proto: "joinBlacklistRes"),
    32: .same(proto: "removeBlacklistRes"),
    33: .same(proto: "followingsListRes"),
    34: .same(proto: "followersListRes"),
    35: .same(proto: "userFeedbackRes"),
    36: .same(proto: "searchRes"),
    37: .same(proto: "signInAvatarRes"),
    38: .same(proto: "userWalletRes"),
    39: .same(proto: "idCardRecognitionRes"),
    40: .same(proto: "logoffRes"),
    41: .same(proto: "userMedalListRes"),
    42: .same(proto: "dressUpMallRes"),
    43: .same(proto: "buyDressUpRes"),
    44: .same(proto: "inviteRes"),
    45: .same(proto: "giveDressUpRes"),
    46: .same(proto: "myFriendsRes"),
    47: .same(proto: "visitRecordRes"),
    48: .same(proto: "eidolonOperationRes"),
    49: .same(proto: "loadBlacklistRes"),
    50: .same(proto: "honouredGuestCardsRes"),
    51: .same(proto: "fansClubBadgesRes"),
    52: .same(proto: "wearAndRemoveBadgeRes"),
    53: .same(proto: "fansClubRanksRes"),
    54: .same(proto: "fansClubExitRes"),
    55: .same(proto: "FaceVerifyRes"),
    56: .same(proto: "faceVerifyResultRes"),
    57: .same(proto: "userVoiceDialogueReportRes"),
    58: .same(proto: "userVoiceSoftDeleteRes"),
    59: .same(proto: "userVoiceSubmitRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSLoginRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loginRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loginRes(v)
        }
      }()
      case 2: try {
        var v: OSViewRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .viewRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .viewRes(v)
        }
      }()
      case 3: try {
        var v: OSEditUserRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .editUserRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .editUserRes(v)
        }
      }()
      case 4: try {
        var v: OSUserPhotoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userPhotoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userPhotoReq(v)
        }
      }()
      case 5: try {
        var v: OSUploadPhotoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .uploadPhotoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .uploadPhotoRes(v)
        }
      }()
      case 6: try {
        var v: OSUploadPhotoListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .uploadPhotoListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .uploadPhotoListRes(v)
        }
      }()
      case 7: try {
        var v: OSDeletePhotoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deletePhotoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deletePhotoRes(v)
        }
      }()
      case 8: try {
        var v: OSDeletePhotoListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deletePhotoListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deletePhotoListRes(v)
        }
      }()
      case 9: try {
        var v: OSSigninInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .signinInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .signinInfoRes(v)
        }
      }()
      case 10: try {
        var v: OSUserSigninRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userSigninRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userSigninRes(v)
        }
      }()
      case 11: try {
        var v: OSDressUpTagsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .dressUpTagsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .dressUpTagsRes(v)
        }
      }()
      case 12: try {
        var v: OSUserDressUpRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userDressUpRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userDressUpRes(v)
        }
      }()
      case 13: try {
        var v: OSDressUpOperateRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .dressUpOperateRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .dressUpOperateRes(v)
        }
      }()
      case 14: try {
        var v: OSUserGiftWallRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userGiftWallRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userGiftWallRes(v)
        }
      }()
      case 15: try {
        var v: OSGiftDetailsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giftDetailsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giftDetailsRes(v)
        }
      }()
      case 16: try {
        var v: OSLastJoinChannelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .lastJoinChannelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .lastJoinChannelRes(v)
        }
      }()
      case 17: try {
        var v: OSAccountSecurityRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .accountSecurityRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .accountSecurityRes(v)
        }
      }()
      case 18: try {
        var v: OSThirdPartyAccountRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .thirdPartyAccountRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .thirdPartyAccountRes(v)
        }
      }()
      case 19: try {
        var v: OSBindMobileRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .bindMobileRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .bindMobileRes(v)
        }
      }()
      case 20: try {
        var v: OSAdolescentSettingRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .adolescentSettingRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .adolescentSettingRes(v)
        }
      }()
      case 21: try {
        var v: OSAuthenticationRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .authenticationRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .authenticationRes(v)
        }
      }()
      case 22: try {
        var v: OSSettingPasswordRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .settingPasswordRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .settingPasswordRes(v)
        }
      }()
      case 23: try {
        var v: OSUpdatePasswordRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .updatePasswordRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .updatePasswordRes(v)
        }
      }()
      case 24: try {
        var v: OSResetPasswordRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .resetPasswordRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .resetPasswordRes(v)
        }
      }()
      case 25: try {
        var v: OSAuthenticationVerifyMobileRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .authenticationVerifyMobileRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .authenticationVerifyMobileRes(v)
        }
      }()
      case 26: try {
        var v: OSBindVerifyMobileRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .bindVerifyMobileRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .bindVerifyMobileRes(v)
        }
      }()
      case 27: try {
        var v: OSFollowRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .followRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .followRes(v)
        }
      }()
      case 28: try {
        var v: OSUnfollowRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .unfollowRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .unfollowRes(v)
        }
      }()
      case 29: try {
        var v: OSLogoutRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .logoutRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .logoutRes(v)
        }
      }()
      case 30: try {
        var v: OSReportRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .reportRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .reportRes(v)
        }
      }()
      case 31: try {
        var v: OSJoinBlacklistRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .joinBlacklistRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .joinBlacklistRes(v)
        }
      }()
      case 32: try {
        var v: OSRemoveBlacklistRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .removeBlacklistRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .removeBlacklistRes(v)
        }
      }()
      case 33: try {
        var v: OSFollowingsListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .followingsListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .followingsListRes(v)
        }
      }()
      case 34: try {
        var v: OSFollowersListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .followersListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .followersListRes(v)
        }
      }()
      case 35: try {
        var v: OSUserFeedbackRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userFeedbackRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userFeedbackRes(v)
        }
      }()
      case 36: try {
        var v: OSSearchRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .searchRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .searchRes(v)
        }
      }()
      case 37: try {
        var v: OSSignInAvatarRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .signInAvatarRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .signInAvatarRes(v)
        }
      }()
      case 38: try {
        var v: OSUserWalletRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userWalletRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userWalletRes(v)
        }
      }()
      case 39: try {
        var v: OSIdCardRecognitionRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .idCardRecognitionRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .idCardRecognitionRes(v)
        }
      }()
      case 40: try {
        var v: OSLogoffRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .logoffRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .logoffRes(v)
        }
      }()
      case 41: try {
        var v: OSUserMedalListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userMedalListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userMedalListRes(v)
        }
      }()
      case 42: try {
        var v: OSDressUpMallRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .dressUpMallRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .dressUpMallRes(v)
        }
      }()
      case 43: try {
        var v: OSBuyDressUpRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .buyDressUpRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .buyDressUpRes(v)
        }
      }()
      case 44: try {
        var v: OSInviteRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .inviteRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .inviteRes(v)
        }
      }()
      case 45: try {
        var v: OSGiveDressUpRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .giveDressUpRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .giveDressUpRes(v)
        }
      }()
      case 46: try {
        var v: OSMyFriendsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .myFriendsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .myFriendsRes(v)
        }
      }()
      case 47: try {
        var v: OSVisitRecordRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .visitRecordRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .visitRecordRes(v)
        }
      }()
      case 48: try {
        var v: OSEidolonOperationRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .eidolonOperationRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .eidolonOperationRes(v)
        }
      }()
      case 49: try {
        var v: OSLoadBlacklistRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadBlacklistRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadBlacklistRes(v)
        }
      }()
      case 50: try {
        var v: OSHonouredGuestCardsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .honouredGuestCardsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .honouredGuestCardsRes(v)
        }
      }()
      case 51: try {
        var v: OSFansClubBadgesRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .fansClubBadgesRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .fansClubBadgesRes(v)
        }
      }()
      case 52: try {
        var v: OSWearAndRemoveBadgeRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wearAndRemoveBadgeRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wearAndRemoveBadgeRes(v)
        }
      }()
      case 53: try {
        var v: OSFansClubRanksRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .fansClubRanksRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .fansClubRanksRes(v)
        }
      }()
      case 54: try {
        var v: OSFansClubExitRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .fansClubExitRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .fansClubExitRes(v)
        }
      }()
      case 55: try {
        var v: OSFaceVerifyRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .faceVerifyRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .faceVerifyRes(v)
        }
      }()
      case 56: try {
        var v: OSFaceVerifyResultRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .faceVerifyResultRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .faceVerifyResultRes(v)
        }
      }()
      case 57: try {
        var v: OSUserVoiceDialogueReportRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userVoiceDialogueReportRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userVoiceDialogueReportRes(v)
        }
      }()
      case 58: try {
        var v: OSUserVoiceSoftDeleteRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userVoiceSoftDeleteRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userVoiceSoftDeleteRes(v)
        }
      }()
      case 59: try {
        var v: OSUserVoiceSubmitRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .userVoiceSubmitRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .userVoiceSubmitRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .loginRes?: try {
      guard case .loginRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .viewRes?: try {
      guard case .viewRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .editUserRes?: try {
      guard case .editUserRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .userPhotoReq?: try {
      guard case .userPhotoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .uploadPhotoRes?: try {
      guard case .uploadPhotoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .uploadPhotoListRes?: try {
      guard case .uploadPhotoListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deletePhotoRes?: try {
      guard case .deletePhotoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deletePhotoListRes?: try {
      guard case .deletePhotoListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .signinInfoRes?: try {
      guard case .signinInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .userSigninRes?: try {
      guard case .userSigninRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .dressUpTagsRes?: try {
      guard case .dressUpTagsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .userDressUpRes?: try {
      guard case .userDressUpRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .dressUpOperateRes?: try {
      guard case .dressUpOperateRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .userGiftWallRes?: try {
      guard case .userGiftWallRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .giftDetailsRes?: try {
      guard case .giftDetailsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .lastJoinChannelRes?: try {
      guard case .lastJoinChannelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .accountSecurityRes?: try {
      guard case .accountSecurityRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .thirdPartyAccountRes?: try {
      guard case .thirdPartyAccountRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .bindMobileRes?: try {
      guard case .bindMobileRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .adolescentSettingRes?: try {
      guard case .adolescentSettingRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .authenticationRes?: try {
      guard case .authenticationRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .settingPasswordRes?: try {
      guard case .settingPasswordRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .updatePasswordRes?: try {
      guard case .updatePasswordRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .resetPasswordRes?: try {
      guard case .resetPasswordRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .authenticationVerifyMobileRes?: try {
      guard case .authenticationVerifyMobileRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .bindVerifyMobileRes?: try {
      guard case .bindVerifyMobileRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .followRes?: try {
      guard case .followRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .unfollowRes?: try {
      guard case .unfollowRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .logoutRes?: try {
      guard case .logoutRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .reportRes?: try {
      guard case .reportRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .joinBlacklistRes?: try {
      guard case .joinBlacklistRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .removeBlacklistRes?: try {
      guard case .removeBlacklistRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .followingsListRes?: try {
      guard case .followingsListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .followersListRes?: try {
      guard case .followersListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .userFeedbackRes?: try {
      guard case .userFeedbackRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .searchRes?: try {
      guard case .searchRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .signInAvatarRes?: try {
      guard case .signInAvatarRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .userWalletRes?: try {
      guard case .userWalletRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .idCardRecognitionRes?: try {
      guard case .idCardRecognitionRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .logoffRes?: try {
      guard case .logoffRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .userMedalListRes?: try {
      guard case .userMedalListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .dressUpMallRes?: try {
      guard case .dressUpMallRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .buyDressUpRes?: try {
      guard case .buyDressUpRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .inviteRes?: try {
      guard case .inviteRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .giveDressUpRes?: try {
      guard case .giveDressUpRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .myFriendsRes?: try {
      guard case .myFriendsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .visitRecordRes?: try {
      guard case .visitRecordRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .eidolonOperationRes?: try {
      guard case .eidolonOperationRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .loadBlacklistRes?: try {
      guard case .loadBlacklistRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .honouredGuestCardsRes?: try {
      guard case .honouredGuestCardsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .fansClubBadgesRes?: try {
      guard case .fansClubBadgesRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .wearAndRemoveBadgeRes?: try {
      guard case .wearAndRemoveBadgeRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .fansClubRanksRes?: try {
      guard case .fansClubRanksRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .fansClubExitRes?: try {
      guard case .fansClubExitRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .faceVerifyRes?: try {
      guard case .faceVerifyRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .faceVerifyResultRes?: try {
      guard case .faceVerifyResultRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .userVoiceDialogueReportRes?: try {
      guard case .userVoiceDialogueReportRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .userVoiceSoftDeleteRes?: try {
      guard case .userVoiceSoftDeleteRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .userVoiceSubmitRes?: try {
      guard case .userVoiceSubmitRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserResponse, rhs: OSUserResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoginReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "credential"),
    3: .same(proto: "identityType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.credential) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identityType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    if !self.credential.isEmpty {
      try visitor.visitSingularStringField(value: self.credential, fieldNumber: 2)
    }
    if !self.identityType.isEmpty {
      try visitor.visitSingularStringField(value: self.identityType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoginReq, rhs: OSLoginReq) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.credential != rhs.credential {return false}
    if lhs.identityType != rhs.identityType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoginRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "myChannel"),
    3: .same(proto: "user"),
    4: .same(proto: "userSetting"),
    5: .same(proto: "signinInfo"),
    6: .same(proto: "signinInfo2"),
    7: .same(proto: "medalList"),
    8: .same(proto: "bindMobile"),
    9: .same(proto: "inviteConfig"),
    10: .same(proto: "isNew"),
    11: .same(proto: "privateChannelToken"),
    12: .same(proto: "hasEdit"),
    13: .same(proto: "openAdolescentModel"),
    14: .same(proto: "eidolonInfo"),
  ]

  fileprivate class _StorageClass {
    var _token: String = String()
    var _myChannel: OSChannelVo? = nil
    var _user: OSUserVo? = nil
    var _userSetting: OSUserSetting? = nil
    var _signinInfo: OSSigninInfo? = nil
    var _signinInfo2: OSSigninInfo2? = nil
    var _medalList: [OSMedalList] = []
    var _bindMobile: OSBindMobile? = nil
    var _inviteConfig: OSInviteConfig? = nil
    var _isNew: Int32 = 0
    var _privateChannelToken: String = String()
    var _hasEdit_p: Int32 = 0
    var _openAdolescentModel: Int32 = 0
    var _eidolonInfo: OSEidolonInfo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _myChannel = source._myChannel
      _user = source._user
      _userSetting = source._userSetting
      _signinInfo = source._signinInfo
      _signinInfo2 = source._signinInfo2
      _medalList = source._medalList
      _bindMobile = source._bindMobile
      _inviteConfig = source._inviteConfig
      _isNew = source._isNew
      _privateChannelToken = source._privateChannelToken
      _hasEdit_p = source._hasEdit_p
      _openAdolescentModel = source._openAdolescentModel
      _eidolonInfo = source._eidolonInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._myChannel) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._userSetting) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._signinInfo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._signinInfo2) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._bindMobile) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._inviteConfig) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._isNew) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._privateChannelToken) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._hasEdit_p) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._openAdolescentModel) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._eidolonInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 1)
      }
      try { if let v = _storage._myChannel {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._userSetting {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._signinInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._signinInfo2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 7)
      }
      try { if let v = _storage._bindMobile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._inviteConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._isNew != 0 {
        try visitor.visitSingularInt32Field(value: _storage._isNew, fieldNumber: 10)
      }
      if !_storage._privateChannelToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._privateChannelToken, fieldNumber: 11)
      }
      if _storage._hasEdit_p != 0 {
        try visitor.visitSingularInt32Field(value: _storage._hasEdit_p, fieldNumber: 12)
      }
      if _storage._openAdolescentModel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._openAdolescentModel, fieldNumber: 13)
      }
      try { if let v = _storage._eidolonInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoginRes, rhs: OSLoginRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._myChannel != rhs_storage._myChannel {return false}
        if _storage._user != rhs_storage._user {return false}
        if _storage._userSetting != rhs_storage._userSetting {return false}
        if _storage._signinInfo != rhs_storage._signinInfo {return false}
        if _storage._signinInfo2 != rhs_storage._signinInfo2 {return false}
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._bindMobile != rhs_storage._bindMobile {return false}
        if _storage._inviteConfig != rhs_storage._inviteConfig {return false}
        if _storage._isNew != rhs_storage._isNew {return false}
        if _storage._privateChannelToken != rhs_storage._privateChannelToken {return false}
        if _storage._hasEdit_p != rhs_storage._hasEdit_p {return false}
        if _storage._openAdolescentModel != rhs_storage._openAdolescentModel {return false}
        if _storage._eidolonInfo != rhs_storage._eidolonInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSigninInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigninInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "secondPrompt"),
    2: .same(proto: "giftIcon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.secondPrompt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftIcon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.secondPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.secondPrompt, fieldNumber: 1)
    }
    if !self.giftIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIcon, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSigninInfo, rhs: OSSigninInfo) -> Bool {
    if lhs.secondPrompt != rhs.secondPrompt {return false}
    if lhs.giftIcon != rhs.giftIcon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSigninInfo2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigninInfo2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prizeList"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.prizeList) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prizeList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prizeList, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSigninInfo2, rhs: OSSigninInfo2) -> Bool {
    if lhs.prizeList != rhs.prizeList {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPrizeList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrizeList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "iconUrl"),
    3: .same(proto: "count"),
    4: .same(proto: "prizeType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.prizeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    if self.prizeType != 0 {
      try visitor.visitSingularInt32Field(value: self.prizeType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPrizeList, rhs: OSPrizeList) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.count != rhs.count {return false}
    if lhs.prizeType != rhs.prizeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBindMobile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindMobile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isBindMobile"),
    2: .same(proto: "createChannelAuth"),
    3: .same(proto: "publicChatAuth"),
    4: .same(proto: "momentAuth"),
    5: .same(proto: "upSeatAuth"),
    6: .same(proto: "commentAuth"),
    7: .same(proto: "displayMobile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.isBindMobile) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.createChannelAuth) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.publicChatAuth) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.momentAuth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.upSeatAuth) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.commentAuth) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.displayMobile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isBindMobile != 0 {
      try visitor.visitSingularInt32Field(value: self.isBindMobile, fieldNumber: 1)
    }
    if self.createChannelAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.createChannelAuth, fieldNumber: 2)
    }
    if self.publicChatAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.publicChatAuth, fieldNumber: 3)
    }
    if self.momentAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.momentAuth, fieldNumber: 4)
    }
    if self.upSeatAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.upSeatAuth, fieldNumber: 5)
    }
    if self.commentAuth != 0 {
      try visitor.visitSingularInt32Field(value: self.commentAuth, fieldNumber: 6)
    }
    if !self.displayMobile.isEmpty {
      try visitor.visitSingularStringField(value: self.displayMobile, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBindMobile, rhs: OSBindMobile) -> Bool {
    if lhs.isBindMobile != rhs.isBindMobile {return false}
    if lhs.createChannelAuth != rhs.createChannelAuth {return false}
    if lhs.publicChatAuth != rhs.publicChatAuth {return false}
    if lhs.momentAuth != rhs.momentAuth {return false}
    if lhs.upSeatAuth != rhs.upSeatAuth {return false}
    if lhs.commentAuth != rhs.commentAuth {return false}
    if lhs.displayMobile != rhs.displayMobile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSInviteConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InviteConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "skipType"),
    2: .same(proto: "skipChannelId"),
    3: .same(proto: "lockRoom"),
    4: .same(proto: "invitationStatus"),
    5: .same(proto: "editCodeEntrance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.skipType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.skipChannelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lockRoom) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.invitationStatus) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.editCodeEntrance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.skipType != 0 {
      try visitor.visitSingularInt32Field(value: self.skipType, fieldNumber: 1)
    }
    if !self.skipChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.skipChannelID, fieldNumber: 2)
    }
    if self.lockRoom != 0 {
      try visitor.visitSingularInt32Field(value: self.lockRoom, fieldNumber: 3)
    }
    if self.invitationStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.invitationStatus, fieldNumber: 4)
    }
    if self.editCodeEntrance != 0 {
      try visitor.visitSingularInt32Field(value: self.editCodeEntrance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSInviteConfig, rhs: OSInviteConfig) -> Bool {
    if lhs.skipType != rhs.skipType {return false}
    if lhs.skipChannelID != rhs.skipChannelID {return false}
    if lhs.lockRoom != rhs.lockRoom {return false}
    if lhs.invitationStatus != rhs.invitationStatus {return false}
    if lhs.editCodeEntrance != rhs.editCodeEntrance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSViewReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSViewReq, rhs: OSViewReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSViewRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "medalList"),
    3: .same(proto: "dressUpInfo"),
    4: .same(proto: "family"),
    5: .same(proto: "other"),
    6: .same(proto: "currentLocation"),
    7: .same(proto: "following"),
    8: .same(proto: "blacklistStatus"),
    9: .same(proto: "withdrawSwitch"),
    10: .same(proto: "walletSwitch"),
    11: .same(proto: "checkCode"),
    12: .same(proto: "honouredGuestCards"),
    13: .same(proto: "fansClubs"),
    15: .same(proto: "fansBadge"),
    16: .same(proto: "collectHallInfo"),
  ]

  fileprivate class _StorageClass {
    var _user: OSUserVo? = nil
    var _medalList: [OSMedalList] = []
    var _dressUpInfo: OSDressUpInfo? = nil
    var _family: OSFamily? = nil
    var _other: OSOther? = nil
    var _currentLocation: OSChannelVo? = nil
    var _following: Int32 = 0
    var _blacklistStatus: Int32 = 0
    var _withdrawSwitch: Int32 = 0
    var _walletSwitch: Int32 = 0
    var _checkCode: String = String()
    var _honouredGuestCards: [OSHonouredGuestCard] = []
    var _fansClubs: [OSFansClubBadge] = []
    var _fansBadge: OSFansClubVo? = nil
    var _collectHallInfo: OSCollectionHallVo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _user = source._user
      _medalList = source._medalList
      _dressUpInfo = source._dressUpInfo
      _family = source._family
      _other = source._other
      _currentLocation = source._currentLocation
      _following = source._following
      _blacklistStatus = source._blacklistStatus
      _withdrawSwitch = source._withdrawSwitch
      _walletSwitch = source._walletSwitch
      _checkCode = source._checkCode
      _honouredGuestCards = source._honouredGuestCards
      _fansClubs = source._fansClubs
      _fansBadge = source._fansBadge
      _collectHallInfo = source._collectHallInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._user) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dressUpInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._family) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._other) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._currentLocation) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._following) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._blacklistStatus) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._withdrawSwitch) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._walletSwitch) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._checkCode) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._honouredGuestCards) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._fansClubs) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._fansBadge) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._collectHallInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._user {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 2)
      }
      try { if let v = _storage._dressUpInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._family {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._other {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._currentLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._following != 0 {
        try visitor.visitSingularInt32Field(value: _storage._following, fieldNumber: 7)
      }
      if _storage._blacklistStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blacklistStatus, fieldNumber: 8)
      }
      if _storage._withdrawSwitch != 0 {
        try visitor.visitSingularInt32Field(value: _storage._withdrawSwitch, fieldNumber: 9)
      }
      if _storage._walletSwitch != 0 {
        try visitor.visitSingularInt32Field(value: _storage._walletSwitch, fieldNumber: 10)
      }
      if !_storage._checkCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._checkCode, fieldNumber: 11)
      }
      if !_storage._honouredGuestCards.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._honouredGuestCards, fieldNumber: 12)
      }
      if !_storage._fansClubs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fansClubs, fieldNumber: 13)
      }
      try { if let v = _storage._fansBadge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._collectHallInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSViewRes, rhs: OSViewRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._user != rhs_storage._user {return false}
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._dressUpInfo != rhs_storage._dressUpInfo {return false}
        if _storage._family != rhs_storage._family {return false}
        if _storage._other != rhs_storage._other {return false}
        if _storage._currentLocation != rhs_storage._currentLocation {return false}
        if _storage._following != rhs_storage._following {return false}
        if _storage._blacklistStatus != rhs_storage._blacklistStatus {return false}
        if _storage._withdrawSwitch != rhs_storage._withdrawSwitch {return false}
        if _storage._walletSwitch != rhs_storage._walletSwitch {return false}
        if _storage._checkCode != rhs_storage._checkCode {return false}
        if _storage._honouredGuestCards != rhs_storage._honouredGuestCards {return false}
        if _storage._fansClubs != rhs_storage._fansClubs {return false}
        if _storage._fansBadge != rhs_storage._fansBadge {return false}
        if _storage._collectHallInfo != rhs_storage._collectHallInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Family"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "familyId"),
    2: .same(proto: "familyAccountId"),
    3: .same(proto: "familyName"),
    4: .same(proto: "familyAvatarUrl"),
    5: .same(proto: "familyMessage"),
    6: .same(proto: "type"),
    7: .same(proto: "familySignInvite"),
    8: .same(proto: "powerType"),
    9: .same(proto: "familySignRecordId"),
    10: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.familyAccountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.familyAvatarURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.familyMessage) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.familySignInvite) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.powerType) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.familySignRecordID) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.familyID.isEmpty {
      try visitor.visitSingularStringField(value: self.familyID, fieldNumber: 1)
    }
    if self.familyAccountID != 0 {
      try visitor.visitSingularInt32Field(value: self.familyAccountID, fieldNumber: 2)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 3)
    }
    if !self.familyAvatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.familyAvatarURL, fieldNumber: 4)
    }
    if self.familyMessage != 0 {
      try visitor.visitSingularInt32Field(value: self.familyMessage, fieldNumber: 5)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 6)
    }
    if self.familySignInvite != 0 {
      try visitor.visitSingularInt32Field(value: self.familySignInvite, fieldNumber: 7)
    }
    if !self.powerType.isEmpty {
      try visitor.visitSingularStringField(value: self.powerType, fieldNumber: 8)
    }
    if self.familySignRecordID != 0 {
      try visitor.visitSingularInt64Field(value: self.familySignRecordID, fieldNumber: 9)
    }
    if self.source != 0 {
      try visitor.visitSingularInt64Field(value: self.source, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFamily, rhs: OSFamily) -> Bool {
    if lhs.familyID != rhs.familyID {return false}
    if lhs.familyAccountID != rhs.familyAccountID {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.familyAvatarURL != rhs.familyAvatarURL {return false}
    if lhs.familyMessage != rhs.familyMessage {return false}
    if lhs.type != rhs.type {return false}
    if lhs.familySignInvite != rhs.familySignInvite {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.familySignRecordID != rhs.familySignRecordID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOther: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Other"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "following"),
    2: .same(proto: "followers"),
    3: .same(proto: "friends"),
    4: .same(proto: "invitation"),
    5: .same(proto: "momentCount"),
    6: .same(proto: "footprint"),
    7: .same(proto: "isGenderModify"),
    8: .same(proto: "visitCount"),
    9: .same(proto: "hasCertification"),
    10: .same(proto: "faceVerification"),
    11: .same(proto: "displayName"),
    12: .same(proto: "displayNumber"),
    13: .same(proto: "myFansClubState"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.following) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.followers) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.friends) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.invitation) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.momentCount) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.footprint) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.isGenderModify) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.visitCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.hasCertification_p) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.faceVerification) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.displayNumber) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.myFansClubState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.following != 0 {
      try visitor.visitSingularInt32Field(value: self.following, fieldNumber: 1)
    }
    if self.followers != 0 {
      try visitor.visitSingularInt32Field(value: self.followers, fieldNumber: 2)
    }
    if self.friends != 0 {
      try visitor.visitSingularInt32Field(value: self.friends, fieldNumber: 3)
    }
    if self.invitation != 0 {
      try visitor.visitSingularInt32Field(value: self.invitation, fieldNumber: 4)
    }
    if self.momentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.momentCount, fieldNumber: 5)
    }
    if self.footprint != 0 {
      try visitor.visitSingularInt32Field(value: self.footprint, fieldNumber: 6)
    }
    if self.isGenderModify != 0 {
      try visitor.visitSingularInt32Field(value: self.isGenderModify, fieldNumber: 7)
    }
    if self.visitCount != 0 {
      try visitor.visitSingularInt32Field(value: self.visitCount, fieldNumber: 8)
    }
    if self.hasCertification_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasCertification_p, fieldNumber: 9)
    }
    if self.faceVerification != 0 {
      try visitor.visitSingularInt32Field(value: self.faceVerification, fieldNumber: 10)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 11)
    }
    if !self.displayNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.displayNumber, fieldNumber: 12)
    }
    if self.myFansClubState != 0 {
      try visitor.visitSingularInt32Field(value: self.myFansClubState, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOther, rhs: OSOther) -> Bool {
    if lhs.following != rhs.following {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.friends != rhs.friends {return false}
    if lhs.invitation != rhs.invitation {return false}
    if lhs.momentCount != rhs.momentCount {return false}
    if lhs.footprint != rhs.footprint {return false}
    if lhs.isGenderModify != rhs.isGenderModify {return false}
    if lhs.visitCount != rhs.visitCount {return false}
    if lhs.hasCertification_p != rhs.hasCertification_p {return false}
    if lhs.faceVerification != rhs.faceVerification {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.displayNumber != rhs.displayNumber {return false}
    if lhs.myFansClubState != rhs.myFansClubState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubBadge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubBadge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubId"),
    2: .same(proto: "level"),
    3: .same(proto: "badgeName"),
    4: .same(proto: "badgeIcon"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clubID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.badgeName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.badgeIcon) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clubID != 0 {
      try visitor.visitSingularInt64Field(value: self.clubID, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 2)
    }
    if !self.badgeName.isEmpty {
      try visitor.visitSingularStringField(value: self.badgeName, fieldNumber: 3)
    }
    if !self.badgeIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.badgeIcon, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubBadge, rhs: OSFansClubBadge) -> Bool {
    if lhs.clubID != rhs.clubID {return false}
    if lhs.level != rhs.level {return false}
    if lhs.badgeName != rhs.badgeName {return false}
    if lhs.badgeIcon != rhs.badgeIcon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEditUserReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditUserReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nickname"),
    2: .same(proto: "gender"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "birthday"),
    5: .same(proto: "signature"),
    6: .same(proto: "inviteCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.birthday) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.inviteCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 1)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if !self.birthday.isEmpty {
      try visitor.visitSingularStringField(value: self.birthday, fieldNumber: 4)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
    }
    if !self.inviteCode.isEmpty {
      try visitor.visitSingularStringField(value: self.inviteCode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEditUserReq, rhs: OSEditUserReq) -> Bool {
    if lhs.nickname != rhs.nickname {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.birthday != rhs.birthday {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.inviteCode != rhs.inviteCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEditUserRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditUserRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "channelId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "nickname"),
    5: .same(proto: "avatarUrl"),
    6: .same(proto: "gender"),
    7: .same(proto: "birthday"),
    8: .same(proto: "signature"),
    9: .same(proto: "followers"),
    10: .same(proto: "following"),
    11: .same(proto: "adminFlag"),
    12: .same(proto: "inviteConfig"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.birthday) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.signature) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.followers) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.following) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.adminFlag) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._inviteConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 4)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    if !self.birthday.isEmpty {
      try visitor.visitSingularStringField(value: self.birthday, fieldNumber: 7)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 8)
    }
    if self.followers != 0 {
      try visitor.visitSingularInt32Field(value: self.followers, fieldNumber: 9)
    }
    if self.following != 0 {
      try visitor.visitSingularInt32Field(value: self.following, fieldNumber: 10)
    }
    if self.adminFlag != 0 {
      try visitor.visitSingularInt32Field(value: self.adminFlag, fieldNumber: 11)
    }
    try { if let v = self._inviteConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEditUserRes, rhs: OSEditUserRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.birthday != rhs.birthday {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs.following != rhs.following {return false}
    if lhs.adminFlag != rhs.adminFlag {return false}
    if lhs._inviteConfig != rhs._inviteConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserPhotoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPhotoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserPhotoReq, rhs: OSUserPhotoReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserPhotoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPhotoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userPhotoList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userPhotoList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userPhotoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userPhotoList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserPhotoRes, rhs: OSUserPhotoRes) -> Bool {
    if lhs.userPhotoList != rhs.userPhotoList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserPhotoVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserPhotoVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "userId"),
    3: .same(proto: "url"),
    4: .same(proto: "defaultPhoto"),
    5: .same(proto: "sort"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.defaultPhoto) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.sort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if self.defaultPhoto != 0 {
      try visitor.visitSingularInt32Field(value: self.defaultPhoto, fieldNumber: 4)
    }
    if self.sort != 0 {
      try visitor.visitSingularInt32Field(value: self.sort, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserPhotoVo, rhs: OSUserPhotoVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.defaultPhoto != rhs.defaultPhoto {return false}
    if lhs.sort != rhs.sort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUploadPhotoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadPhotoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUploadPhotoReq, rhs: OSUploadPhotoReq) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUploadPhotoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadPhotoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "userId"),
    3: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUploadPhotoRes, rhs: OSUploadPhotoRes) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUploadPhotoListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadPhotoListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "urlList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.urlList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urlList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.urlList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUploadPhotoListReq, rhs: OSUploadPhotoListReq) -> Bool {
    if lhs.urlList != rhs.urlList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUploadPhotoListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadPhotoListRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUploadPhotoListRes, rhs: OSUploadPhotoListRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeletePhotoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePhotoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeletePhotoReq, rhs: OSDeletePhotoReq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeletePhotoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePhotoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "userId"),
    3: .same(proto: "url"),
    4: .same(proto: "defaultPhoto"),
    5: .same(proto: "sort"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.defaultPhoto) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.sort) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    if self.defaultPhoto != 0 {
      try visitor.visitSingularInt32Field(value: self.defaultPhoto, fieldNumber: 4)
    }
    if self.sort != 0 {
      try visitor.visitSingularInt32Field(value: self.sort, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeletePhotoRes, rhs: OSDeletePhotoRes) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.url != rhs.url {return false}
    if lhs.defaultPhoto != rhs.defaultPhoto {return false}
    if lhs.sort != rhs.sort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeletePhotoListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePhotoListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.idList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idList.isEmpty {
      try visitor.visitPackedInt64Field(value: self.idList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeletePhotoListReq, rhs: OSDeletePhotoListReq) -> Bool {
    if lhs.idList != rhs.idList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeletePhotoListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePhotoListRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeletePhotoListRes, rhs: OSDeletePhotoListRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSigninInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigninInfoReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSigninInfoReq, rhs: OSSigninInfoReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSigninInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigninInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seriesDay"),
    2: .same(proto: "signinStatus"),
    3: .same(proto: "monthTimestamp"),
    4: .same(proto: "signinList"),
    5: .same(proto: "seriesGiftList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seriesDay) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.signinStatus) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.monthTimestamp) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.signinList) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.seriesGiftList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seriesDay != 0 {
      try visitor.visitSingularInt32Field(value: self.seriesDay, fieldNumber: 1)
    }
    if self.signinStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.signinStatus, fieldNumber: 2)
    }
    if self.monthTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.monthTimestamp, fieldNumber: 3)
    }
    if !self.signinList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signinList, fieldNumber: 4)
    }
    if !self.seriesGiftList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.seriesGiftList, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSigninInfoRes, rhs: OSSigninInfoRes) -> Bool {
    if lhs.seriesDay != rhs.seriesDay {return false}
    if lhs.signinStatus != rhs.signinStatus {return false}
    if lhs.monthTimestamp != rhs.monthTimestamp {return false}
    if lhs.signinList != rhs.signinList {return false}
    if lhs.seriesGiftList != rhs.seriesGiftList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSigninList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigninList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dateTimestamp"),
    2: .same(proto: "signinTimestamp"),
    3: .same(proto: "showIcon"),
    4: .same(proto: "signinStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.dateTimestamp) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.signinTimestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.showIcon) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.signinStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dateTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.dateTimestamp, fieldNumber: 1)
    }
    if self.signinTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.signinTimestamp, fieldNumber: 2)
    }
    if !self.showIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.showIcon, fieldNumber: 3)
    }
    if self.signinStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.signinStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSigninList, rhs: OSSigninList) -> Bool {
    if lhs.dateTimestamp != rhs.dateTimestamp {return false}
    if lhs.signinTimestamp != rhs.signinTimestamp {return false}
    if lhs.showIcon != rhs.showIcon {return false}
    if lhs.signinStatus != rhs.signinStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSeriesGiftList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeriesGiftList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftName"),
    2: .same(proto: "giftIcon"),
    3: .same(proto: "signinScope"),
    4: .same(proto: "remark"),
    5: .same(proto: "acquire"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftIcon) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.signinScope) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.acquire) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 1)
    }
    if !self.giftIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIcon, fieldNumber: 2)
    }
    if self.signinScope != 0 {
      try visitor.visitSingularInt32Field(value: self.signinScope, fieldNumber: 3)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 4)
    }
    if !self.acquire.isEmpty {
      try visitor.visitSingularStringField(value: self.acquire, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSeriesGiftList, rhs: OSSeriesGiftList) -> Bool {
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftIcon != rhs.giftIcon {return false}
    if lhs.signinScope != rhs.signinScope {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.acquire != rhs.acquire {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserSigninReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSigninReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserSigninReq, rhs: OSUserSigninReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserSigninRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSigninRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prompt"),
    2: .same(proto: "secondPrompt"),
    3: .same(proto: "signinGifts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secondPrompt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.signinGifts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 1)
    }
    if !self.secondPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.secondPrompt, fieldNumber: 2)
    }
    if !self.signinGifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signinGifts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserSigninRes, rhs: OSUserSigninRes) -> Bool {
    if lhs.prompt != rhs.prompt {return false}
    if lhs.secondPrompt != rhs.secondPrompt {return false}
    if lhs.signinGifts != rhs.signinGifts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSigninGifts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigninGifts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftName"),
    2: .same(proto: "giftIcon"),
    3: .same(proto: "count"),
    4: .same(proto: "remark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftIcon) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.remark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 1)
    }
    if !self.giftIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIcon, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    if !self.remark.isEmpty {
      try visitor.visitSingularStringField(value: self.remark, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSigninGifts, rhs: OSSigninGifts) -> Bool {
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftIcon != rhs.giftIcon {return false}
    if lhs.count != rhs.count {return false}
    if lhs.remark != rhs.remark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpTagsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpTagsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressUpSource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressUpSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressUpSource != 0 {
      try visitor.visitSingularInt32Field(value: self.dressUpSource, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpTagsReq, rhs: OSDressUpTagsReq) -> Bool {
    if lhs.dressUpSource != rhs.dressUpSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpTagsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpTagsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressUpTagList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dressUpTagList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dressUpTagList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dressUpTagList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpTagsRes, rhs: OSDressUpTagsRes) -> Bool {
    if lhs.dressUpTagList != rhs.dressUpTagList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpTagVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpTagVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "searchType"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.searchType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.searchType != .mount {
      try visitor.visitSingularEnumField(value: self.searchType, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpTagVo, rhs: OSDressUpTagVo) -> Bool {
    if lhs.searchType != rhs.searchType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserDressUpReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDressUpReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "searchType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.searchType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.searchType != .mount {
      try visitor.visitSingularEnumField(value: self.searchType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserDressUpReq, rhs: OSUserDressUpReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.searchType != rhs.searchType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserDressUpRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserDressUpRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserDressUpRes, rhs: OSUserDressUpRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "userDressUpId"),
    3: .same(proto: "dressUpName"),
    4: .same(proto: "dressUpIcon"),
    5: .same(proto: "dressIconSvga"),
    6: .same(proto: "dressUpStatus"),
    7: .same(proto: "duration"),
    8: .same(proto: "dressUpType"),
    9: .same(proto: "searchType"),
    10: .same(proto: "dressUpRemark"),
    11: .same(proto: "effectiveTime"),
    12: .same(proto: "expireTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userDressUpID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressUpName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dressUpIcon) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.dressIconSvga) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.dressUpStatus) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.dressUpType) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.searchType) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.dressUpRemark) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.effectiveTime) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if self.userDressUpID != 0 {
      try visitor.visitSingularInt32Field(value: self.userDressUpID, fieldNumber: 2)
    }
    if !self.dressUpName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpName, fieldNumber: 3)
    }
    if !self.dressUpIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpIcon, fieldNumber: 4)
    }
    if !self.dressIconSvga.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIconSvga, fieldNumber: 5)
    }
    if self.dressUpStatus != .unWear {
      try visitor.visitSingularEnumField(value: self.dressUpStatus, fieldNumber: 6)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 7)
    }
    if self.dressUpType != 0 {
      try visitor.visitSingularInt32Field(value: self.dressUpType, fieldNumber: 8)
    }
    if self.searchType != .mount {
      try visitor.visitSingularEnumField(value: self.searchType, fieldNumber: 9)
    }
    if !self.dressUpRemark.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpRemark, fieldNumber: 10)
    }
    if self.effectiveTime != 0 {
      try visitor.visitSingularInt64Field(value: self.effectiveTime, fieldNumber: 11)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTime, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpVo, rhs: OSDressUpVo) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.userDressUpID != rhs.userDressUpID {return false}
    if lhs.dressUpName != rhs.dressUpName {return false}
    if lhs.dressUpIcon != rhs.dressUpIcon {return false}
    if lhs.dressIconSvga != rhs.dressIconSvga {return false}
    if lhs.dressUpStatus != rhs.dressUpStatus {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.dressUpType != rhs.dressUpType {return false}
    if lhs.searchType != rhs.searchType {return false}
    if lhs.dressUpRemark != rhs.dressUpRemark {return false}
    if lhs.effectiveTime != rhs.effectiveTime {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpOperateReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpOperateReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operateType"),
    2: .same(proto: "userDressUpId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operateType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userDressUpID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operateType != .unWear {
      try visitor.visitSingularEnumField(value: self.operateType, fieldNumber: 1)
    }
    if self.userDressUpID != 0 {
      try visitor.visitSingularInt32Field(value: self.userDressUpID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpOperateReq, rhs: OSDressUpOperateReq) -> Bool {
    if lhs.operateType != rhs.operateType {return false}
    if lhs.userDressUpID != rhs.userDressUpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpOperateRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpOperateRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpOperateRes, rhs: OSDressUpOperateRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserGiftWallReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGiftWallReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
    2: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserGiftWallReq, rhs: OSUserGiftWallReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserGiftWallRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGiftWallRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserGiftWallRes, rhs: OSUserGiftWallRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftWallVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftWallVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftId"),
    2: .same(proto: "giftName"),
    3: .same(proto: "giftCount"),
    4: .same(proto: "giftIconUrl"),
    5: .same(proto: "totalGiftValue"),
    6: .same(proto: "timedCornerMark"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.giftIconURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalGiftValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.timedCornerMark) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 1)
    }
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 2)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 3)
    }
    if !self.giftIconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIconURL, fieldNumber: 4)
    }
    if self.totalGiftValue != 0 {
      try visitor.visitSingularInt32Field(value: self.totalGiftValue, fieldNumber: 5)
    }
    if self.timedCornerMark != 0 {
      try visitor.visitSingularInt32Field(value: self.timedCornerMark, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftWallVo, rhs: OSGiftWallVo) -> Bool {
    if lhs.giftID != rhs.giftID {return false}
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.giftIconURL != rhs.giftIconURL {return false}
    if lhs.totalGiftValue != rhs.totalGiftValue {return false}
    if lhs.timedCornerMark != rhs.timedCornerMark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftDetailsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftDetailsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftDetailsReq, rhs: OSGiftDetailsReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftDetailsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftDetailsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftDetails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._giftDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._giftDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftDetailsRes, rhs: OSGiftDetailsRes) -> Bool {
    if lhs._giftDetails != rhs._giftDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiftDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiftDetails, rhs: OSGiftDetails) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserGiftVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserGiftVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
    2: .same(proto: "nickname"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "giftName"),
    5: .same(proto: "giftIconUrl"),
    6: .same(proto: "giftCount"),
    7: .same(proto: "totalGiftValue"),
    8: .same(proto: "createTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.giftIconURL) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.totalGiftValue) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.createTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 4)
    }
    if !self.giftIconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIconURL, fieldNumber: 5)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 6)
    }
    if self.totalGiftValue != 0 {
      try visitor.visitSingularInt32Field(value: self.totalGiftValue, fieldNumber: 7)
    }
    if !self.createTime.isEmpty {
      try visitor.visitSingularStringField(value: self.createTime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserGiftVo, rhs: OSUserGiftVo) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftIconURL != rhs.giftIconURL {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.totalGiftValue != rhs.totalGiftValue {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLastJoinChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastJoinChannelReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLastJoinChannelReq, rhs: OSLastJoinChannelReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLastJoinChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastJoinChannelRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLastJoinChannelRes, rhs: OSLastJoinChannelRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAccountSecurityReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountSecurityReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAccountSecurityReq, rhs: OSAccountSecurityReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAccountSecurityRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountSecurityRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobile"),
    2: .same(proto: "bindMobileMsg"),
    3: .same(proto: "authenticationMsg"),
    4: .same(proto: "exitPassword"),
    5: .same(proto: "securityLevel"),
    6: .same(proto: "securityMsg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bindMobileMsg) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authenticationMsg) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.exitPassword) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.securityLevel) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.securityMsg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobile.isEmpty {
      try visitor.visitSingularStringField(value: self.mobile, fieldNumber: 1)
    }
    if !self.bindMobileMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.bindMobileMsg, fieldNumber: 2)
    }
    if !self.authenticationMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.authenticationMsg, fieldNumber: 3)
    }
    if self.exitPassword != 0 {
      try visitor.visitSingularInt32Field(value: self.exitPassword, fieldNumber: 4)
    }
    if self.securityLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.securityLevel, fieldNumber: 5)
    }
    if !self.securityMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.securityMsg, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAccountSecurityRes, rhs: OSAccountSecurityRes) -> Bool {
    if lhs.mobile != rhs.mobile {return false}
    if lhs.bindMobileMsg != rhs.bindMobileMsg {return false}
    if lhs.authenticationMsg != rhs.authenticationMsg {return false}
    if lhs.exitPassword != rhs.exitPassword {return false}
    if lhs.securityLevel != rhs.securityLevel {return false}
    if lhs.securityMsg != rhs.securityMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSThirdPartyAccountReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThirdPartyAccountReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSThirdPartyAccountReq, rhs: OSThirdPartyAccountReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSThirdPartyAccountRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThirdPartyAccountRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "qqBindState"),
    2: .same(proto: "wechatBindState"),
    3: .same(proto: "appleBindState"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.qqBindState) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.wechatBindState) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.appleBindState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.qqBindState != 0 {
      try visitor.visitSingularInt32Field(value: self.qqBindState, fieldNumber: 1)
    }
    if self.wechatBindState != 0 {
      try visitor.visitSingularInt32Field(value: self.wechatBindState, fieldNumber: 2)
    }
    if self.appleBindState != 0 {
      try visitor.visitSingularInt32Field(value: self.appleBindState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSThirdPartyAccountRes, rhs: OSThirdPartyAccountRes) -> Bool {
    if lhs.qqBindState != rhs.qqBindState {return false}
    if lhs.wechatBindState != rhs.wechatBindState {return false}
    if lhs.appleBindState != rhs.appleBindState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBindMobileReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindMobileReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobile"),
    2: .same(proto: "verifyCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.verifyCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobile.isEmpty {
      try visitor.visitSingularStringField(value: self.mobile, fieldNumber: 1)
    }
    if !self.verifyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBindMobileReq, rhs: OSBindMobileReq) -> Bool {
    if lhs.mobile != rhs.mobile {return false}
    if lhs.verifyCode != rhs.verifyCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBindMobileRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindMobileRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobile"),
    2: .same(proto: "displayMobile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayMobile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobile.isEmpty {
      try visitor.visitSingularStringField(value: self.mobile, fieldNumber: 1)
    }
    if !self.displayMobile.isEmpty {
      try visitor.visitSingularStringField(value: self.displayMobile, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBindMobileRes, rhs: OSBindMobileRes) -> Bool {
    if lhs.mobile != rhs.mobile {return false}
    if lhs.displayMobile != rhs.displayMobile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAdolescentSettingReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdolescentSettingReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adolescentModel"),
    2: .same(proto: "adolescentPwd"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.adolescentModel) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.adolescentPwd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.adolescentModel != 0 {
      try visitor.visitSingularInt32Field(value: self.adolescentModel, fieldNumber: 1)
    }
    if self.adolescentPwd != 0 {
      try visitor.visitSingularInt32Field(value: self.adolescentPwd, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAdolescentSettingReq, rhs: OSAdolescentSettingReq) -> Bool {
    if lhs.adolescentModel != rhs.adolescentModel {return false}
    if lhs.adolescentPwd != rhs.adolescentPwd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAdolescentSettingRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdolescentSettingRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAdolescentSettingRes, rhs: OSAdolescentSettingRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAuthenticationReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idCardNo"),
    2: .same(proto: "realName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idCardNo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.realName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idCardNo.isEmpty {
      try visitor.visitSingularStringField(value: self.idCardNo, fieldNumber: 1)
    }
    if !self.realName.isEmpty {
      try visitor.visitSingularStringField(value: self.realName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAuthenticationReq, rhs: OSAuthenticationReq) -> Bool {
    if lhs.idCardNo != rhs.idCardNo {return false}
    if lhs.realName != rhs.realName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAuthenticationRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userSetting"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userSetting) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAuthenticationRes, rhs: OSAuthenticationRes) -> Bool {
    if lhs._userSetting != rhs._userSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSettingPasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettingPasswordReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSettingPasswordReq, rhs: OSSettingPasswordReq) -> Bool {
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSettingPasswordRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettingPasswordRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSettingPasswordRes, rhs: OSSettingPasswordRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUpdatePasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePasswordReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oldPassword"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.oldPassword) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oldPassword.isEmpty {
      try visitor.visitSingularStringField(value: self.oldPassword, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUpdatePasswordReq, rhs: OSUpdatePasswordReq) -> Bool {
    if lhs.oldPassword != rhs.oldPassword {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUpdatePasswordRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdatePasswordRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUpdatePasswordRes, rhs: OSUpdatePasswordRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSResetPasswordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
    2: .same(proto: "password"),
    3: .same(proto: "mobilePhone"),
    4: .same(proto: "verifyCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mobilePhone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.verifyCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if !self.mobilePhone.isEmpty {
      try visitor.visitSingularStringField(value: self.mobilePhone, fieldNumber: 3)
    }
    if !self.verifyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyCode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSResetPasswordReq, rhs: OSResetPasswordReq) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.password != rhs.password {return false}
    if lhs.mobilePhone != rhs.mobilePhone {return false}
    if lhs.verifyCode != rhs.verifyCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSResetPasswordRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPasswordRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSResetPasswordRes, rhs: OSResetPasswordRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAuthenticationVerifyMobileReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationVerifyMobileReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobile"),
    2: .same(proto: "verifyCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobile) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.verifyCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobile.isEmpty {
      try visitor.visitSingularStringField(value: self.mobile, fieldNumber: 1)
    }
    if !self.verifyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAuthenticationVerifyMobileReq, rhs: OSAuthenticationVerifyMobileReq) -> Bool {
    if lhs.mobile != rhs.mobile {return false}
    if lhs.verifyCode != rhs.verifyCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAuthenticationVerifyMobileRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationVerifyMobileRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAuthenticationVerifyMobileRes, rhs: OSAuthenticationVerifyMobileRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBindVerifyMobileReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindVerifyMobileReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verifyCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.verifyCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.verifyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBindVerifyMobileReq, rhs: OSBindVerifyMobileReq) -> Bool {
    if lhs.verifyCode != rhs.verifyCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBindVerifyMobileRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindVerifyMobileRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBindVerifyMobileRes, rhs: OSBindVerifyMobileRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFollowReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFollowReq, rhs: OSFollowReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFollowRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "followStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.followStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.followStatus != .unfollow {
      try visitor.visitSingularEnumField(value: self.followStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFollowRes, rhs: OSFollowRes) -> Bool {
    if lhs.followStatus != rhs.followStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnfollowReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfollowReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnfollowReq, rhs: OSUnfollowReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUnfollowRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnfollowRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUnfollowRes, rhs: OSUnfollowRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLogoutReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLogoutReq, rhs: OSLogoutReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLogoutRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoutRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLogoutRes, rhs: OSLogoutRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSReportReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
    2: .same(proto: "reason"),
    3: .same(proto: "type"),
    4: .same(proto: "pictureUrls"),
    5: .same(proto: "momentId"),
    6: .same(proto: "commentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.pictureUrls) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.momentID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.commentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 3)
    }
    if !self.pictureUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pictureUrls, fieldNumber: 4)
    }
    if self.momentID != 0 {
      try visitor.visitSingularInt64Field(value: self.momentID, fieldNumber: 5)
    }
    if self.commentID != 0 {
      try visitor.visitSingularInt64Field(value: self.commentID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSReportReq, rhs: OSReportReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.type != rhs.type {return false}
    if lhs.pictureUrls != rhs.pictureUrls {return false}
    if lhs.momentID != rhs.momentID {return false}
    if lhs.commentID != rhs.commentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSReportRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSReportRes, rhs: OSReportRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinBlacklistReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinBlacklistReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinBlacklistReq, rhs: OSJoinBlacklistReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJoinBlacklistRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JoinBlacklistRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJoinBlacklistRes, rhs: OSJoinBlacklistRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadBlacklistReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadBlacklistReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadBlacklistReq, rhs: OSLoadBlacklistReq) -> Bool {
    if lhs._page != rhs._page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadBlacklistRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadBlacklistRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadBlacklistRes, rhs: OSLoadBlacklistRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRemoveBlacklistReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveBlacklistReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRemoveBlacklistReq, rhs: OSRemoveBlacklistReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRemoveBlacklistRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveBlacklistRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRemoveBlacklistRes, rhs: OSRemoveBlacklistRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFollowingsListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowingsListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFollowingsListReq, rhs: OSFollowingsListReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFollowingsListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowingsListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFollowingsListRes, rhs: OSFollowingsListRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEidolonOperationReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EidolonOperationReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operateType"),
    2: .same(proto: "id"),
    3: .same(proto: "carry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operateType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.carry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operateType.isEmpty {
      try visitor.visitSingularStringField(value: self.operateType, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.carry != false {
      try visitor.visitSingularBoolField(value: self.carry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEidolonOperationReq, rhs: OSEidolonOperationReq) -> Bool {
    if lhs.operateType != rhs.operateType {return false}
    if lhs.id != rhs.id {return false}
    if lhs.carry != rhs.carry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEidolonOperationRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EidolonOperationRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEidolonOperationRes, rhs: OSEidolonOperationRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSVisitRecordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VisitRecordReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSVisitRecordReq, rhs: OSVisitRecordReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSVisitRecordRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VisitRecordRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSVisitRecordRes, rhs: OSVisitRecordRes) -> Bool {
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMyFriendsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyFriendsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "searchStr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.searchStr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.searchStr.isEmpty {
      try visitor.visitSingularStringField(value: self.searchStr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMyFriendsReq, rhs: OSMyFriendsReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.searchStr != rhs.searchStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMyFriendsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MyFriendsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMyFriendsRes, rhs: OSMyFriendsRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserFollowVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFollowVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "followingUserId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "nickname"),
    6: .same(proto: "gender"),
    7: .same(proto: "alias"),
    8: .same(proto: "description"),
    9: .same(proto: "bothStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.followingUserID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.bothStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.followingUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.followingUserID, fieldNumber: 2)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 7)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 8)
    }
    if self.bothStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.bothStatus, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserFollowVo, rhs: OSUserFollowVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.followingUserID != rhs.followingUserID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.bothStatus != rhs.bothStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFollowersListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowersListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFollowersListReq, rhs: OSFollowersListReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFollowersListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowersListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFollowersListRes, rhs: OSFollowersListRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserFollowersVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFollowersVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "followedUserId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "nickname"),
    6: .same(proto: "gender"),
    7: .same(proto: "bothStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.followedUserID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.bothStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.followedUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.followedUserID, fieldNumber: 2)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    if self.bothStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.bothStatus, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserFollowersVo, rhs: OSUserFollowersVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.followedUserID != rhs.followedUserID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.bothStatus != rhs.bothStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserFeedbackReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFeedbackReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserFeedbackReq, rhs: OSUserFeedbackReq) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserFeedbackRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserFeedbackRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserFeedbackRes, rhs: OSUserFeedbackRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSearchReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "searchStr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.searchStr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchStr.isEmpty {
      try visitor.visitSingularStringField(value: self.searchStr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSearchReq, rhs: OSSearchReq) -> Bool {
    if lhs.searchStr != rhs.searchStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSearchRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "user"),
    2: .same(proto: "chatchannel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.user) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chatchannel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.user.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.user, fieldNumber: 1)
    }
    if !self.chatchannel.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chatchannel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSearchRes, rhs: OSSearchRes) -> Bool {
    if lhs.user != rhs.user {return false}
    if lhs.chatchannel != rhs.chatchannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSearchChannelVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchChannelVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelNo"),
    2: .same(proto: "channelId"),
    3: .same(proto: "channelName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "channelType"),
    6: .same(proto: "ownerId"),
    7: .same(proto: "onlineNumber"),
    8: .same(proto: "lockedStatus"),
    9: .same(proto: "labelName"),
    10: .same(proto: "userInSeats"),
    11: .same(proto: "labelBackgroundImg"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelNo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.channelType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.onlineNumber) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.labelName) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.userInSeats) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.labelBackgroundImg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelNo != 0 {
      try visitor.visitSingularInt32Field(value: self.channelNo, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.channelType.isEmpty {
      try visitor.visitSingularStringField(value: self.channelType, fieldNumber: 5)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 6)
    }
    if self.onlineNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.onlineNumber, fieldNumber: 7)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 8)
    }
    if !self.labelName.isEmpty {
      try visitor.visitSingularStringField(value: self.labelName, fieldNumber: 9)
    }
    if !self.userInSeats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userInSeats, fieldNumber: 10)
    }
    if !self.labelBackgroundImg.isEmpty {
      try visitor.visitSingularStringField(value: self.labelBackgroundImg, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSearchChannelVo, rhs: OSSearchChannelVo) -> Bool {
    if lhs.channelNo != rhs.channelNo {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.onlineNumber != rhs.onlineNumber {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.labelName != rhs.labelName {return false}
    if lhs.userInSeats != rhs.userInSeats {return false}
    if lhs.labelBackgroundImg != rhs.labelBackgroundImg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSignInAvatarReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignInAvatarReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSignInAvatarReq, rhs: OSSignInAvatarReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSignInAvatarRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignInAvatarRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatarList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.avatarList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatarList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.avatarList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSignInAvatarRes, rhs: OSSignInAvatarRes) -> Bool {
    if lhs.avatarList != rhs.avatarList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserAvatarVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserAvatarVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatarName"),
    2: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.avatarName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatarName.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarName, fieldNumber: 1)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserAvatarVo, rhs: OSUserAvatarVo) -> Bool {
    if lhs.avatarName != rhs.avatarName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserWalletReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWalletReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserWalletReq, rhs: OSUserWalletReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserWalletRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserWalletRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "diamondsAmount"),
    2: .same(proto: "crystalAmount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.diamondsAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.crystalAmount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.diamondsAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.diamondsAmount, fieldNumber: 1)
    }
    if self.crystalAmount != 0 {
      try visitor.visitSingularInt32Field(value: self.crystalAmount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserWalletRes, rhs: OSUserWalletRes) -> Bool {
    if lhs.diamondsAmount != rhs.diamondsAmount {return false}
    if lhs.crystalAmount != rhs.crystalAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSIdCardRecognitionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdCardRecognitionReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idCardFaceUrl"),
    2: .same(proto: "idCardBackUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idCardFaceURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idCardBackURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idCardFaceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.idCardFaceURL, fieldNumber: 1)
    }
    if !self.idCardBackURL.isEmpty {
      try visitor.visitSingularStringField(value: self.idCardBackURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSIdCardRecognitionReq, rhs: OSIdCardRecognitionReq) -> Bool {
    if lhs.idCardFaceURL != rhs.idCardFaceURL {return false}
    if lhs.idCardBackURL != rhs.idCardBackURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSIdCardRecognitionRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdCardRecognitionRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "hasCertification"),
    3: .same(proto: "displayName"),
    4: .same(proto: "displayNumber"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hasCertification_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.hasCertification_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasCertification_p, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.displayNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.displayNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSIdCardRecognitionRes, rhs: OSIdCardRecognitionRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.hasCertification_p != rhs.hasCertification_p {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.displayNumber != rhs.displayNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLogoffReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoffReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLogoffReq, rhs: OSLogoffReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLogoffRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogoffRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLogoffRes, rhs: OSLogoffRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserMedalListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserMedalListReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserMedalListReq, rhs: OSUserMedalListReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserMedalListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserMedalListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "medalList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.medalList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.medalList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.medalList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserMedalListRes, rhs: OSUserMedalListRes) -> Bool {
    if lhs.medalList != rhs.medalList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpMallReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpMallReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "searchType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.searchType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.searchType != .mount {
      try visitor.visitSingularEnumField(value: self.searchType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpMallReq, rhs: OSDressUpMallReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.searchType != rhs.searchType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpMallRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpMallRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpMallRes, rhs: OSDressUpMallRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressUpMallVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressUpMallVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "dressUpName"),
    3: .same(proto: "dressUpIcon"),
    4: .same(proto: "dressUpPrice"),
    5: .same(proto: "dressUpRemark"),
    6: .same(proto: "duration"),
    7: .same(proto: "limitedType"),
    8: .same(proto: "dressIconSvga"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressUpName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressUpIcon) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.dressUpPrice) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.dressUpRemark) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.limitedType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.dressIconSvga) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if !self.dressUpName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpName, fieldNumber: 2)
    }
    if !self.dressUpIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpIcon, fieldNumber: 3)
    }
    if self.dressUpPrice != 0 {
      try visitor.visitSingularInt32Field(value: self.dressUpPrice, fieldNumber: 4)
    }
    if !self.dressUpRemark.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpRemark, fieldNumber: 5)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 6)
    }
    if self.limitedType != 0 {
      try visitor.visitSingularInt32Field(value: self.limitedType, fieldNumber: 7)
    }
    if !self.dressIconSvga.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIconSvga, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressUpMallVo, rhs: OSDressUpMallVo) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.dressUpName != rhs.dressUpName {return false}
    if lhs.dressUpIcon != rhs.dressUpIcon {return false}
    if lhs.dressUpPrice != rhs.dressUpPrice {return false}
    if lhs.dressUpRemark != rhs.dressUpRemark {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.limitedType != rhs.limitedType {return false}
    if lhs.dressIconSvga != rhs.dressIconSvga {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBuyDressUpReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyDressUpReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBuyDressUpReq, rhs: OSBuyDressUpReq) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBuyDressUpRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuyDressUpRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBuyDressUpRes, rhs: OSBuyDressUpRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiveDressUpReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiveDressUpReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "targetAccountId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.targetAccountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if self.targetAccountID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetAccountID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiveDressUpReq, rhs: OSGiveDressUpReq) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.targetAccountID != rhs.targetAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGiveDressUpRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiveDressUpRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
    2: .same(proto: "dressUpName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressUpName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if !self.dressUpName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressUpName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGiveDressUpRes, rhs: OSGiveDressUpRes) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.dressUpName != rhs.dressUpName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSInviteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InviteReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviteCode"),
    2: .same(proto: "channelIdCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inviteCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelIDCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inviteCode.isEmpty {
      try visitor.visitSingularStringField(value: self.inviteCode, fieldNumber: 1)
    }
    if !self.channelIDCode.isEmpty {
      try visitor.visitSingularStringField(value: self.channelIDCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSInviteReq, rhs: OSInviteReq) -> Bool {
    if lhs.inviteCode != rhs.inviteCode {return false}
    if lhs.channelIDCode != rhs.channelIDCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSInviteRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InviteRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSInviteRes, rhs: OSInviteRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBlacklistVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlacklistVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "blackListedUserId"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blackListedUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.blackListedUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.blackListedUserID, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBlacklistVo, rhs: OSBlacklistVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.blackListedUserID != rhs.blackListedUserID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHonouredGuestCardsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HonouredGuestCardsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHonouredGuestCardsReq, rhs: OSHonouredGuestCardsReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHonouredGuestCardsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HonouredGuestCardsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "honouredGuestCards"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.honouredGuestCards) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.honouredGuestCards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.honouredGuestCards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHonouredGuestCardsRes, rhs: OSHonouredGuestCardsRes) -> Bool {
    if lhs.honouredGuestCards != rhs.honouredGuestCards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubBadgesReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubBadgesReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubBadgesReq, rhs: OSFansClubBadgesReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubBadgesRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubBadgesRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fansClubBadges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fansClubBadges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fansClubBadges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fansClubBadges, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubBadgesRes, rhs: OSFansClubBadgesRes) -> Bool {
    if lhs.fansClubBadges != rhs.fansClubBadges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubBadges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubBadges"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "clubId"),
    6: .same(proto: "channelId"),
    7: .same(proto: "badgeName"),
    8: .same(proto: "badgeIcon"),
    9: .same(proto: "badgeLevel"),
    10: .same(proto: "wearStatus"),
    11: .same(proto: "level"),
    12: .same(proto: "nextLevel"),
    13: .same(proto: "nextLevelValue"),
    14: .same(proto: "currentValue"),
    15: .same(proto: "todayIntimacyInfo"),
    16: .same(proto: "maxLevelValue"),
  ]

  fileprivate class _StorageClass {
    var _userID: String = String()
    var _accountID: Int32 = 0
    var _nickname: String = String()
    var _avatarURL: String = String()
    var _clubID: Int64 = 0
    var _channelID: String = String()
    var _badgeName: String = String()
    var _badgeIcon: String = String()
    var _badgeLevel: String = String()
    var _wearStatus: Int32 = 0
    var _level: Int32 = 0
    var _nextLevel: Int32 = 0
    var _nextLevelValue: Int64 = 0
    var _currentValue: Int64 = 0
    var _todayIntimacyInfo: OSIntimacyVo? = nil
    var _maxLevelValue: Int64 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _userID = source._userID
      _accountID = source._accountID
      _nickname = source._nickname
      _avatarURL = source._avatarURL
      _clubID = source._clubID
      _channelID = source._channelID
      _badgeName = source._badgeName
      _badgeIcon = source._badgeIcon
      _badgeLevel = source._badgeLevel
      _wearStatus = source._wearStatus
      _level = source._level
      _nextLevel = source._nextLevel
      _nextLevelValue = source._nextLevelValue
      _currentValue = source._currentValue
      _todayIntimacyInfo = source._todayIntimacyInfo
      _maxLevelValue = source._maxLevelValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._accountID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._clubID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._badgeName) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._badgeIcon) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._badgeLevel) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._wearStatus) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._level) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._nextLevel) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._nextLevelValue) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._currentValue) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._todayIntimacyInfo) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._maxLevelValue) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 1)
      }
      if _storage._accountID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._accountID, fieldNumber: 2)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if _storage._clubID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._clubID, fieldNumber: 5)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 6)
      }
      if !_storage._badgeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._badgeName, fieldNumber: 7)
      }
      if !_storage._badgeIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._badgeIcon, fieldNumber: 8)
      }
      if !_storage._badgeLevel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._badgeLevel, fieldNumber: 9)
      }
      if _storage._wearStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._wearStatus, fieldNumber: 10)
      }
      if _storage._level != 0 {
        try visitor.visitSingularInt32Field(value: _storage._level, fieldNumber: 11)
      }
      if _storage._nextLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nextLevel, fieldNumber: 12)
      }
      if _storage._nextLevelValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nextLevelValue, fieldNumber: 13)
      }
      if _storage._currentValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._currentValue, fieldNumber: 14)
      }
      try { if let v = _storage._todayIntimacyInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._maxLevelValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxLevelValue, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubBadges, rhs: OSFansClubBadges) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._clubID != rhs_storage._clubID {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._badgeName != rhs_storage._badgeName {return false}
        if _storage._badgeIcon != rhs_storage._badgeIcon {return false}
        if _storage._badgeLevel != rhs_storage._badgeLevel {return false}
        if _storage._wearStatus != rhs_storage._wearStatus {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._nextLevel != rhs_storage._nextLevel {return false}
        if _storage._nextLevelValue != rhs_storage._nextLevelValue {return false}
        if _storage._currentValue != rhs_storage._currentValue {return false}
        if _storage._todayIntimacyInfo != rhs_storage._todayIntimacyInfo {return false}
        if _storage._maxLevelValue != rhs_storage._maxLevelValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWearAndRemoveBadgeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WearAndRemoveBadgeReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubId"),
    2: .same(proto: "operateType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clubID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.operateType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clubID != 0 {
      try visitor.visitSingularInt64Field(value: self.clubID, fieldNumber: 1)
    }
    if self.operateType != .wearing {
      try visitor.visitSingularEnumField(value: self.operateType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWearAndRemoveBadgeReq, rhs: OSWearAndRemoveBadgeReq) -> Bool {
    if lhs.clubID != rhs.clubID {return false}
    if lhs.operateType != rhs.operateType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWearAndRemoveBadgeRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WearAndRemoveBadgeRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWearAndRemoveBadgeRes, rhs: OSWearAndRemoveBadgeRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubRanksReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubRanksReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubId"),
    2: .same(proto: "searchType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clubID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.searchType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clubID != 0 {
      try visitor.visitSingularInt64Field(value: self.clubID, fieldNumber: 1)
    }
    if self.searchType != .fansRange0 {
      try visitor.visitSingularEnumField(value: self.searchType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubRanksReq, rhs: OSFansClubRanksReq) -> Bool {
    if lhs.clubID != rhs.clubID {return false}
    if lhs.searchType != rhs.searchType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubRanksRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubRanksRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ranks"),
    2: .same(proto: "myRank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ranks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._myRank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ranks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranks, fieldNumber: 1)
    }
    try { if let v = self._myRank {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubRanksRes, rhs: OSFansClubRanksRes) -> Bool {
    if lhs.ranks != rhs.ranks {return false}
    if lhs._myRank != rhs._myRank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubRankVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubRankVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "totalValue"),
    6: .same(proto: "rank"),
    7: .same(proto: "level"),
    8: .same(proto: "badgeName"),
    9: .same(proto: "badgeIcon"),
    10: .same(proto: "gapValue"),
    11: .same(proto: "gender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.badgeName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.badgeIcon) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.gapValue) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.totalValue != 0 {
      try visitor.visitSingularInt64Field(value: self.totalValue, fieldNumber: 5)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 6)
    }
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 7)
    }
    if !self.badgeName.isEmpty {
      try visitor.visitSingularStringField(value: self.badgeName, fieldNumber: 8)
    }
    if !self.badgeIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.badgeIcon, fieldNumber: 9)
    }
    if self.gapValue != 0 {
      try visitor.visitSingularInt32Field(value: self.gapValue, fieldNumber: 10)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubRankVo, rhs: OSFansClubRankVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.totalValue != rhs.totalValue {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.level != rhs.level {return false}
    if lhs.badgeName != rhs.badgeName {return false}
    if lhs.badgeIcon != rhs.badgeIcon {return false}
    if lhs.gapValue != rhs.gapValue {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubExitReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubExitReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clubId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.clubID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.clubID != 0 {
      try visitor.visitSingularInt64Field(value: self.clubID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubExitReq, rhs: OSFansClubExitReq) -> Bool {
    if lhs.clubID != rhs.clubID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFansClubExitRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FansClubExitRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFansClubExitRes, rhs: OSFansClubExitRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFaceVerifyReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaceVerifyReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "realName"),
    2: .same(proto: "idCardNo"),
    3: .same(proto: "returnUrl"),
    4: .same(proto: "bizCode"),
    5: .same(proto: "authType"),
    6: .same(proto: "verifyCode"),
    7: .same(proto: "mobile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.realName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idCardNo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.returnURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.bizCode) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.authType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.verifyCode) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.mobile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.realName.isEmpty {
      try visitor.visitSingularStringField(value: self.realName, fieldNumber: 1)
    }
    if !self.idCardNo.isEmpty {
      try visitor.visitSingularStringField(value: self.idCardNo, fieldNumber: 2)
    }
    if !self.returnURL.isEmpty {
      try visitor.visitSingularStringField(value: self.returnURL, fieldNumber: 3)
    }
    if !self.bizCode.isEmpty {
      try visitor.visitSingularStringField(value: self.bizCode, fieldNumber: 4)
    }
    if self.authType != 0 {
      try visitor.visitSingularInt32Field(value: self.authType, fieldNumber: 5)
    }
    if !self.verifyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyCode, fieldNumber: 6)
    }
    if !self.mobile.isEmpty {
      try visitor.visitSingularStringField(value: self.mobile, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFaceVerifyReq, rhs: OSFaceVerifyReq) -> Bool {
    if lhs.realName != rhs.realName {return false}
    if lhs.idCardNo != rhs.idCardNo {return false}
    if lhs.returnURL != rhs.returnURL {return false}
    if lhs.bizCode != rhs.bizCode {return false}
    if lhs.authType != rhs.authType {return false}
    if lhs.verifyCode != rhs.verifyCode {return false}
    if lhs.mobile != rhs.mobile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFaceVerifyRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaceVerifyRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "realName"),
    2: .same(proto: "idCardNo"),
    3: .same(proto: "certifyId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.realName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idCardNo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.certifyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.realName.isEmpty {
      try visitor.visitSingularStringField(value: self.realName, fieldNumber: 1)
    }
    if !self.idCardNo.isEmpty {
      try visitor.visitSingularStringField(value: self.idCardNo, fieldNumber: 2)
    }
    if !self.certifyID.isEmpty {
      try visitor.visitSingularStringField(value: self.certifyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFaceVerifyRes, rhs: OSFaceVerifyRes) -> Bool {
    if lhs.realName != rhs.realName {return false}
    if lhs.idCardNo != rhs.idCardNo {return false}
    if lhs.certifyID != rhs.certifyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFaceVerifyResultReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaceVerifyResultReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certifyId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.certifyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certifyID.isEmpty {
      try visitor.visitSingularStringField(value: self.certifyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFaceVerifyResultReq, rhs: OSFaceVerifyResultReq) -> Bool {
    if lhs.certifyID != rhs.certifyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFaceVerifyResultRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaceVerifyResultRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userSetting"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userSetting) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFaceVerifyResultRes, rhs: OSFaceVerifyResultRes) -> Bool {
    if lhs._userSetting != rhs._userSetting {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceDialogueReportReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceDialogueReportReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceDialogueReportReq, rhs: OSUserVoiceDialogueReportReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceDialogueReportRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceDialogueReportRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userVoices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userVoices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userVoices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userVoices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceDialogueReportRes, rhs: OSUserVoiceDialogueReportRes) -> Bool {
    if lhs.userVoices != rhs.userVoices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceDialogueReportVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceDialogueReportVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "word"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.word) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceDialogueReportVo, rhs: OSUserVoiceDialogueReportVo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.word != rhs.word {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceSoftDeleteReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceSoftDeleteReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceSoftDeleteReq, rhs: OSUserVoiceSoftDeleteReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceSoftDeleteRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceSoftDeleteRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceSoftDeleteRes, rhs: OSUserVoiceSoftDeleteRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceSubmitReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceSubmitReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voice"),
    2: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.voice) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voice.isEmpty {
      try visitor.visitSingularStringField(value: self.voice, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceSubmitReq, rhs: OSUserVoiceSubmitReq) -> Bool {
    if lhs.voice != rhs.voice {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserVoiceSubmitRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserVoiceSubmitRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserVoiceSubmitRes, rhs: OSUserVoiceSubmitRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
