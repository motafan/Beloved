// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_bridge.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Uniyt的显示模式
public enum OSUnityMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case init_ // = 1
  case role // = 2
  case zone2D // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .init_
    case 2: self = .role
    case 3: self = .zone2D
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .init_: return 1
    case .role: return 2
    case .zone2D: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSUnityMode] = [
    .none,
    .init_,
    .role,
    .zone2D,
  ]

}

/// 商城的角色显示模式
public enum OSRoleMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case dontCare // = 0

  /// 小
  case small // = 1

  /// 大
  case big // = 2

  /// 五官商城
  case body // = 3

  /// 衣服商城
  case dress // = 4

  /// 退出
  case exit // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .dontCare
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dontCare
    case 1: self = .small
    case 2: self = .big
    case 3: self = .body
    case 4: self = .dress
    case 5: self = .exit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .dontCare: return 0
    case .small: return 1
    case .big: return 2
    case .body: return 3
    case .dress: return 4
    case .exit: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSRoleMode] = [
    .dontCare,
    .small,
    .big,
    .body,
    .dress,
    .exit,
  ]

}

/// ===================================
/// CallApp
public struct OSCallAppReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: OSCallAppReq.OneOf_Request? = nil

  /// Common
  public var getServerInfo: OSGetServerInfoReq {
    get {
      if case .getServerInfo(let v)? = request {return v}
      return OSGetServerInfoReq()
    }
    set {request = .getServerInfo(newValue)}
  }

  public var getUserInfo: OSGetUserInfoReq {
    get {
      if case .getUserInfo(let v)? = request {return v}
      return OSGetUserInfoReq()
    }
    set {request = .getUserInfo(newValue)}
  }

  /// Store
  public var getRoleHandPosition: OSGetRoleHandPositionReq {
    get {
      if case .getRoleHandPosition(let v)? = request {return v}
      return OSGetRoleHandPositionReq()
    }
    set {request = .getRoleHandPosition(newValue)}
  }

  /// Zone2D
  public var getZone2DsafeArea: OSGetZone2DSafeAreaReq {
    get {
      if case .getZone2DsafeArea(let v)? = request {return v}
      return OSGetZone2DSafeAreaReq()
    }
    set {request = .getZone2DsafeArea(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    /// Common
    case getServerInfo(OSGetServerInfoReq)
    case getUserInfo(OSGetUserInfoReq)
    /// Store
    case getRoleHandPosition(OSGetRoleHandPositionReq)
    /// Zone2D
    case getZone2DsafeArea(OSGetZone2DSafeAreaReq)

  }

  public init() {}
}

public struct OSCallAppRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: OSCallAppRes.OneOf_Response? = nil

  /// Common
  public var getServerInfo: OSGetServerInfoRes {
    get {
      if case .getServerInfo(let v)? = response {return v}
      return OSGetServerInfoRes()
    }
    set {response = .getServerInfo(newValue)}
  }

  public var getUserInfo: OSGetUserInfoRes {
    get {
      if case .getUserInfo(let v)? = response {return v}
      return OSGetUserInfoRes()
    }
    set {response = .getUserInfo(newValue)}
  }

  /// Store
  public var getRoleHandPosition: OSGetRoleHandPositionRes {
    get {
      if case .getRoleHandPosition(let v)? = response {return v}
      return OSGetRoleHandPositionRes()
    }
    set {response = .getRoleHandPosition(newValue)}
  }

  /// Zone2D
  public var getZone2DsafeArea: OSGetZone2DSafeAreaRes {
    get {
      if case .getZone2DsafeArea(let v)? = response {return v}
      return OSGetZone2DSafeAreaRes()
    }
    set {response = .getZone2DsafeArea(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    /// Common
    case getServerInfo(OSGetServerInfoRes)
    case getUserInfo(OSGetUserInfoRes)
    /// Store
    case getRoleHandPosition(OSGetRoleHandPositionRes)
    /// Zone2D
    case getZone2DsafeArea(OSGetZone2DSafeAreaRes)

  }

  public init() {}
}

public struct OSGetServerInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGetServerInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGetUserInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGetUserInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: String = String()

  public var requestHeader: OSRequestHeader {
    get {return _requestHeader ?? OSRequestHeader()}
    set {_requestHeader = newValue}
  }
  /// Returns true if `requestHeader` has been explicitly set.
  public var hasRequestHeader: Bool {return self._requestHeader != nil}
  /// Clears the value of `requestHeader`. Subsequent reads from it will return its default value.
  public mutating func clearRequestHeader() {self._requestHeader = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _requestHeader: OSRequestHeader? = nil
}

/// 获取我的页面角色手摆位Y坐标
public struct OSGetRoleHandPositionReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGetRoleHandPositionRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handPos: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取app推荐unity的安全区域
public struct OSGetZone2DSafeAreaReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGetZone2DSafeAreaRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var minPosY: Int32 = 0

  public var maxPosY: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===================================
/// NotifyApp
public struct OSNotifyApp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notify: OSNotifyApp.OneOf_Notify? = nil

  /// Common
  public var unityInited: OSOnUnityInited {
    get {
      if case .unityInited(let v)? = notify {return v}
      return OSOnUnityInited()
    }
    set {notify = .unityInited(newValue)}
  }

  public var unityModeChanged: OSOnUnityModeChanged {
    get {
      if case .unityModeChanged(let v)? = notify {return v}
      return OSOnUnityModeChanged()
    }
    set {notify = .unityModeChanged(newValue)}
  }

  /// Store
  public var joinDressMode: OSOnJoinDressModel {
    get {
      if case .joinDressMode(let v)? = notify {return v}
      return OSOnJoinDressModel()
    }
    set {notify = .joinDressMode(newValue)}
  }

  public var exitDressMode: OSOnExitDressModel {
    get {
      if case .exitDressMode(let v)? = notify {return v}
      return OSOnExitDressModel()
    }
    set {notify = .exitDressMode(newValue)}
  }

  public var updateMeatAvatar: OSOnUpdateMetaAvatar {
    get {
      if case .updateMeatAvatar(let v)? = notify {return v}
      return OSOnUpdateMetaAvatar()
    }
    set {notify = .updateMeatAvatar(newValue)}
  }

  /// Zone2D
  public var unity2DClickSeat: OSOnUnity2dClickSeat {
    get {
      if case .unity2DClickSeat(let v)? = notify {return v}
      return OSOnUnity2dClickSeat()
    }
    set {notify = .unity2DClickSeat(newValue)}
  }

  public var quitZone2Dstore: OSOnQuitZone2DStore {
    get {
      if case .quitZone2Dstore(let v)? = notify {return v}
      return OSOnQuitZone2DStore()
    }
    set {notify = .quitZone2Dstore(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Notify: Equatable, Sendable {
    /// Common
    case unityInited(OSOnUnityInited)
    case unityModeChanged(OSOnUnityModeChanged)
    /// Store
    case joinDressMode(OSOnJoinDressModel)
    case exitDressMode(OSOnExitDressModel)
    case updateMeatAvatar(OSOnUpdateMetaAvatar)
    /// Zone2D
    case unity2DClickSeat(OSOnUnity2dClickSeat)
    case quitZone2Dstore(OSOnQuitZone2DStore)

  }

  public init() {}
}

/// Unity初始化完成
public struct OSOnUnityInited: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSOnUnityModeChanged: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: OSUnityMode = .none

  /// 个人形象返回Role模式
  public var roleMode: OSRoleMode = .dontCare

  /// 切换到zone2D模式返回的位置信息
  public var zone2Dregion: OSZone2DRegion {
    get {return _zone2Dregion ?? OSZone2DRegion()}
    set {_zone2Dregion = newValue}
  }
  /// Returns true if `zone2Dregion` has been explicitly set.
  public var hasZone2Dregion: Bool {return self._zone2Dregion != nil}
  /// Clears the value of `zone2Dregion`. Subsequent reads from it will return its default value.
  public mutating func clearZone2Dregion() {self._zone2Dregion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _zone2Dregion: OSZone2DRegion? = nil
}

/// Unity已进入装扮编辑模式
public struct OSOnJoinDressModel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Unity已退出装扮编辑模式
public struct OSOnExitDressModel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 我的形象图片更新
public struct OSOnUpdateMetaAvatar: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var imgPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 在Unity2D房间中，点击麦位
public struct OSOnUnity2dClickSeat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seatIndex: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// unity退出了2d房内的商城
public struct OSOnQuitZone2DStore: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ===================================
/// CallUnity
public struct OSCallUnityReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: OSCallUnityReq.OneOf_Request? = nil

  public var switchUnityMode: OSSwitchUnityModeReq {
    get {
      if case .switchUnityMode(let v)? = request {return v}
      return OSSwitchUnityModeReq()
    }
    set {request = .switchUnityMode(newValue)}
  }

  public var userSelfModified: OSUserSelfModifiedReq {
    get {
      if case .userSelfModified(let v)? = request {return v}
      return OSUserSelfModifiedReq()
    }
    set {request = .userSelfModified(newValue)}
  }

  /// Zone2D
  public var receiveSeatInfoOfUnity2D: OSReceiveSeatInfoOfUnity2DReq {
    get {
      if case .receiveSeatInfoOfUnity2D(let v)? = request {return v}
      return OSReceiveSeatInfoOfUnity2DReq()
    }
    set {request = .receiveSeatInfoOfUnity2D(newValue)}
  }

  public var receiveVolumeInfoOfUnity2D: OSReceiveVolumeInfoOfUnity2DReq {
    get {
      if case .receiveVolumeInfoOfUnity2D(let v)? = request {return v}
      return OSReceiveVolumeInfoOfUnity2DReq()
    }
    set {request = .receiveVolumeInfoOfUnity2D(newValue)}
  }

  public var quitZone2D: OSQuitZone2DReq {
    get {
      if case .quitZone2D(let v)? = request {return v}
      return OSQuitZone2DReq()
    }
    set {request = .quitZone2D(newValue)}
  }

  public var zone2DplayAnim: OSZone2DPlayAnimReq {
    get {
      if case .zone2DplayAnim(let v)? = request {return v}
      return OSZone2DPlayAnimReq()
    }
    set {request = .zone2DplayAnim(newValue)}
  }

  public var zone2DsendGift: OSZone2DSendGiftReq {
    get {
      if case .zone2DsendGift(let v)? = request {return v}
      return OSZone2DSendGiftReq()
    }
    set {request = .zone2DsendGift(newValue)}
  }

  public var zone2DopenStore: OSZone2DOpenStoreReq {
    get {
      if case .zone2DopenStore(let v)? = request {return v}
      return OSZone2DOpenStoreReq()
    }
    set {request = .zone2DopenStore(newValue)}
  }

  public var zone2DquitStore: OSZone2DQuitStoreReq {
    get {
      if case .zone2DquitStore(let v)? = request {return v}
      return OSZone2DQuitStoreReq()
    }
    set {request = .zone2DquitStore(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case switchUnityMode(OSSwitchUnityModeReq)
    case userSelfModified(OSUserSelfModifiedReq)
    /// Zone2D
    case receiveSeatInfoOfUnity2D(OSReceiveSeatInfoOfUnity2DReq)
    case receiveVolumeInfoOfUnity2D(OSReceiveVolumeInfoOfUnity2DReq)
    case quitZone2D(OSQuitZone2DReq)
    case zone2DplayAnim(OSZone2DPlayAnimReq)
    case zone2DsendGift(OSZone2DSendGiftReq)
    case zone2DopenStore(OSZone2DOpenStoreReq)
    case zone2DquitStore(OSZone2DQuitStoreReq)

  }

  public init() {}
}

/// 切换Unity显示模式
public struct OSSwitchUnityModeReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: OSUnityMode = .none

  public var roleMode: OSRoleMode = .dontCare

  public var zone2Dinfo: OSZone2DInfo {
    get {return _zone2Dinfo ?? OSZone2DInfo()}
    set {_zone2Dinfo = newValue}
  }
  /// Returns true if `zone2Dinfo` has been explicitly set.
  public var hasZone2Dinfo: Bool {return self._zone2Dinfo != nil}
  /// Clears the value of `zone2Dinfo`. Subsequent reads from it will return its default value.
  public mutating func clearZone2Dinfo() {self._zone2Dinfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _zone2Dinfo: OSZone2DInfo? = nil
}

public struct OSUserSelfModifiedReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///
///UserInSeats.channelPowerType: 1-房主, 2-超管, 3-管理员, 4-普通, 5-公会会长, 6-黑名单
///UserInSeats.status: 0-lock, 1-normal, 2-mute, 3-lockAndMute
public struct OSReceiveSeatInfoOfUnity2DReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位列表信息
  public var seatInfos: [OSZone2DSeatInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 传给Unity麦位音量数据
public struct OSReceiveVolumeInfoOfUnity2DReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seatVolumeInfos: [OSSeatVolumeInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 通知Unity退出混合模式房间
public struct OSQuitZone2DReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 调用unity播放麦位角色动作
public struct OSZone2DPlayAnimReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seatIndex: Int32 = 0

  public var expressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 调用unity播互动礼物表现
public struct OSZone2DSendGiftReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senderSeatIndex: Int32 = 0

  public var targetsSeatIndex: [Int32] = []

  public var giftEffect: STGiftEffect {
    get {return _giftEffect ?? STGiftEffect()}
    set {_giftEffect = newValue}
  }
  /// Returns true if `giftEffect` has been explicitly set.
  public var hasGiftEffect: Bool {return self._giftEffect != nil}
  /// Clears the value of `giftEffect`. Subsequent reads from it will return its default value.
  public mutating func clearGiftEffect() {self._giftEffect = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _giftEffect: STGiftEffect? = nil
}

/// App在Zone2D房点了商城按钮
public struct OSZone2DOpenStoreReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// App在Zone2D房退出商城按钮(安卓用, 手势返回退出)
public struct OSZone2DQuitStoreReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSZone2DInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uniCode: String = String()

  public var isOpenChannel: Int32 = 0

  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSZone2DRegion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var safeArea: OSZone2DSafeArea {
    get {return _safeArea ?? OSZone2DSafeArea()}
    set {_safeArea = newValue}
  }
  /// Returns true if `safeArea` has been explicitly set.
  public var hasSafeArea: Bool {return self._safeArea != nil}
  /// Clears the value of `safeArea`. Subsequent reads from it will return its default value.
  public mutating func clearSafeArea() {self._safeArea = nil}

  /// 麦位接受礼物的屏幕坐标(像素坐标, 左上角为原点)
  public var seatGiftPositions: [OSIntVec2] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _safeArea: OSZone2DSafeArea? = nil
}

public struct OSZone2DSafeArea: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var minPosY: Int32 = 0

  public var maxPosY: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSIntVec2: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var x: Int32 = 0

  public var y: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 麦位音量信息
public struct OSSeatVolumeInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountID: Int32 = 0

  public var volume: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSZone2DSeatInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var seatIndex: Int32 = 0

  public var seatStatus: Int32 = 0

  public var userInSeats: OSUserInSeats {
    get {return _userInSeats ?? OSUserInSeats()}
    set {_userInSeats = newValue}
  }
  /// Returns true if `userInSeats` has been explicitly set.
  public var hasUserInSeats: Bool {return self._userInSeats != nil}
  /// Clears the value of `userInSeats`. Subsequent reads from it will return its default value.
  public mutating func clearUserInSeats() {self._userInSeats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInSeats: OSUserInSeats? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSUnityMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "none"),
    1: .same(proto: "init"),
    2: .same(proto: "role"),
    3: .same(proto: "zone2D"),
  ]
}

extension OSRoleMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "dontCare"),
    1: .same(proto: "small"),
    2: .same(proto: "big"),
    3: .same(proto: "body"),
    4: .same(proto: "dress"),
    5: .same(proto: "exit"),
  ]
}

extension OSCallAppReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallAppReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getServerInfo"),
    2: .same(proto: "getUserInfo"),
    3: .same(proto: "getRoleHandPosition"),
    4: .same(proto: "getZone2DSafeArea"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSGetServerInfoReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getServerInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getServerInfo(v)
        }
      }()
      case 2: try {
        var v: OSGetUserInfoReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getUserInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getUserInfo(v)
        }
      }()
      case 3: try {
        var v: OSGetRoleHandPositionReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getRoleHandPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getRoleHandPosition(v)
        }
      }()
      case 4: try {
        var v: OSGetZone2DSafeAreaReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getZone2DsafeArea(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getZone2DsafeArea(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getServerInfo?: try {
      guard case .getServerInfo(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getUserInfo?: try {
      guard case .getUserInfo(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getRoleHandPosition?: try {
      guard case .getRoleHandPosition(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getZone2DsafeArea?: try {
      guard case .getZone2DsafeArea(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCallAppReq, rhs: OSCallAppReq) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCallAppRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallAppRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getServerInfo"),
    2: .same(proto: "getUserInfo"),
    3: .same(proto: "getRoleHandPosition"),
    4: .same(proto: "getZone2DSafeArea"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSGetServerInfoRes?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getServerInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getServerInfo(v)
        }
      }()
      case 2: try {
        var v: OSGetUserInfoRes?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getUserInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getUserInfo(v)
        }
      }()
      case 3: try {
        var v: OSGetRoleHandPositionRes?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getRoleHandPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getRoleHandPosition(v)
        }
      }()
      case 4: try {
        var v: OSGetZone2DSafeAreaRes?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getZone2DsafeArea(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getZone2DsafeArea(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getServerInfo?: try {
      guard case .getServerInfo(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .getUserInfo?: try {
      guard case .getUserInfo(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getRoleHandPosition?: try {
      guard case .getRoleHandPosition(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getZone2DsafeArea?: try {
      guard case .getZone2DsafeArea(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCallAppRes, rhs: OSCallAppRes) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetServerInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServerInfoReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetServerInfoReq, rhs: OSGetServerInfoReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetServerInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServerInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetServerInfoRes, rhs: OSGetServerInfoRes) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetUserInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserInfoReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetUserInfoReq, rhs: OSGetUserInfoReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetUserInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "requestHeader"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requestHeader) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._requestHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetUserInfoRes, rhs: OSGetUserInfoRes) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._requestHeader != rhs._requestHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetRoleHandPositionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRoleHandPositionReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetRoleHandPositionReq, rhs: OSGetRoleHandPositionReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetRoleHandPositionRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRoleHandPositionRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handPos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.handPos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.handPos.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.handPos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetRoleHandPositionRes, rhs: OSGetRoleHandPositionRes) -> Bool {
    if lhs.handPos != rhs.handPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetZone2DSafeAreaReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetZone2DSafeAreaReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetZone2DSafeAreaReq, rhs: OSGetZone2DSafeAreaReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGetZone2DSafeAreaRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetZone2DSafeAreaRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minPosY"),
    2: .same(proto: "maxPosY"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minPosY) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxPosY) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPosY != 0 {
      try visitor.visitSingularInt32Field(value: self.minPosY, fieldNumber: 1)
    }
    if self.maxPosY != 0 {
      try visitor.visitSingularInt32Field(value: self.maxPosY, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGetZone2DSafeAreaRes, rhs: OSGetZone2DSafeAreaRes) -> Bool {
    if lhs.minPosY != rhs.minPosY {return false}
    if lhs.maxPosY != rhs.maxPosY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSNotifyApp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyApp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unityInited"),
    2: .same(proto: "unityModeChanged"),
    3: .same(proto: "joinDressMode"),
    4: .same(proto: "exitDressMode"),
    5: .same(proto: "updateMeatAvatar"),
    6: .same(proto: "unity2dClickSeat"),
    7: .same(proto: "quitZone2DStore"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSOnUnityInited?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .unityInited(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .unityInited(v)
        }
      }()
      case 2: try {
        var v: OSOnUnityModeChanged?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .unityModeChanged(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .unityModeChanged(v)
        }
      }()
      case 3: try {
        var v: OSOnJoinDressModel?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .joinDressMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .joinDressMode(v)
        }
      }()
      case 4: try {
        var v: OSOnExitDressModel?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .exitDressMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .exitDressMode(v)
        }
      }()
      case 5: try {
        var v: OSOnUpdateMetaAvatar?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .updateMeatAvatar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .updateMeatAvatar(v)
        }
      }()
      case 6: try {
        var v: OSOnUnity2dClickSeat?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .unity2DClickSeat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .unity2DClickSeat(v)
        }
      }()
      case 7: try {
        var v: OSOnQuitZone2DStore?
        var hadOneofValue = false
        if let current = self.notify {
          hadOneofValue = true
          if case .quitZone2Dstore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notify = .quitZone2Dstore(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.notify {
    case .unityInited?: try {
      guard case .unityInited(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unityModeChanged?: try {
      guard case .unityModeChanged(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .joinDressMode?: try {
      guard case .joinDressMode(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .exitDressMode?: try {
      guard case .exitDressMode(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .updateMeatAvatar?: try {
      guard case .updateMeatAvatar(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .unity2DClickSeat?: try {
      guard case .unity2DClickSeat(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .quitZone2Dstore?: try {
      guard case .quitZone2Dstore(let v)? = self.notify else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSNotifyApp, rhs: OSNotifyApp) -> Bool {
    if lhs.notify != rhs.notify {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnUnityInited: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnUnityInited"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnUnityInited, rhs: OSOnUnityInited) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnUnityModeChanged: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnUnityModeChanged"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "roleMode"),
    3: .same(proto: "zone2DRegion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.roleMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._zone2Dregion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mode != .none {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.roleMode != .dontCare {
      try visitor.visitSingularEnumField(value: self.roleMode, fieldNumber: 2)
    }
    try { if let v = self._zone2Dregion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnUnityModeChanged, rhs: OSOnUnityModeChanged) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.roleMode != rhs.roleMode {return false}
    if lhs._zone2Dregion != rhs._zone2Dregion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnJoinDressModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnJoinDressModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnJoinDressModel, rhs: OSOnJoinDressModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnExitDressModel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnExitDressModel"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnExitDressModel, rhs: OSOnExitDressModel) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnUpdateMetaAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnUpdateMetaAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "imgPath"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imgPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imgPath.isEmpty {
      try visitor.visitSingularStringField(value: self.imgPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnUpdateMetaAvatar, rhs: OSOnUpdateMetaAvatar) -> Bool {
    if lhs.imgPath != rhs.imgPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnUnity2dClickSeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnUnity2dClickSeat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seatIndex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnUnity2dClickSeat, rhs: OSOnUnity2dClickSeat) -> Bool {
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnQuitZone2DStore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnQuitZone2DStore"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnQuitZone2DStore, rhs: OSOnQuitZone2DStore) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCallUnityReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallUnityReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "switchUnityMode"),
    9: .same(proto: "userSelfModified"),
    2: .same(proto: "receiveSeatInfoOfUnity2D"),
    3: .same(proto: "receiveVolumeInfoOfUnity2D"),
    4: .same(proto: "quitZone2D"),
    5: .same(proto: "zone2DPlayAnim"),
    6: .same(proto: "zone2DSendGift"),
    7: .same(proto: "zone2DOpenStore"),
    8: .same(proto: "zone2DQuitStore"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSSwitchUnityModeReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .switchUnityMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .switchUnityMode(v)
        }
      }()
      case 2: try {
        var v: OSReceiveSeatInfoOfUnity2DReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .receiveSeatInfoOfUnity2D(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .receiveSeatInfoOfUnity2D(v)
        }
      }()
      case 3: try {
        var v: OSReceiveVolumeInfoOfUnity2DReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .receiveVolumeInfoOfUnity2D(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .receiveVolumeInfoOfUnity2D(v)
        }
      }()
      case 4: try {
        var v: OSQuitZone2DReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .quitZone2D(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .quitZone2D(v)
        }
      }()
      case 5: try {
        var v: OSZone2DPlayAnimReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .zone2DplayAnim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .zone2DplayAnim(v)
        }
      }()
      case 6: try {
        var v: OSZone2DSendGiftReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .zone2DsendGift(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .zone2DsendGift(v)
        }
      }()
      case 7: try {
        var v: OSZone2DOpenStoreReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .zone2DopenStore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .zone2DopenStore(v)
        }
      }()
      case 8: try {
        var v: OSZone2DQuitStoreReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .zone2DquitStore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .zone2DquitStore(v)
        }
      }()
      case 9: try {
        var v: OSUserSelfModifiedReq?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .userSelfModified(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .userSelfModified(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .switchUnityMode?: try {
      guard case .switchUnityMode(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .receiveSeatInfoOfUnity2D?: try {
      guard case .receiveSeatInfoOfUnity2D(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .receiveVolumeInfoOfUnity2D?: try {
      guard case .receiveVolumeInfoOfUnity2D(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .quitZone2D?: try {
      guard case .quitZone2D(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .zone2DplayAnim?: try {
      guard case .zone2DplayAnim(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .zone2DsendGift?: try {
      guard case .zone2DsendGift(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .zone2DopenStore?: try {
      guard case .zone2DopenStore(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .zone2DquitStore?: try {
      guard case .zone2DquitStore(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .userSelfModified?: try {
      guard case .userSelfModified(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCallUnityReq, rhs: OSCallUnityReq) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSwitchUnityModeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SwitchUnityModeReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "roleMode"),
    3: .same(proto: "zone2DInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.roleMode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._zone2Dinfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mode != .none {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    if self.roleMode != .dontCare {
      try visitor.visitSingularEnumField(value: self.roleMode, fieldNumber: 2)
    }
    try { if let v = self._zone2Dinfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSwitchUnityModeReq, rhs: OSSwitchUnityModeReq) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.roleMode != rhs.roleMode {return false}
    if lhs._zone2Dinfo != rhs._zone2Dinfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUserSelfModifiedReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserSelfModifiedReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUserSelfModifiedReq, rhs: OSUserSelfModifiedReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSReceiveSeatInfoOfUnity2DReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveSeatInfoOfUnity2DReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seatInfos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.seatInfos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.seatInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.seatInfos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSReceiveSeatInfoOfUnity2DReq, rhs: OSReceiveSeatInfoOfUnity2DReq) -> Bool {
    if lhs.seatInfos != rhs.seatInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSReceiveVolumeInfoOfUnity2DReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveVolumeInfoOfUnity2DReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seatVolumeInfos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.seatVolumeInfos) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.seatVolumeInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.seatVolumeInfos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSReceiveVolumeInfoOfUnity2DReq, rhs: OSReceiveVolumeInfoOfUnity2DReq) -> Bool {
    if lhs.seatVolumeInfos != rhs.seatVolumeInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSQuitZone2DReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuitZone2DReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSQuitZone2DReq, rhs: OSQuitZone2DReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DPlayAnimReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DPlayAnimReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seatIndex"),
    2: .same(proto: "expressionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.expressionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 1)
    }
    if !self.expressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.expressionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DPlayAnimReq, rhs: OSZone2DPlayAnimReq) -> Bool {
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.expressionID != rhs.expressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DSendGiftReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DSendGiftReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "senderSeatIndex"),
    2: .same(proto: "targetsSeatIndex"),
    3: .same(proto: "giftEffect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.senderSeatIndex) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.targetsSeatIndex) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._giftEffect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.senderSeatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.senderSeatIndex, fieldNumber: 1)
    }
    if !self.targetsSeatIndex.isEmpty {
      try visitor.visitPackedInt32Field(value: self.targetsSeatIndex, fieldNumber: 2)
    }
    try { if let v = self._giftEffect {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DSendGiftReq, rhs: OSZone2DSendGiftReq) -> Bool {
    if lhs.senderSeatIndex != rhs.senderSeatIndex {return false}
    if lhs.targetsSeatIndex != rhs.targetsSeatIndex {return false}
    if lhs._giftEffect != rhs._giftEffect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DOpenStoreReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DOpenStoreReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DOpenStoreReq, rhs: OSZone2DOpenStoreReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DQuitStoreReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DQuitStoreReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DQuitStoreReq, rhs: OSZone2DQuitStoreReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uniCode"),
    2: .same(proto: "isOpenChannel"),
    3: .same(proto: "channelID"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uniCode) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.isOpenChannel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uniCode.isEmpty {
      try visitor.visitSingularStringField(value: self.uniCode, fieldNumber: 1)
    }
    if self.isOpenChannel != 0 {
      try visitor.visitSingularInt32Field(value: self.isOpenChannel, fieldNumber: 2)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DInfo, rhs: OSZone2DInfo) -> Bool {
    if lhs.uniCode != rhs.uniCode {return false}
    if lhs.isOpenChannel != rhs.isOpenChannel {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DRegion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DRegion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "safeArea"),
    2: .same(proto: "seatGiftPositions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._safeArea) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.seatGiftPositions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._safeArea {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.seatGiftPositions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.seatGiftPositions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DRegion, rhs: OSZone2DRegion) -> Bool {
    if lhs._safeArea != rhs._safeArea {return false}
    if lhs.seatGiftPositions != rhs.seatGiftPositions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DSafeArea: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DSafeArea"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "minPosY"),
    2: .same(proto: "maxPosY"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minPosY) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxPosY) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minPosY != 0 {
      try visitor.visitSingularInt32Field(value: self.minPosY, fieldNumber: 1)
    }
    if self.maxPosY != 0 {
      try visitor.visitSingularInt32Field(value: self.maxPosY, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DSafeArea, rhs: OSZone2DSafeArea) -> Bool {
    if lhs.minPosY != rhs.minPosY {return false}
    if lhs.maxPosY != rhs.maxPosY {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSIntVec2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntVec2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSIntVec2, rhs: OSIntVec2) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSeatVolumeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeatVolumeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accountId"),
    2: .same(proto: "volume"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.volume) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 1)
    }
    if self.volume != 0 {
      try visitor.visitSingularInt32Field(value: self.volume, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSeatVolumeInfo, rhs: OSSeatVolumeInfo) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.volume != rhs.volume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSZone2DSeatInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Zone2DSeatInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seatIndex"),
    2: .same(proto: "seatStatus"),
    3: .same(proto: "userInSeats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seatIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.seatStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._userInSeats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seatIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.seatIndex, fieldNumber: 1)
    }
    if self.seatStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.seatStatus, fieldNumber: 2)
    }
    try { if let v = self._userInSeats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSZone2DSeatInfo, rhs: OSZone2DSeatInfo) -> Bool {
    if lhs.seatIndex != rhs.seatIndex {return false}
    if lhs.seatStatus != rhs.seatStatus {return false}
    if lhs._userInSeats != rhs._userInSeats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
