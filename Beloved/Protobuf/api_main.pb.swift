// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_main.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct OSRawHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///头长度
  public var length: Int32 = 0

  ///头版本
  public var version: Int32 = 0

  ///加密算法,0=不加密,1=AES加密,2=RSA加密
  public var encrypt: Int32 = 0

  ///压缩算法
  public var compress: Int32 = 0

  /// 0 none; 1 hex; 2 base64
  public var coding: Int32 = 0

  /// 请求的业务模块(Main.Request)
  public var module: Int32 = 0

  public var context: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 请求实体
public struct OSRequestHeader: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 版本号, 默认1
  public var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// 当次请求id
  public var context: Int32 {
    get {return _storage._context}
    set {_uniqueStorage()._context = newValue}
  }

  /// 用户token
  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  /// 当前时间戳(毫秒ms)
  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  /// 初始化时填设备信息
  public var device: OSDevice {
    get {return _storage._device ?? OSDevice()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {_uniqueStorage()._device = nil}

  /// appFlag标识
  public var appFlag: Int32 {
    get {return _storage._appFlag}
    set {_uniqueStorage()._appFlag = newValue}
  }

  /// 客户端不需要传
  public var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 响应实体
public struct OSResponseHeader: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 协议版本号, 默认1
  public var version: Int32 = 0

  /// 当次响应对应的请求id
  public var context: Int32 = 0

  /// 状态码, 0成功，-1失败
  public var code: Int32 = 0

  /// 消息当前时间戳(毫秒ms)
  public var timestamp: Int64 = 0

  /// 消息提示
  public var message: String = String()

  ///当前用户id
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 请求总入口
public struct OSApiRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 协议头
  public var header: OSRequestHeader {
    get {return _header ?? OSRequestHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var request: OSApiRequest.OneOf_Request? = nil

  public var main: OSMainRequest {
    get {
      if case .main(let v)? = request {return v}
      return OSMainRequest()
    }
    set {request = .main(newValue)}
  }

  /// 用户相关请求
  public var user: OSUserRequest {
    get {
      if case .user(let v)? = request {return v}
      return OSUserRequest()
    }
    set {request = .user(newValue)}
  }

  /// 大厅相关请求
  public var lobby: OSLobbyRequest {
    get {
      if case .lobby(let v)? = request {return v}
      return OSLobbyRequest()
    }
    set {request = .lobby(newValue)}
  }

  /// 动态相关请求
  public var moment: OSMomentRequest {
    get {
      if case .moment(let v)? = request {return v}
      return OSMomentRequest()
    }
    set {request = .moment(newValue)}
  }

  /// 房间相关请求
  public var channel: OSChannelRequest {
    get {
      if case .channel(let v)? = request {return v}
      return OSChannelRequest()
    }
    set {request = .channel(newValue)}
  }

  /// 消息相关请求
  public var message: OSMessageRequest {
    get {
      if case .message(let v)? = request {return v}
      return OSMessageRequest()
    }
    set {request = .message(newValue)}
  }

  /// 商店相关请求
  public var store: OSStoreRequest {
    get {
      if case .store(let v)? = request {return v}
      return OSStoreRequest()
    }
    set {request = .store(newValue)}
  }

  /// 娱乐玩法相关请求
  public var play: OSPlayRequest {
    get {
      if case .play(let v)? = request {return v}
      return OSPlayRequest()
    }
    set {request = .play(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case main(OSMainRequest)
    /// 用户相关请求
    case user(OSUserRequest)
    /// 大厅相关请求
    case lobby(OSLobbyRequest)
    /// 动态相关请求
    case moment(OSMomentRequest)
    /// 房间相关请求
    case channel(OSChannelRequest)
    /// 消息相关请求
    case message(OSMessageRequest)
    /// 商店相关请求
    case store(OSStoreRequest)
    /// 娱乐玩法相关请求
    case play(OSPlayRequest)

  }

  public init() {}

  fileprivate var _header: OSRequestHeader? = nil
}

/// 返回总入口
public struct OSApiResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 协议头
  public var header: OSResponseHeader {
    get {return _storage._header ?? OSResponseHeader()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {_uniqueStorage()._header = nil}

  public var response: OneOf_Response? {
    get {return _storage._response}
    set {_uniqueStorage()._response = newValue}
  }

  public var main: OSMainResponse {
    get {
      if case .main(let v)? = _storage._response {return v}
      return OSMainResponse()
    }
    set {_uniqueStorage()._response = .main(newValue)}
  }

  /// 用户相关响应
  public var user: OSUserResponse {
    get {
      if case .user(let v)? = _storage._response {return v}
      return OSUserResponse()
    }
    set {_uniqueStorage()._response = .user(newValue)}
  }

  /// 大厅相关响应
  public var lobby: OSLobbyResponse {
    get {
      if case .lobby(let v)? = _storage._response {return v}
      return OSLobbyResponse()
    }
    set {_uniqueStorage()._response = .lobby(newValue)}
  }

  /// 动态相关响应
  public var moment: OSMomentResponse {
    get {
      if case .moment(let v)? = _storage._response {return v}
      return OSMomentResponse()
    }
    set {_uniqueStorage()._response = .moment(newValue)}
  }

  /// 房间相关响应
  public var channel: OSChannelResponse {
    get {
      if case .channel(let v)? = _storage._response {return v}
      return OSChannelResponse()
    }
    set {_uniqueStorage()._response = .channel(newValue)}
  }

  /// 消息相关响应
  public var message: OSMessageResponse {
    get {
      if case .message(let v)? = _storage._response {return v}
      return OSMessageResponse()
    }
    set {_uniqueStorage()._response = .message(newValue)}
  }

  /// 商店相关请求
  public var store: OSStoreResponse {
    get {
      if case .store(let v)? = _storage._response {return v}
      return OSStoreResponse()
    }
    set {_uniqueStorage()._response = .store(newValue)}
  }

  /// 娱乐玩法相关请求
  public var play: OSPlayResponse {
    get {
      if case .play(let v)? = _storage._response {return v}
      return OSPlayResponse()
    }
    set {_uniqueStorage()._response = .play(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable, Sendable {
    case main(OSMainResponse)
    /// 用户相关响应
    case user(OSUserResponse)
    /// 大厅相关响应
    case lobby(OSLobbyResponse)
    /// 动态相关响应
    case moment(OSMomentResponse)
    /// 房间相关响应
    case channel(OSChannelResponse)
    /// 消息相关响应
    case message(OSMessageResponse)
    /// 商店相关请求
    case store(OSStoreResponse)
    /// 娱乐玩法相关请求
    case play(OSPlayResponse)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct OSMainRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSMainRequest.OneOf_Body? = nil

  /// 初始化请求
  public var init_p: OSInitReq {
    get {
      if case .init_p(let v)? = body {return v}
      return OSInitReq()
    }
    set {body = .init_p(newValue)}
  }

  /// 获取验证码请求
  public var smsReq: OSSmsReq {
    get {
      if case .smsReq(let v)? = body {return v}
      return OSSmsReq()
    }
    set {body = .smsReq(newValue)}
  }

  /// 校验验证码请求
  public var checkCodeReq: OSCheckCodeReq {
    get {
      if case .checkCodeReq(let v)? = body {return v}
      return OSCheckCodeReq()
    }
    set {body = .checkCodeReq(newValue)}
  }

  /// 版本信息请求
  public var versionReq: OSVersionReq {
    get {
      if case .versionReq(let v)? = body {return v}
      return OSVersionReq()
    }
    set {body = .versionReq(newValue)}
  }

  /// 七牛云obs信息请求
  public var qiniuObsReq: OSQiniuObsReq {
    get {
      if case .qiniuObsReq(let v)? = body {return v}
      return OSQiniuObsReq()
    }
    set {body = .qiniuObsReq(newValue)}
  }

  /// 埋点上报请求
  public var pointReportReq: OSPointReportReq {
    get {
      if case .pointReportReq(let v)? = body {return v}
      return OSPointReportReq()
    }
    set {body = .pointReportReq(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 初始化请求
    case init_p(OSInitReq)
    /// 获取验证码请求
    case smsReq(OSSmsReq)
    /// 校验验证码请求
    case checkCodeReq(OSCheckCodeReq)
    /// 版本信息请求
    case versionReq(OSVersionReq)
    /// 七牛云obs信息请求
    case qiniuObsReq(OSQiniuObsReq)
    /// 埋点上报请求
    case pointReportReq(OSPointReportReq)

  }

  public init() {}
}

public struct OSMainResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSMainResponse.OneOf_Body? = nil

  /// 初始化响应
  public var init_p: OSInitRes {
    get {
      if case .init_p(let v)? = body {return v}
      return OSInitRes()
    }
    set {body = .init_p(newValue)}
  }

  /// 获取验证码响应
  public var smsRes: OSSmsRes {
    get {
      if case .smsRes(let v)? = body {return v}
      return OSSmsRes()
    }
    set {body = .smsRes(newValue)}
  }

  /// 校验验证码响应
  public var checkCodeRes: OSCheckCodeRes {
    get {
      if case .checkCodeRes(let v)? = body {return v}
      return OSCheckCodeRes()
    }
    set {body = .checkCodeRes(newValue)}
  }

  /// 版本信息响应
  public var versionRes: OSVersionRes {
    get {
      if case .versionRes(let v)? = body {return v}
      return OSVersionRes()
    }
    set {body = .versionRes(newValue)}
  }

  /// 七牛云obs信息响应
  public var qiniuObsRes: OSQiniuObsRes {
    get {
      if case .qiniuObsRes(let v)? = body {return v}
      return OSQiniuObsRes()
    }
    set {body = .qiniuObsRes(newValue)}
  }

  /// 埋点上报响应
  public var pointReportRes: OSPointReportRes {
    get {
      if case .pointReportRes(let v)? = body {return v}
      return OSPointReportRes()
    }
    set {body = .pointReportRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 初始化响应
    case init_p(OSInitRes)
    /// 获取验证码响应
    case smsRes(OSSmsRes)
    /// 校验验证码响应
    case checkCodeRes(OSCheckCodeRes)
    /// 版本信息响应
    case versionRes(OSVersionRes)
    /// 七牛云obs信息响应
    case qiniuObsRes(OSQiniuObsRes)
    /// 埋点上报响应
    case pointReportRes(OSPointReportRes)

  }

  public init() {}
}

/// 初始化请求
public struct OSInitReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 初始化响应
public struct OSInitRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间背景图信息
  public var chatChannelCovers: [OSChatChannelCovers] {
    get {return _storage._chatChannelCovers}
    set {_uniqueStorage()._chatChannelCovers = newValue}
  }

  /// 表情文件信息
  public var emojis: [OSEmojis] {
    get {return _storage._emojis}
    set {_uniqueStorage()._emojis = newValue}
  }

  /// 实名认证开关 0.关闭 1.开启
  public var certificationSwitch: Int32 {
    get {return _storage._certificationSwitch}
    set {_uniqueStorage()._certificationSwitch = newValue}
  }

  /// 支付模块地址
  public var paymentHost: String {
    get {return _storage._paymentHost}
    set {_uniqueStorage()._paymentHost = newValue}
  }

  /// 华为云obs信息
  public var huaweiObs: OSHhuaweiObs {
    get {return _storage._huaweiObs ?? OSHhuaweiObs()}
    set {_uniqueStorage()._huaweiObs = newValue}
  }
  /// Returns true if `huaweiObs` has been explicitly set.
  public var hasHuaweiObs: Bool {return _storage._huaweiObs != nil}
  /// Clears the value of `huaweiObs`. Subsequent reads from it will return its default value.
  public mutating func clearHuaweiObs() {_uniqueStorage()._huaweiObs = nil}

  /// 加入房间实名认证开关
  public var channelRealSwitch: Int32 {
    get {return _storage._channelRealSwitch}
    set {_uniqueStorage()._channelRealSwitch = newValue}
  }

  /// 青少年模式开关 0.关闭 1.开启
  public var adolescentSwitch: Int32 {
    get {return _storage._adolescentSwitch}
    set {_uniqueStorage()._adolescentSwitch = newValue}
  }

  /// 公会入口开关
  public var contractSwitch: Int32 {
    get {return _storage._contractSwitch}
    set {_uniqueStorage()._contractSwitch = newValue}
  }

  /// 公会H5地址
  public var contractURL: String {
    get {return _storage._contractURL}
    set {_uniqueStorage()._contractURL = newValue}
  }

  /// 提现（我的水晶）H5地址
  public var withdrawURL: String {
    get {return _storage._withdrawURL}
    set {_uniqueStorage()._withdrawURL = newValue}
  }

  /// 长连接地址
  public var miniGameServer: String {
    get {return _storage._miniGameServer}
    set {_uniqueStorage()._miniGameServer = newValue}
  }

  /// 表情包内文件路径
  public var emojiBaseURL: String {
    get {return _storage._emojiBaseURL}
    set {_uniqueStorage()._emojiBaseURL = newValue}
  }

  /// 公会详情页H5地址
  public var familyDetailURL: String {
    get {return _storage._familyDetailURL}
    set {_uniqueStorage()._familyDetailURL = newValue}
  }

  /// 企业微信客服id
  public var wechatEnterpriseID: String {
    get {return _storage._wechatEnterpriseID}
    set {_uniqueStorage()._wechatEnterpriseID = newValue}
  }

  /// 企业微信客服地址
  public var wechatStaffService: String {
    get {return _storage._wechatStaffService}
    set {_uniqueStorage()._wechatStaffService = newValue}
  }

  ///首页标签
  public var lobbyLabels: [OSLobbyLabel] {
    get {return _storage._lobbyLabels}
    set {_uniqueStorage()._lobbyLabels = newValue}
  }

  ///启动页信息
  public var startPage: OSStartPageInfo {
    get {return _storage._startPage ?? OSStartPageInfo()}
    set {_uniqueStorage()._startPage = newValue}
  }
  /// Returns true if `startPage` has been explicitly set.
  public var hasStartPage: Bool {return _storage._startPage != nil}
  /// Clears the value of `startPage`. Subsequent reads from it will return its default value.
  public mutating func clearStartPage() {_uniqueStorage()._startPage = nil}

  /// APP用户认证方式 1实名认证2人脸认证
  public var appAuthType: Int32 {
    get {return _storage._appAuthType}
    set {_uniqueStorage()._appAuthType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 首页标签
public struct OSLobbyLabel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///菜单id
  public var menuid: Int32 = 0

  ///菜单内容
  public var menudesc: String = String()

  /// 是否显示角标0隐藏1显示
  public var showCornerMark: Int32 = 0

  /// 角标路径
  public var cornerMarkURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 表情文件信息
public struct OSEmojis: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 静态图片文件名(png)
  public var `static`: String = String()

  /// 动态图片文件名(gif)
  public var name: String = String()

  /// emoji名称
  public var dynamic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间背景图信息
public struct OSChatChannelCovers: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 背景图id
  public var id: Int32 = 0

  /// 背景图名称
  public var name: String = String()

  /// 背景图地址
  public var coverURL: String = String()

  /// svga封面背景地址
  public var svgaCoverURL: String = String()

  /// mp4封面背景地址
  public var mp4CoverURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 华为云obs信息
public struct OSHhuaweiObs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Access Key
  public var obsAk: String = String()

  /// 桶
  public var bucket: String = String()

  public var endpoint: String = String()

  /// Secret Access Key
  public var obsSk: String = String()

  /// 域名
  public var domain: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取验证码请求
public struct OSSmsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 手机号码,为空则获取已登录用户绑定手机的验证码
  public var mobilePhone: String = String()

  /// 验证码类型
  public var type: OSCodeType = .type0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取验证码响应
public struct OSSmsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 校验验证码请求
public struct OSCheckCodeReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 手机号码
  public var mobilePhone: String = String()

  /// 验证码
  public var verifyCode: String = String()

  /// 验证码类型,忘记密码传2
  public var type: OSCodeType = .type0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 校验验证码响应
public struct OSCheckCodeRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 账号列表
  public var accounts: [OSAccountVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 账号信息
public struct OSAccountVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 手机号码
  public var mobile: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 版本信息请求
public struct OSVersionReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 版本信息响应
public struct OSVersionRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 版本号
  public var versionCode: Int32 = 0

  /// 版本名
  public var versionName: String = String()

  /// 更新方式
  public var appUpdateMode: Int32 = 0

  /// 下载地址
  public var downloadURL: String = String()

  /// 更新内容
  public var updateContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 七牛云obs信息请求
public struct OSQiniuObsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 七牛云obs信息响应
public struct OSQiniuObsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenList: [OSUploadTokenVo] = []

  public var expireTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSUploadTokenVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: String = String()

  public var url: String = String()

  public var key: String = String()

  ///文件类型 1.头像 2.聊天图片 3.聊天语音 4.聊天视频 5.后台数据 6.动态资源
  public var fileType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 启动页信息
public struct OSStartPageInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 启动页名称
  public var name: String = String()

  /// 图片地址
  public var imgURL: String = String()

  /// 跳转类型 0:APP首页;1:房间;2:浏览器
  public var jumpType: String = String()

  /// 跳转目标(房间号或链接地址)
  public var jumpContent: String = String()

  ///目标房间信息
  public var jumpChannel: OSJumpChannel {
    get {return _jumpChannel ?? OSJumpChannel()}
    set {_jumpChannel = newValue}
  }
  /// Returns true if `jumpChannel` has been explicitly set.
  public var hasJumpChannel: Bool {return self._jumpChannel != nil}
  /// Clears the value of `jumpChannel`. Subsequent reads from it will return its default value.
  public mutating func clearJumpChannel() {self._jumpChannel = nil}

  ///是否显示绑定的用户信息 0否1是
  public var isShow: Int32 = 0

  ///绑定的用户信息
  public var showUserInfo: OSShowUserInfo {
    get {return _showUserInfo ?? OSShowUserInfo()}
    set {_showUserInfo = newValue}
  }
  /// Returns true if `showUserInfo` has been explicitly set.
  public var hasShowUserInfo: Bool {return self._showUserInfo != nil}
  /// Clears the value of `showUserInfo`. Subsequent reads from it will return its default value.
  public mutating func clearShowUserInfo() {self._showUserInfo = nil}

  ///启动页停留时长（秒）
  public var duration: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _jumpChannel: OSJumpChannel? = nil
  fileprivate var _showUserInfo: OSShowUserInfo? = nil
}

///跳转目标房间信息
public struct OSJumpChannel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///房间id
  public var channelID: String = String()

  ///是否是密码房（ 0:不是 1:是）
  public var lockedStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///启动页绑定展示的用户信息
public struct OSShowUserInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用户id
  public var userID: String = String()

  ///账号id
  public var accountID: Int32 = 0

  ///用户昵称
  public var nickname: String = String()

  ///用户头像
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 埋点上报请求
public struct OSPointReportReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///类型 1:动态预览
  public var eventType: OSPointReportType = .point0

  /// 动态id列表
  public var momentIds: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 埋点上报响应
public struct OSPointReportRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSRawHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RawHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
    2: .same(proto: "version"),
    3: .same(proto: "encrypt"),
    4: .same(proto: "compress"),
    5: .same(proto: "coding"),
    6: .same(proto: "module"),
    7: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.encrypt) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.compress) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.coding) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.module) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.encrypt != 0 {
      try visitor.visitSingularInt32Field(value: self.encrypt, fieldNumber: 3)
    }
    if self.compress != 0 {
      try visitor.visitSingularInt32Field(value: self.compress, fieldNumber: 4)
    }
    if self.coding != 0 {
      try visitor.visitSingularInt32Field(value: self.coding, fieldNumber: 5)
    }
    if self.module != 0 {
      try visitor.visitSingularInt32Field(value: self.module, fieldNumber: 6)
    }
    if self.context != 0 {
      try visitor.visitSingularInt32Field(value: self.context, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRawHeader, rhs: OSRawHeader) -> Bool {
    if lhs.length != rhs.length {return false}
    if lhs.version != rhs.version {return false}
    if lhs.encrypt != rhs.encrypt {return false}
    if lhs.compress != rhs.compress {return false}
    if lhs.coding != rhs.coding {return false}
    if lhs.module != rhs.module {return false}
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRequestHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "context"),
    3: .same(proto: "token"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "device"),
    6: .same(proto: "appFlag"),
    7: .same(proto: "ip"),
  ]

  fileprivate class _StorageClass {
    var _version: Int32 = 0
    var _context: Int32 = 0
    var _token: String = String()
    var _timestamp: Int64 = 0
    var _device: OSDevice? = nil
    var _appFlag: Int32 = 0
    var _ip: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _context = source._context
      _token = source._token
      _timestamp = source._timestamp
      _device = source._device
      _appFlag = source._appFlag
      _ip = source._ip
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._context) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._token) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._appFlag) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._ip) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if _storage._context != 0 {
        try visitor.visitSingularInt32Field(value: _storage._context, fieldNumber: 2)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 3)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 4)
      }
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._appFlag != 0 {
        try visitor.visitSingularInt32Field(value: _storage._appFlag, fieldNumber: 6)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRequestHeader, rhs: OSRequestHeader) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._context != rhs_storage._context {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._appFlag != rhs_storage._appFlag {return false}
        if _storage._ip != rhs_storage._ip {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSResponseHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "context"),
    3: .same(proto: "code"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "message"),
    6: .standard(proto: "user_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.context) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if self.context != 0 {
      try visitor.visitSingularInt32Field(value: self.context, fieldNumber: 2)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 5)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSResponseHeader, rhs: OSResponseHeader) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.context != rhs.context {return false}
    if lhs.code != rhs.code {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.message != rhs.message {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSApiRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "main"),
    3: .same(proto: "user"),
    4: .same(proto: "lobby"),
    5: .same(proto: "moment"),
    6: .same(proto: "channel"),
    7: .same(proto: "message"),
    8: .same(proto: "store"),
    9: .same(proto: "play"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try {
        var v: OSMainRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .main(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .main(v)
        }
      }()
      case 3: try {
        var v: OSUserRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .user(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .user(v)
        }
      }()
      case 4: try {
        var v: OSLobbyRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .lobby(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .lobby(v)
        }
      }()
      case 5: try {
        var v: OSMomentRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .moment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .moment(v)
        }
      }()
      case 6: try {
        var v: OSChannelRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .channel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .channel(v)
        }
      }()
      case 7: try {
        var v: OSMessageRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .message(v)
        }
      }()
      case 8: try {
        var v: OSStoreRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .store(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .store(v)
        }
      }()
      case 9: try {
        var v: OSPlayRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .play(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .play(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.request {
    case .main?: try {
      guard case .main(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .user?: try {
      guard case .user(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .lobby?: try {
      guard case .lobby(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .moment?: try {
      guard case .moment(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .channel?: try {
      guard case .channel(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .message?: try {
      guard case .message(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .store?: try {
      guard case .store(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .play?: try {
      guard case .play(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSApiRequest, rhs: OSApiRequest) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSApiResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "main"),
    3: .same(proto: "user"),
    4: .same(proto: "lobby"),
    5: .same(proto: "moment"),
    6: .same(proto: "channel"),
    7: .same(proto: "message"),
    8: .same(proto: "store"),
    9: .same(proto: "play"),
  ]

  fileprivate class _StorageClass {
    var _header: OSResponseHeader? = nil
    var _response: OSApiResponse.OneOf_Response?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _header = source._header
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 2: try {
          var v: OSMainResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .main(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .main(v)
          }
        }()
        case 3: try {
          var v: OSUserResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .user(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .user(v)
          }
        }()
        case 4: try {
          var v: OSLobbyResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .lobby(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .lobby(v)
          }
        }()
        case 5: try {
          var v: OSMomentResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .moment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .moment(v)
          }
        }()
        case 6: try {
          var v: OSChannelResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .channel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .channel(v)
          }
        }()
        case 7: try {
          var v: OSMessageResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .message(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .message(v)
          }
        }()
        case 8: try {
          var v: OSStoreResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .store(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .store(v)
          }
        }()
        case 9: try {
          var v: OSPlayResponse?
          var hadOneofValue = false
          if let current = _storage._response {
            hadOneofValue = true
            if case .play(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._response = .play(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      switch _storage._response {
      case .main?: try {
        guard case .main(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .user?: try {
        guard case .user(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .lobby?: try {
        guard case .lobby(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .moment?: try {
        guard case .moment(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .channel?: try {
        guard case .channel(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .message?: try {
        guard case .message(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .store?: try {
        guard case .store(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .play?: try {
        guard case .play(let v)? = _storage._response else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSApiResponse, rhs: OSApiResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._header != rhs_storage._header {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMainRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MainRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "smsReq"),
    3: .same(proto: "checkCodeReq"),
    4: .same(proto: "versionReq"),
    5: .same(proto: "qiniuObsReq"),
    6: .same(proto: "pointReportReq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSInitReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .init_p(v)
        }
      }()
      case 2: try {
        var v: OSSmsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .smsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .smsReq(v)
        }
      }()
      case 3: try {
        var v: OSCheckCodeReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .checkCodeReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .checkCodeReq(v)
        }
      }()
      case 4: try {
        var v: OSVersionReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .versionReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .versionReq(v)
        }
      }()
      case 5: try {
        var v: OSQiniuObsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .qiniuObsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .qiniuObsReq(v)
        }
      }()
      case 6: try {
        var v: OSPointReportReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pointReportReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pointReportReq(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .init_p?: try {
      guard case .init_p(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .smsReq?: try {
      guard case .smsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .checkCodeReq?: try {
      guard case .checkCodeReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .versionReq?: try {
      guard case .versionReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .qiniuObsReq?: try {
      guard case .qiniuObsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .pointReportReq?: try {
      guard case .pointReportReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMainRequest, rhs: OSMainRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMainResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MainResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "smsRes"),
    3: .same(proto: "checkCodeRes"),
    4: .same(proto: "versionRes"),
    5: .same(proto: "qiniuObsRes"),
    6: .same(proto: "pointReportRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSInitRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .init_p(v)
        }
      }()
      case 2: try {
        var v: OSSmsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .smsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .smsRes(v)
        }
      }()
      case 3: try {
        var v: OSCheckCodeRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .checkCodeRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .checkCodeRes(v)
        }
      }()
      case 4: try {
        var v: OSVersionRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .versionRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .versionRes(v)
        }
      }()
      case 5: try {
        var v: OSQiniuObsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .qiniuObsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .qiniuObsRes(v)
        }
      }()
      case 6: try {
        var v: OSPointReportRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .pointReportRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .pointReportRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .init_p?: try {
      guard case .init_p(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .smsRes?: try {
      guard case .smsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .checkCodeRes?: try {
      guard case .checkCodeRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .versionRes?: try {
      guard case .versionRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .qiniuObsRes?: try {
      guard case .qiniuObsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .pointReportRes?: try {
      guard case .pointReportRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMainResponse, rhs: OSMainResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSInitReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSInitReq, rhs: OSInitReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSInitRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatChannelCovers"),
    2: .same(proto: "emojis"),
    3: .same(proto: "certificationSwitch"),
    4: .same(proto: "paymentHost"),
    5: .same(proto: "huaweiObs"),
    6: .same(proto: "channelRealSwitch"),
    7: .same(proto: "adolescentSwitch"),
    8: .same(proto: "contractSwitch"),
    9: .same(proto: "contractUrl"),
    10: .same(proto: "withdrawUrl"),
    11: .same(proto: "miniGameServer"),
    12: .same(proto: "emojiBaseUrl"),
    13: .same(proto: "familyDetailUrl"),
    14: .same(proto: "wechatEnterpriseId"),
    15: .same(proto: "wechatStaffService"),
    16: .same(proto: "lobbyLabels"),
    17: .same(proto: "startPage"),
    18: .same(proto: "appAuthType"),
  ]

  fileprivate class _StorageClass {
    var _chatChannelCovers: [OSChatChannelCovers] = []
    var _emojis: [OSEmojis] = []
    var _certificationSwitch: Int32 = 0
    var _paymentHost: String = String()
    var _huaweiObs: OSHhuaweiObs? = nil
    var _channelRealSwitch: Int32 = 0
    var _adolescentSwitch: Int32 = 0
    var _contractSwitch: Int32 = 0
    var _contractURL: String = String()
    var _withdrawURL: String = String()
    var _miniGameServer: String = String()
    var _emojiBaseURL: String = String()
    var _familyDetailURL: String = String()
    var _wechatEnterpriseID: String = String()
    var _wechatStaffService: String = String()
    var _lobbyLabels: [OSLobbyLabel] = []
    var _startPage: OSStartPageInfo? = nil
    var _appAuthType: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _chatChannelCovers = source._chatChannelCovers
      _emojis = source._emojis
      _certificationSwitch = source._certificationSwitch
      _paymentHost = source._paymentHost
      _huaweiObs = source._huaweiObs
      _channelRealSwitch = source._channelRealSwitch
      _adolescentSwitch = source._adolescentSwitch
      _contractSwitch = source._contractSwitch
      _contractURL = source._contractURL
      _withdrawURL = source._withdrawURL
      _miniGameServer = source._miniGameServer
      _emojiBaseURL = source._emojiBaseURL
      _familyDetailURL = source._familyDetailURL
      _wechatEnterpriseID = source._wechatEnterpriseID
      _wechatStaffService = source._wechatStaffService
      _lobbyLabels = source._lobbyLabels
      _startPage = source._startPage
      _appAuthType = source._appAuthType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._chatChannelCovers) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._emojis) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._certificationSwitch) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._paymentHost) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._huaweiObs) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._channelRealSwitch) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._adolescentSwitch) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._contractSwitch) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._contractURL) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._withdrawURL) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._miniGameServer) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._emojiBaseURL) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._familyDetailURL) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._wechatEnterpriseID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._wechatStaffService) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._lobbyLabels) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._startPage) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._appAuthType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._chatChannelCovers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._chatChannelCovers, fieldNumber: 1)
      }
      if !_storage._emojis.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._emojis, fieldNumber: 2)
      }
      if _storage._certificationSwitch != 0 {
        try visitor.visitSingularInt32Field(value: _storage._certificationSwitch, fieldNumber: 3)
      }
      if !_storage._paymentHost.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentHost, fieldNumber: 4)
      }
      try { if let v = _storage._huaweiObs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._channelRealSwitch != 0 {
        try visitor.visitSingularInt32Field(value: _storage._channelRealSwitch, fieldNumber: 6)
      }
      if _storage._adolescentSwitch != 0 {
        try visitor.visitSingularInt32Field(value: _storage._adolescentSwitch, fieldNumber: 7)
      }
      if _storage._contractSwitch != 0 {
        try visitor.visitSingularInt32Field(value: _storage._contractSwitch, fieldNumber: 8)
      }
      if !_storage._contractURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._contractURL, fieldNumber: 9)
      }
      if !_storage._withdrawURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._withdrawURL, fieldNumber: 10)
      }
      if !_storage._miniGameServer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._miniGameServer, fieldNumber: 11)
      }
      if !_storage._emojiBaseURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._emojiBaseURL, fieldNumber: 12)
      }
      if !_storage._familyDetailURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._familyDetailURL, fieldNumber: 13)
      }
      if !_storage._wechatEnterpriseID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wechatEnterpriseID, fieldNumber: 14)
      }
      if !_storage._wechatStaffService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._wechatStaffService, fieldNumber: 15)
      }
      if !_storage._lobbyLabels.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._lobbyLabels, fieldNumber: 16)
      }
      try { if let v = _storage._startPage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._appAuthType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._appAuthType, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSInitRes, rhs: OSInitRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatChannelCovers != rhs_storage._chatChannelCovers {return false}
        if _storage._emojis != rhs_storage._emojis {return false}
        if _storage._certificationSwitch != rhs_storage._certificationSwitch {return false}
        if _storage._paymentHost != rhs_storage._paymentHost {return false}
        if _storage._huaweiObs != rhs_storage._huaweiObs {return false}
        if _storage._channelRealSwitch != rhs_storage._channelRealSwitch {return false}
        if _storage._adolescentSwitch != rhs_storage._adolescentSwitch {return false}
        if _storage._contractSwitch != rhs_storage._contractSwitch {return false}
        if _storage._contractURL != rhs_storage._contractURL {return false}
        if _storage._withdrawURL != rhs_storage._withdrawURL {return false}
        if _storage._miniGameServer != rhs_storage._miniGameServer {return false}
        if _storage._emojiBaseURL != rhs_storage._emojiBaseURL {return false}
        if _storage._familyDetailURL != rhs_storage._familyDetailURL {return false}
        if _storage._wechatEnterpriseID != rhs_storage._wechatEnterpriseID {return false}
        if _storage._wechatStaffService != rhs_storage._wechatStaffService {return false}
        if _storage._lobbyLabels != rhs_storage._lobbyLabels {return false}
        if _storage._startPage != rhs_storage._startPage {return false}
        if _storage._appAuthType != rhs_storage._appAuthType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLobbyLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LobbyLabel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "menuid"),
    2: .same(proto: "menudesc"),
    3: .same(proto: "showCornerMark"),
    4: .same(proto: "cornerMarkUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.menuid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.menudesc) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.showCornerMark) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cornerMarkURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.menuid != 0 {
      try visitor.visitSingularInt32Field(value: self.menuid, fieldNumber: 1)
    }
    if !self.menudesc.isEmpty {
      try visitor.visitSingularStringField(value: self.menudesc, fieldNumber: 2)
    }
    if self.showCornerMark != 0 {
      try visitor.visitSingularInt32Field(value: self.showCornerMark, fieldNumber: 3)
    }
    if !self.cornerMarkURL.isEmpty {
      try visitor.visitSingularStringField(value: self.cornerMarkURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLobbyLabel, rhs: OSLobbyLabel) -> Bool {
    if lhs.menuid != rhs.menuid {return false}
    if lhs.menudesc != rhs.menudesc {return false}
    if lhs.showCornerMark != rhs.showCornerMark {return false}
    if lhs.cornerMarkURL != rhs.cornerMarkURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSEmojis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Emojis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "static"),
    2: .same(proto: "name"),
    3: .same(proto: "dynamic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`static`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dynamic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`static`.isEmpty {
      try visitor.visitSingularStringField(value: self.`static`, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.dynamic.isEmpty {
      try visitor.visitSingularStringField(value: self.dynamic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSEmojis, rhs: OSEmojis) -> Bool {
    if lhs.`static` != rhs.`static` {return false}
    if lhs.name != rhs.name {return false}
    if lhs.dynamic != rhs.dynamic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChatChannelCovers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatChannelCovers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "coverUrl"),
    4: .same(proto: "svgaCoverUrl"),
    5: .same(proto: "mp4CoverUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.coverURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.svgaCoverURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.mp4CoverURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.coverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.coverURL, fieldNumber: 3)
    }
    if !self.svgaCoverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.svgaCoverURL, fieldNumber: 4)
    }
    if !self.mp4CoverURL.isEmpty {
      try visitor.visitSingularStringField(value: self.mp4CoverURL, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChatChannelCovers, rhs: OSChatChannelCovers) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.coverURL != rhs.coverURL {return false}
    if lhs.svgaCoverURL != rhs.svgaCoverURL {return false}
    if lhs.mp4CoverURL != rhs.mp4CoverURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSHhuaweiObs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HhuaweiObs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "obsAk"),
    2: .same(proto: "bucket"),
    3: .same(proto: "endpoint"),
    4: .same(proto: "obsSk"),
    5: .same(proto: "domain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.obsAk) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.obsSk) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.obsAk.isEmpty {
      try visitor.visitSingularStringField(value: self.obsAk, fieldNumber: 1)
    }
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 2)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 3)
    }
    if !self.obsSk.isEmpty {
      try visitor.visitSingularStringField(value: self.obsSk, fieldNumber: 4)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSHhuaweiObs, rhs: OSHhuaweiObs) -> Bool {
    if lhs.obsAk != rhs.obsAk {return false}
    if lhs.bucket != rhs.bucket {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.obsSk != rhs.obsSk {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSmsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SmsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobilePhone"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobilePhone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobilePhone.isEmpty {
      try visitor.visitSingularStringField(value: self.mobilePhone, fieldNumber: 1)
    }
    if self.type != .type0 {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSmsReq, rhs: OSSmsReq) -> Bool {
    if lhs.mobilePhone != rhs.mobilePhone {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSmsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SmsRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSmsRes, rhs: OSSmsRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCheckCodeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckCodeReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobilePhone"),
    2: .same(proto: "verifyCode"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mobilePhone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.verifyCode) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mobilePhone.isEmpty {
      try visitor.visitSingularStringField(value: self.mobilePhone, fieldNumber: 1)
    }
    if !self.verifyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verifyCode, fieldNumber: 2)
    }
    if self.type != .type0 {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCheckCodeReq, rhs: OSCheckCodeReq) -> Bool {
    if lhs.mobilePhone != rhs.mobilePhone {return false}
    if lhs.verifyCode != rhs.verifyCode {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCheckCodeRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckCodeRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCheckCodeRes, rhs: OSCheckCodeRes) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAccountVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "mobile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.mobile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.mobile.isEmpty {
      try visitor.visitSingularStringField(value: self.mobile, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAccountVo, rhs: OSAccountVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.mobile != rhs.mobile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSVersionReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSVersionReq, rhs: OSVersionReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSVersionRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "versionCode"),
    2: .same(proto: "versionName"),
    3: .same(proto: "appUpdateMode"),
    4: .same(proto: "downloadUrl"),
    5: .same(proto: "updateContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.versionCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.versionName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.appUpdateMode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.updateContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.versionCode != 0 {
      try visitor.visitSingularInt32Field(value: self.versionCode, fieldNumber: 1)
    }
    if !self.versionName.isEmpty {
      try visitor.visitSingularStringField(value: self.versionName, fieldNumber: 2)
    }
    if self.appUpdateMode != 0 {
      try visitor.visitSingularInt32Field(value: self.appUpdateMode, fieldNumber: 3)
    }
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 4)
    }
    if !self.updateContent.isEmpty {
      try visitor.visitSingularStringField(value: self.updateContent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSVersionRes, rhs: OSVersionRes) -> Bool {
    if lhs.versionCode != rhs.versionCode {return false}
    if lhs.versionName != rhs.versionName {return false}
    if lhs.appUpdateMode != rhs.appUpdateMode {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.updateContent != rhs.updateContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSQiniuObsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QiniuObsReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSQiniuObsReq, rhs: OSQiniuObsReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSQiniuObsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QiniuObsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenList"),
    2: .same(proto: "expireTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tokenList) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokenList, fieldNumber: 1)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSQiniuObsRes, rhs: OSQiniuObsRes) -> Bool {
    if lhs.tokenList != rhs.tokenList {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSUploadTokenVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadTokenVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "url"),
    3: .same(proto: "key"),
    4: .same(proto: "fileType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.fileType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if self.fileType != 0 {
      try visitor.visitSingularInt32Field(value: self.fileType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSUploadTokenVo, rhs: OSUploadTokenVo) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.url != rhs.url {return false}
    if lhs.key != rhs.key {return false}
    if lhs.fileType != rhs.fileType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStartPageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartPageInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "imgUrl"),
    3: .same(proto: "jumpType"),
    4: .same(proto: "jumpContent"),
    5: .same(proto: "jumpChannel"),
    6: .same(proto: "isShow"),
    7: .same(proto: "showUserInfo"),
    8: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imgURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.jumpType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.jumpContent) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._jumpChannel) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.isShow) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._showUserInfo) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.imgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imgURL, fieldNumber: 2)
    }
    if !self.jumpType.isEmpty {
      try visitor.visitSingularStringField(value: self.jumpType, fieldNumber: 3)
    }
    if !self.jumpContent.isEmpty {
      try visitor.visitSingularStringField(value: self.jumpContent, fieldNumber: 4)
    }
    try { if let v = self._jumpChannel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isShow != 0 {
      try visitor.visitSingularInt32Field(value: self.isShow, fieldNumber: 6)
    }
    try { if let v = self._showUserInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStartPageInfo, rhs: OSStartPageInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.imgURL != rhs.imgURL {return false}
    if lhs.jumpType != rhs.jumpType {return false}
    if lhs.jumpContent != rhs.jumpContent {return false}
    if lhs._jumpChannel != rhs._jumpChannel {return false}
    if lhs.isShow != rhs.isShow {return false}
    if lhs._showUserInfo != rhs._showUserInfo {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSJumpChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JumpChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "lockedStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSJumpChannel, rhs: OSJumpChannel) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSShowUserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShowUserInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSShowUserInfo, rhs: OSShowUserInfo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPointReportReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointReportReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eventType"),
    2: .same(proto: "momentIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.momentIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .point0 {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if !self.momentIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.momentIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPointReportReq, rhs: OSPointReportReq) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.momentIds != rhs.momentIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPointReportRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointReportRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPointReportRes, rhs: OSPointReportRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
