// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_play.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 玩法相关请求
public struct OSPlayRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSPlayRequest.OneOf_Body? = nil

  /// 礼物藏馆信息请求
  public var collectHallInfoReq: OSCollectHallInfoReq {
    get {
      if case .collectHallInfoReq(let v)? = body {return v}
      return OSCollectHallInfoReq()
    }
    set {body = .collectHallInfoReq(newValue)}
  }

  /// 用户主页系列列表请求
  public var collectHallSeriesReq: OSCollectHallSeriesReq {
    get {
      if case .collectHallSeriesReq(let v)? = body {return v}
      return OSCollectHallSeriesReq()
    }
    set {body = .collectHallSeriesReq(newValue)}
  }

  /// 限定系列礼物列表请求
  public var collectHallSeriesGiftsReq: OSCollectHallSeriesGiftsReq {
    get {
      if case .collectHallSeriesGiftsReq(let v)? = body {return v}
      return OSCollectHallSeriesGiftsReq()
    }
    set {body = .collectHallSeriesGiftsReq(newValue)}
  }

  /// 限定系列奖励列表请求
  public var collectHallSeriesPrizeReq: OSCollectHallSeriesPrizeReq {
    get {
      if case .collectHallSeriesPrizeReq(let v)? = body {return v}
      return OSCollectHallSeriesPrizeReq()
    }
    set {body = .collectHallSeriesPrizeReq(newValue)}
  }

  /// sud获取客户端code请求
  public var sudGetCodeReq: OSSudGetCodeReq {
    get {
      if case .sudGetCodeReq(let v)? = body {return v}
      return OSSudGetCodeReq()
    }
    set {body = .sudGetCodeReq(newValue)}
  }

  /// sud短期令牌Code更换长期令牌SSToken请求
  public var sudGetSstokenReq: OSSudGetSstokenReq {
    get {
      if case .sudGetSstokenReq(let v)? = body {return v}
      return OSSudGetSstokenReq()
    }
    set {body = .sudGetSstokenReq(newValue)}
  }

  /// sud刷新长期令牌请求
  public var sudUpdateSstokenReq: OSSudUpdateSstokenReq {
    get {
      if case .sudUpdateSstokenReq(let v)? = body {return v}
      return OSSudUpdateSstokenReq()
    }
    set {body = .sudUpdateSstokenReq(newValue)}
  }

  /// sud获取用户信息请求
  public var sudGetUserInfoReq: OSSudGetUserInfoReq {
    get {
      if case .sudGetUserInfoReq(let v)? = body {return v}
      return OSSudGetUserInfoReq()
    }
    set {body = .sudGetUserInfoReq(newValue)}
  }

  /// sud创建订单请求
  public var sudCreateOrderReq: OSSudCreateOrderReq {
    get {
      if case .sudCreateOrderReq(let v)? = body {return v}
      return OSSudCreateOrderReq()
    }
    set {body = .sudCreateOrderReq(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 礼物藏馆信息请求
    case collectHallInfoReq(OSCollectHallInfoReq)
    /// 用户主页系列列表请求
    case collectHallSeriesReq(OSCollectHallSeriesReq)
    /// 限定系列礼物列表请求
    case collectHallSeriesGiftsReq(OSCollectHallSeriesGiftsReq)
    /// 限定系列奖励列表请求
    case collectHallSeriesPrizeReq(OSCollectHallSeriesPrizeReq)
    /// sud获取客户端code请求
    case sudGetCodeReq(OSSudGetCodeReq)
    /// sud短期令牌Code更换长期令牌SSToken请求
    case sudGetSstokenReq(OSSudGetSstokenReq)
    /// sud刷新长期令牌请求
    case sudUpdateSstokenReq(OSSudUpdateSstokenReq)
    /// sud获取用户信息请求
    case sudGetUserInfoReq(OSSudGetUserInfoReq)
    /// sud创建订单请求
    case sudCreateOrderReq(OSSudCreateOrderReq)

  }

  public init() {}
}

/// 玩法相关响应
public struct OSPlayResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSPlayResponse.OneOf_Body? = nil

  /// 礼物藏馆信息响应
  public var collectHallInfoRes: OSCollectHallInfoRes {
    get {
      if case .collectHallInfoRes(let v)? = body {return v}
      return OSCollectHallInfoRes()
    }
    set {body = .collectHallInfoRes(newValue)}
  }

  /// 用户主页系列列表响应
  public var collectHallSeriesRes: OSCollectHallSeriesRes {
    get {
      if case .collectHallSeriesRes(let v)? = body {return v}
      return OSCollectHallSeriesRes()
    }
    set {body = .collectHallSeriesRes(newValue)}
  }

  /// 限定系列礼物列表响应
  public var collectHallSeriesGiftsRes: OSCollectHallSeriesGiftsRes {
    get {
      if case .collectHallSeriesGiftsRes(let v)? = body {return v}
      return OSCollectHallSeriesGiftsRes()
    }
    set {body = .collectHallSeriesGiftsRes(newValue)}
  }

  /// 限定系列奖励列表响应
  public var collectHallSeriesPrizeRes: OSCollectHallSeriesPrizeRes {
    get {
      if case .collectHallSeriesPrizeRes(let v)? = body {return v}
      return OSCollectHallSeriesPrizeRes()
    }
    set {body = .collectHallSeriesPrizeRes(newValue)}
  }

  /// sud获取客户端code响应
  public var sudGetCodeRes: OSSudGetCodeRes {
    get {
      if case .sudGetCodeRes(let v)? = body {return v}
      return OSSudGetCodeRes()
    }
    set {body = .sudGetCodeRes(newValue)}
  }

  /// sud短期令牌Code更换长期令牌SSToken响应
  public var sudGetSstokenRes: OSSudGetSstokenRes {
    get {
      if case .sudGetSstokenRes(let v)? = body {return v}
      return OSSudGetSstokenRes()
    }
    set {body = .sudGetSstokenRes(newValue)}
  }

  /// sud刷新长期令牌响应
  public var sudUpdateSstokenRes: OSSudUpdateSstokenRes {
    get {
      if case .sudUpdateSstokenRes(let v)? = body {return v}
      return OSSudUpdateSstokenRes()
    }
    set {body = .sudUpdateSstokenRes(newValue)}
  }

  /// sud获取用户信息响应
  public var sudGetUserInfoRes: OSSudGetUserInfoRes {
    get {
      if case .sudGetUserInfoRes(let v)? = body {return v}
      return OSSudGetUserInfoRes()
    }
    set {body = .sudGetUserInfoRes(newValue)}
  }

  /// sud创建订单响应
  public var sudCreateOrderRes: OSSudCreateOrderRes {
    get {
      if case .sudCreateOrderRes(let v)? = body {return v}
      return OSSudCreateOrderRes()
    }
    set {body = .sudCreateOrderRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 礼物藏馆信息响应
    case collectHallInfoRes(OSCollectHallInfoRes)
    /// 用户主页系列列表响应
    case collectHallSeriesRes(OSCollectHallSeriesRes)
    /// 限定系列礼物列表响应
    case collectHallSeriesGiftsRes(OSCollectHallSeriesGiftsRes)
    /// 限定系列奖励列表响应
    case collectHallSeriesPrizeRes(OSCollectHallSeriesPrizeRes)
    /// sud获取客户端code响应
    case sudGetCodeRes(OSSudGetCodeRes)
    /// sud短期令牌Code更换长期令牌SSToken响应
    case sudGetSstokenRes(OSSudGetSstokenRes)
    /// sud刷新长期令牌响应
    case sudUpdateSstokenRes(OSSudUpdateSstokenRes)
    /// sud获取用户信息响应
    case sudGetUserInfoRes(OSSudGetUserInfoRes)
    /// sud创建订单响应
    case sudCreateOrderRes(OSSudCreateOrderRes)

  }

  public init() {}
}

/// 礼物藏馆信息请求
public struct OSCollectHallInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 礼物藏馆信息响应
public struct OSCollectHallInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户藏馆信息
  public var userInfo: OSCollectionHallVo {
    get {return _userInfo ?? OSCollectionHallVo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  /// 未点亮礼物列表
  public var greyGifts: [OSCollectionHallVo] = []

  /// 已点亮礼物列表
  public var brightGifts: [OSCollectionHallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: OSCollectionHallVo? = nil
}

/// 用户主页系列列表请求
public struct OSCollectHallSeriesReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户主页系列列表响应
public struct OSCollectHallSeriesRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户主页限时系列列表
  public var userSeries: [OSCollectionHallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 限定系列礼物列表请求
public struct OSCollectHallSeriesGiftsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 系列ID
  public var seriesID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 限定系列礼物列表响应
public struct OSCollectHallSeriesGiftsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 限时系列的所有礼物列表
  public var gifts: [OSCollectionHallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 限定系列奖励列表请求
public struct OSCollectHallSeriesPrizeReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 系列ID
  public var seriesID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 限定系列奖励列表响应
public struct OSCollectHallSeriesPrizeRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///奖励标识
  public var prizeIndex: Int32 = 0

  ///是否完成获得奖励 0未完成1已完成
  public var finish: Int32 = 0

  /// 奖品列表
  public var prizes: [OSCollectionHallVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// sud获取客户端code
public struct OSSudGetCodeReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户Id(如果值为空，提取token里面的userId)
  public var userID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 限定系列奖励列表响应
public struct OSSudGetCodeRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///客户端code(默认有效时长两小时)
  public var code: String = String()

  ///过期时间戳（毫秒）
  public var expireDate: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 短期令牌Code更换长期令牌SSToken请求
public struct OSSudGetSstokenReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 客户端code
  public var code: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 短期令牌Code更换长期令牌SSToken响应
public struct OSSudGetSstokenRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///长期令牌
  public var ssToken: String = String()

  ///过期时间戳（毫秒）
  public var expireDate: Int64 = 0

  ///用户信息
  public var userInfo: OSSudUserInfo {
    get {return _userInfo ?? OSSudUserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: OSSudUserInfo? = nil
}

/// 刷新长期令牌请求
public struct OSSudUpdateSstokenReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 长期令牌
  public var ssToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 刷新长期令牌响应
public struct OSSudUpdateSstokenRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///长期令牌
  public var ssToken: String = String()

  ///过期时间戳（毫秒）
  public var expireDate: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取用户信息请求
public struct OSSudGetUserInfoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 长期令牌
  public var ssToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取用户信息响应
public struct OSSudGetUserInfoRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用户信息
  public var userInfo: OSSudUserInfo {
    get {return _userInfo ?? OSSudUserInfo()}
    set {_userInfo = newValue}
  }
  /// Returns true if `userInfo` has been explicitly set.
  public var hasUserInfo: Bool {return self._userInfo != nil}
  /// Clears the value of `userInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInfo() {self._userInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userInfo: OSSudUserInfo? = nil
}

///sud用户信息
public struct OSSudUserInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 接入方uid，机器人为空字符
  public var uid: String = String()

  /// 用户昵称
  public var nickName: String = String()

  /// 用户头像url(建议使用128*128尺寸)
  public var avatarURL: String = String()

  /// 性别（female or male or "") 未知性别请填写空字符串
  public var gender: String = String()

  /// 0:普通用户，1:机器人（默认为0）
  public var isAi: Int32 = 0

  ///  ai等级 0：简单ai 1：简单ai 2：中级ai 3：高级ai 默认为0
  public var aiLevel: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// sud创建订单请求
public struct OSSudCreateOrderReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间Id
  public var channelID: String = String()

  /// 触发的行为动作，比如打赏，购买等(狼人杀抢角色：buy_role)
  public var cmd: String = String()

  /// 付费用户uid
  public var fromUid: String = String()

  /// 目标用户uid
  public var toUid: String = String()

  /// 所属的游戏价值钻石
  public var value: Int32 = 0

  ///扩展数据 json 字符串, 特殊可选
  public var payload: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// sud创建订单响应
public struct OSSudCreateOrderRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///商户订单号id
  public var outOrderID: String = String()

  ///SUD订单号id
  public var orderID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSPlayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collectHallInfoReq"),
    2: .same(proto: "collectHallSeriesReq"),
    3: .same(proto: "CollectHallSeriesGiftsReq"),
    4: .same(proto: "collectHallSeriesPrizeReq"),
    5: .same(proto: "sudGetCodeReq"),
    6: .same(proto: "sudGetSstokenReq"),
    7: .same(proto: "sudUpdateSstokenReq"),
    8: .same(proto: "sudGetUserInfoReq"),
    9: .same(proto: "sudCreateOrderReq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSCollectHallInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallInfoReq(v)
        }
      }()
      case 2: try {
        var v: OSCollectHallSeriesReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallSeriesReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallSeriesReq(v)
        }
      }()
      case 3: try {
        var v: OSCollectHallSeriesGiftsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallSeriesGiftsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallSeriesGiftsReq(v)
        }
      }()
      case 4: try {
        var v: OSCollectHallSeriesPrizeReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallSeriesPrizeReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallSeriesPrizeReq(v)
        }
      }()
      case 5: try {
        var v: OSSudGetCodeReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudGetCodeReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudGetCodeReq(v)
        }
      }()
      case 6: try {
        var v: OSSudGetSstokenReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudGetSstokenReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudGetSstokenReq(v)
        }
      }()
      case 7: try {
        var v: OSSudUpdateSstokenReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudUpdateSstokenReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudUpdateSstokenReq(v)
        }
      }()
      case 8: try {
        var v: OSSudGetUserInfoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudGetUserInfoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudGetUserInfoReq(v)
        }
      }()
      case 9: try {
        var v: OSSudCreateOrderReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudCreateOrderReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudCreateOrderReq(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .collectHallInfoReq?: try {
      guard case .collectHallInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .collectHallSeriesReq?: try {
      guard case .collectHallSeriesReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .collectHallSeriesGiftsReq?: try {
      guard case .collectHallSeriesGiftsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .collectHallSeriesPrizeReq?: try {
      guard case .collectHallSeriesPrizeReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sudGetCodeReq?: try {
      guard case .sudGetCodeReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sudGetSstokenReq?: try {
      guard case .sudGetSstokenReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .sudUpdateSstokenReq?: try {
      guard case .sudUpdateSstokenReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .sudGetUserInfoReq?: try {
      guard case .sudGetUserInfoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sudCreateOrderReq?: try {
      guard case .sudCreateOrderReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPlayRequest, rhs: OSPlayRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPlayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collectHallInfoRes"),
    2: .same(proto: "collectHallSeriesRes"),
    3: .same(proto: "CollectHallSeriesGiftsRes"),
    4: .same(proto: "collectHallSeriesPrizeRes"),
    5: .same(proto: "sudGetCodeRes"),
    6: .same(proto: "sudGetSstokenRes"),
    7: .same(proto: "sudUpdateSstokenRes"),
    8: .same(proto: "sudGetUserInfoRes"),
    9: .same(proto: "sudCreateOrderRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSCollectHallInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallInfoRes(v)
        }
      }()
      case 2: try {
        var v: OSCollectHallSeriesRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallSeriesRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallSeriesRes(v)
        }
      }()
      case 3: try {
        var v: OSCollectHallSeriesGiftsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallSeriesGiftsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallSeriesGiftsRes(v)
        }
      }()
      case 4: try {
        var v: OSCollectHallSeriesPrizeRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .collectHallSeriesPrizeRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .collectHallSeriesPrizeRes(v)
        }
      }()
      case 5: try {
        var v: OSSudGetCodeRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudGetCodeRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudGetCodeRes(v)
        }
      }()
      case 6: try {
        var v: OSSudGetSstokenRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudGetSstokenRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudGetSstokenRes(v)
        }
      }()
      case 7: try {
        var v: OSSudUpdateSstokenRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudUpdateSstokenRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudUpdateSstokenRes(v)
        }
      }()
      case 8: try {
        var v: OSSudGetUserInfoRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudGetUserInfoRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudGetUserInfoRes(v)
        }
      }()
      case 9: try {
        var v: OSSudCreateOrderRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sudCreateOrderRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sudCreateOrderRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .collectHallInfoRes?: try {
      guard case .collectHallInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .collectHallSeriesRes?: try {
      guard case .collectHallSeriesRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .collectHallSeriesGiftsRes?: try {
      guard case .collectHallSeriesGiftsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .collectHallSeriesPrizeRes?: try {
      guard case .collectHallSeriesPrizeRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sudGetCodeRes?: try {
      guard case .sudGetCodeRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sudGetSstokenRes?: try {
      guard case .sudGetSstokenRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .sudUpdateSstokenRes?: try {
      guard case .sudUpdateSstokenRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .sudGetUserInfoRes?: try {
      guard case .sudGetUserInfoRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sudCreateOrderRes?: try {
      guard case .sudCreateOrderRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPlayResponse, rhs: OSPlayResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallInfoReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallInfoReq, rhs: OSCollectHallInfoReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userInfo"),
    2: .same(proto: "greyGifts"),
    3: .same(proto: "brightGifts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.greyGifts) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.brightGifts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.greyGifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.greyGifts, fieldNumber: 2)
    }
    if !self.brightGifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.brightGifts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallInfoRes, rhs: OSCollectHallInfoRes) -> Bool {
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs.greyGifts != rhs.greyGifts {return false}
    if lhs.brightGifts != rhs.brightGifts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallSeriesReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallSeriesReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallSeriesReq, rhs: OSCollectHallSeriesReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallSeriesRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallSeriesRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userSeries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userSeries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userSeries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userSeries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallSeriesRes, rhs: OSCollectHallSeriesRes) -> Bool {
    if lhs.userSeries != rhs.userSeries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallSeriesGiftsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallSeriesGiftsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seriesId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seriesID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seriesID != 0 {
      try visitor.visitSingularInt64Field(value: self.seriesID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallSeriesGiftsReq, rhs: OSCollectHallSeriesGiftsReq) -> Bool {
    if lhs.seriesID != rhs.seriesID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallSeriesGiftsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallSeriesGiftsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gifts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gifts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gifts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gifts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallSeriesGiftsRes, rhs: OSCollectHallSeriesGiftsRes) -> Bool {
    if lhs.gifts != rhs.gifts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallSeriesPrizeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallSeriesPrizeReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seriesId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.seriesID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seriesID != 0 {
      try visitor.visitSingularInt64Field(value: self.seriesID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallSeriesPrizeReq, rhs: OSCollectHallSeriesPrizeReq) -> Bool {
    if lhs.seriesID != rhs.seriesID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCollectHallSeriesPrizeRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CollectHallSeriesPrizeRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prizeIndex"),
    2: .same(proto: "finish"),
    3: .same(proto: "prizes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.prizeIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.prizes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prizeIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.prizeIndex, fieldNumber: 1)
    }
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 2)
    }
    if !self.prizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prizes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCollectHallSeriesPrizeRes, rhs: OSCollectHallSeriesPrizeRes) -> Bool {
    if lhs.prizeIndex != rhs.prizeIndex {return false}
    if lhs.finish != rhs.finish {return false}
    if lhs.prizes != rhs.prizes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudGetCodeReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudGetCodeReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudGetCodeReq, rhs: OSSudGetCodeReq) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudGetCodeRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudGetCodeRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "expire_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expireDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if self.expireDate != 0 {
      try visitor.visitSingularInt64Field(value: self.expireDate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudGetCodeRes, rhs: OSSudGetCodeRes) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.expireDate != rhs.expireDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudGetSstokenReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudGetSstokenReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudGetSstokenReq, rhs: OSSudGetSstokenReq) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudGetSstokenRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudGetSstokenRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ss_token"),
    2: .standard(proto: "expire_date"),
    3: .standard(proto: "user_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ssToken) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expireDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ssToken.isEmpty {
      try visitor.visitSingularStringField(value: self.ssToken, fieldNumber: 1)
    }
    if self.expireDate != 0 {
      try visitor.visitSingularInt64Field(value: self.expireDate, fieldNumber: 2)
    }
    try { if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudGetSstokenRes, rhs: OSSudGetSstokenRes) -> Bool {
    if lhs.ssToken != rhs.ssToken {return false}
    if lhs.expireDate != rhs.expireDate {return false}
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudUpdateSstokenReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudUpdateSstokenReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ssToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ssToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssToken.isEmpty {
      try visitor.visitSingularStringField(value: self.ssToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudUpdateSstokenReq, rhs: OSSudUpdateSstokenReq) -> Bool {
    if lhs.ssToken != rhs.ssToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudUpdateSstokenRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudUpdateSstokenRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ss_token"),
    2: .standard(proto: "expire_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ssToken) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expireDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssToken.isEmpty {
      try visitor.visitSingularStringField(value: self.ssToken, fieldNumber: 1)
    }
    if self.expireDate != 0 {
      try visitor.visitSingularInt64Field(value: self.expireDate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudUpdateSstokenRes, rhs: OSSudUpdateSstokenRes) -> Bool {
    if lhs.ssToken != rhs.ssToken {return false}
    if lhs.expireDate != rhs.expireDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudGetUserInfoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudGetUserInfoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ss_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ssToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ssToken.isEmpty {
      try visitor.visitSingularStringField(value: self.ssToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudGetUserInfoReq, rhs: OSSudGetUserInfoReq) -> Bool {
    if lhs.ssToken != rhs.ssToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudGetUserInfoRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudGetUserInfoRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "user_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._userInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudGetUserInfoRes, rhs: OSSudGetUserInfoRes) -> Bool {
    if lhs._userInfo != rhs._userInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudUserInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudUserInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "nick_name"),
    3: .standard(proto: "avatar_url"),
    4: .same(proto: "gender"),
    5: .standard(proto: "is_ai"),
    6: .standard(proto: "ai_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gender) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.isAi) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.aiLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uid.isEmpty {
      try visitor.visitSingularStringField(value: self.uid, fieldNumber: 1)
    }
    if !self.nickName.isEmpty {
      try visitor.visitSingularStringField(value: self.nickName, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if !self.gender.isEmpty {
      try visitor.visitSingularStringField(value: self.gender, fieldNumber: 4)
    }
    if self.isAi != 0 {
      try visitor.visitSingularInt32Field(value: self.isAi, fieldNumber: 5)
    }
    if self.aiLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.aiLevel, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudUserInfo, rhs: OSSudUserInfo) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.nickName != rhs.nickName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.isAi != rhs.isAi {return false}
    if lhs.aiLevel != rhs.aiLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudCreateOrderReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudCreateOrderReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "cmd"),
    3: .same(proto: "fromUid"),
    4: .same(proto: "toUid"),
    5: .same(proto: "value"),
    6: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cmd) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fromUid) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.toUid) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.cmd.isEmpty {
      try visitor.visitSingularStringField(value: self.cmd, fieldNumber: 2)
    }
    if !self.fromUid.isEmpty {
      try visitor.visitSingularStringField(value: self.fromUid, fieldNumber: 3)
    }
    if !self.toUid.isEmpty {
      try visitor.visitSingularStringField(value: self.toUid, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudCreateOrderReq, rhs: OSSudCreateOrderReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.cmd != rhs.cmd {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.toUid != rhs.toUid {return false}
    if lhs.value != rhs.value {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSudCreateOrderRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SudCreateOrderRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "out_order_id"),
    2: .standard(proto: "order_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outOrderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.orderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outOrderID.isEmpty {
      try visitor.visitSingularStringField(value: self.outOrderID, fieldNumber: 1)
    }
    if !self.orderID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSudCreateOrderRes, rhs: OSSudCreateOrderRes) -> Bool {
    if lhs.outOrderID != rhs.outOrderID {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
