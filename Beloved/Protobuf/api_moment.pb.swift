// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_moment.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 动态相关请求
public struct OSMomentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSMomentRequest.OneOf_Body? = nil

  /// 加载最新动态列表请求
  public var loadMomentsReq: OSLoadMomentReq {
    get {
      if case .loadMomentsReq(let v)? = body {return v}
      return OSLoadMomentReq()
    }
    set {body = .loadMomentsReq(newValue)}
  }

  /// 动态详情请求
  public var momentDetailReq: OSMomentDetailReq {
    get {
      if case .momentDetailReq(let v)? = body {return v}
      return OSMomentDetailReq()
    }
    set {body = .momentDetailReq(newValue)}
  }

  /// 加载评论列表请求
  public var loadCommentsReq: OSLoadCommentsReq {
    get {
      if case .loadCommentsReq(let v)? = body {return v}
      return OSLoadCommentsReq()
    }
    set {body = .loadCommentsReq(newValue)}
  }

  /// 我的/指定用户/标签/关注的人动态列表请求
  public var personMomentsReq: OSPersonMomentsReq {
    get {
      if case .personMomentsReq(let v)? = body {return v}
      return OSPersonMomentsReq()
    }
    set {body = .personMomentsReq(newValue)}
  }

  /// 点赞动态/评论请求
  public var applaudReq: OSApplaudReq {
    get {
      if case .applaudReq(let v)? = body {return v}
      return OSApplaudReq()
    }
    set {body = .applaudReq(newValue)}
  }

  /// 评论动态请求
  public var makeCommentReq: OSMakeCommentReq {
    get {
      if case .makeCommentReq(let v)? = body {return v}
      return OSMakeCommentReq()
    }
    set {body = .makeCommentReq(newValue)}
  }

  /// 发布动态请求
  public var publishMomentReq: OSPublishMomentReq {
    get {
      if case .publishMomentReq(let v)? = body {return v}
      return OSPublishMomentReq()
    }
    set {body = .publishMomentReq(newValue)}
  }

  /// 删除动态请求
  public var deleteMomentReq: OSDeleteMomentReq {
    get {
      if case .deleteMomentReq(let v)? = body {return v}
      return OSDeleteMomentReq()
    }
    set {body = .deleteMomentReq(newValue)}
  }

  /// 加载互动信息列表请求
  public var loadInteractionsReq: OSLoadInteractionsReq {
    get {
      if case .loadInteractionsReq(let v)? = body {return v}
      return OSLoadInteractionsReq()
    }
    set {body = .loadInteractionsReq(newValue)}
  }

  /// 获取标签(话题)列表请求
  public var loadTagsReq: OSLoadTagsReq {
    get {
      if case .loadTagsReq(let v)? = body {return v}
      return OSLoadTagsReq()
    }
    set {body = .loadTagsReq(newValue)}
  }

  /// 获取推荐动态列表请求
  public var loadRecommendMomentsReq: OSLoadRecommendMomentsReq {
    get {
      if case .loadRecommendMomentsReq(let v)? = body {return v}
      return OSLoadRecommendMomentsReq()
    }
    set {body = .loadRecommendMomentsReq(newValue)}
  }

  /// 获取推荐话题列表请求
  public var loadRecommendTopicReq: OSLoadRecommendTopicReq {
    get {
      if case .loadRecommendTopicReq(let v)? = body {return v}
      return OSLoadRecommendTopicReq()
    }
    set {body = .loadRecommendTopicReq(newValue)}
  }

  /// 根据话题获取动态请求
  public var loadTopicMomentReq: OSLoadTopicMomentReq {
    get {
      if case .loadTopicMomentReq(let v)? = body {return v}
      return OSLoadTopicMomentReq()
    }
    set {body = .loadTopicMomentReq(newValue)}
  }

  /// 将互动消息设置为全部已读请求
  public var readInteractionsReq: OSReadInteractionsReq {
    get {
      if case .readInteractionsReq(let v)? = body {return v}
      return OSReadInteractionsReq()
    }
    set {body = .readInteractionsReq(newValue)}
  }

  /// 检查动态消息请求
  public var checkMomentMessageReq: OSCheckMomentMessageReq {
    get {
      if case .checkMomentMessageReq(let v)? = body {return v}
      return OSCheckMomentMessageReq()
    }
    set {body = .checkMomentMessageReq(newValue)}
  }

  /// 获取话题详情请求
  public var topicDetailReq: OSTopicDetailReq {
    get {
      if case .topicDetailReq(let v)? = body {return v}
      return OSTopicDetailReq()
    }
    set {body = .topicDetailReq(newValue)}
  }

  /// 优质推荐房间请求
  public var recommendChannelReq: OSRecommendChannelReq {
    get {
      if case .recommendChannelReq(let v)? = body {return v}
      return OSRecommendChannelReq()
    }
    set {body = .recommendChannelReq(newValue)}
  }

  /// 话题广场列表请求
  public var topicPlazaReq: OSTopicPlazaReq {
    get {
      if case .topicPlazaReq(let v)? = body {return v}
      return OSTopicPlazaReq()
    }
    set {body = .topicPlazaReq(newValue)}
  }

  /// 动态视频列表请求
  public var loadMomentVideoReq: OSLoadMomentVideoReq {
    get {
      if case .loadMomentVideoReq(let v)? = body {return v}
      return OSLoadMomentVideoReq()
    }
    set {body = .loadMomentVideoReq(newValue)}
  }

  /// 删除动态评论请求
  public var deleteCommentReq: OSDeleteCommentReq {
    get {
      if case .deleteCommentReq(let v)? = body {return v}
      return OSDeleteCommentReq()
    }
    set {body = .deleteCommentReq(newValue)}
  }

  /// 检测动态用户所在房间状态列表请求
  public var momentStatusListReq: OSMomentStatusListReq {
    get {
      if case .momentStatusListReq(let v)? = body {return v}
      return OSMomentStatusListReq()
    }
    set {body = .momentStatusListReq(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 加载最新动态列表请求
    case loadMomentsReq(OSLoadMomentReq)
    /// 动态详情请求
    case momentDetailReq(OSMomentDetailReq)
    /// 加载评论列表请求
    case loadCommentsReq(OSLoadCommentsReq)
    /// 我的/指定用户/标签/关注的人动态列表请求
    case personMomentsReq(OSPersonMomentsReq)
    /// 点赞动态/评论请求
    case applaudReq(OSApplaudReq)
    /// 评论动态请求
    case makeCommentReq(OSMakeCommentReq)
    /// 发布动态请求
    case publishMomentReq(OSPublishMomentReq)
    /// 删除动态请求
    case deleteMomentReq(OSDeleteMomentReq)
    /// 加载互动信息列表请求
    case loadInteractionsReq(OSLoadInteractionsReq)
    /// 获取标签(话题)列表请求
    case loadTagsReq(OSLoadTagsReq)
    /// 获取推荐动态列表请求
    case loadRecommendMomentsReq(OSLoadRecommendMomentsReq)
    /// 获取推荐话题列表请求
    case loadRecommendTopicReq(OSLoadRecommendTopicReq)
    /// 根据话题获取动态请求
    case loadTopicMomentReq(OSLoadTopicMomentReq)
    /// 将互动消息设置为全部已读请求
    case readInteractionsReq(OSReadInteractionsReq)
    /// 检查动态消息请求
    case checkMomentMessageReq(OSCheckMomentMessageReq)
    /// 获取话题详情请求
    case topicDetailReq(OSTopicDetailReq)
    /// 优质推荐房间请求
    case recommendChannelReq(OSRecommendChannelReq)
    /// 话题广场列表请求
    case topicPlazaReq(OSTopicPlazaReq)
    /// 动态视频列表请求
    case loadMomentVideoReq(OSLoadMomentVideoReq)
    /// 删除动态评论请求
    case deleteCommentReq(OSDeleteCommentReq)
    /// 检测动态用户所在房间状态列表请求
    case momentStatusListReq(OSMomentStatusListReq)

  }

  public init() {}
}

/// 动态相关响应
public struct OSMomentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSMomentResponse.OneOf_Body? = nil

  /// 加载最新动态列表响应
  public var momentListRes: OSMomentListRes {
    get {
      if case .momentListRes(let v)? = body {return v}
      return OSMomentListRes()
    }
    set {body = .momentListRes(newValue)}
  }

  /// 动态详情响应
  public var momentDetailRes: OSMomentDetailRes {
    get {
      if case .momentDetailRes(let v)? = body {return v}
      return OSMomentDetailRes()
    }
    set {body = .momentDetailRes(newValue)}
  }

  /// 加载评论列表响应
  public var loadCommentsRes: OSLoadCommentsRes {
    get {
      if case .loadCommentsRes(let v)? = body {return v}
      return OSLoadCommentsRes()
    }
    set {body = .loadCommentsRes(newValue)}
  }

  /// 我的/指定用户/标签/关注的人动态列表响应
  public var personMomentsRes: OSPersonMomentsRes {
    get {
      if case .personMomentsRes(let v)? = body {return v}
      return OSPersonMomentsRes()
    }
    set {body = .personMomentsRes(newValue)}
  }

  /// 点赞动态/评论响应
  public var applaudRes: OSApplaudRes {
    get {
      if case .applaudRes(let v)? = body {return v}
      return OSApplaudRes()
    }
    set {body = .applaudRes(newValue)}
  }

  /// 评论动态请求
  public var makeCommentRes: OSMakeCommentRes {
    get {
      if case .makeCommentRes(let v)? = body {return v}
      return OSMakeCommentRes()
    }
    set {body = .makeCommentRes(newValue)}
  }

  /// 发布动态响应
  public var publishMomentRes: OSPublishMomentRes {
    get {
      if case .publishMomentRes(let v)? = body {return v}
      return OSPublishMomentRes()
    }
    set {body = .publishMomentRes(newValue)}
  }

  /// 删除动态响应
  public var deleteMomentRes: OSDeleteMomentRes {
    get {
      if case .deleteMomentRes(let v)? = body {return v}
      return OSDeleteMomentRes()
    }
    set {body = .deleteMomentRes(newValue)}
  }

  /// 加载互动信息列表响应
  public var loadInteractionsRes: OSLoadInteractionsRes {
    get {
      if case .loadInteractionsRes(let v)? = body {return v}
      return OSLoadInteractionsRes()
    }
    set {body = .loadInteractionsRes(newValue)}
  }

  /// 获取标签列表响应
  public var loadTagsRes: OSLoadTagsRes {
    get {
      if case .loadTagsRes(let v)? = body {return v}
      return OSLoadTagsRes()
    }
    set {body = .loadTagsRes(newValue)}
  }

  /// 获取推荐动态列表响应
  public var loadRecommendMomentsRes: OSLoadRecommendMomentsRes {
    get {
      if case .loadRecommendMomentsRes(let v)? = body {return v}
      return OSLoadRecommendMomentsRes()
    }
    set {body = .loadRecommendMomentsRes(newValue)}
  }

  /// 获取推荐话题列表响应
  public var loadRecommendTopicRes: OSLoadRecommendTopicRes {
    get {
      if case .loadRecommendTopicRes(let v)? = body {return v}
      return OSLoadRecommendTopicRes()
    }
    set {body = .loadRecommendTopicRes(newValue)}
  }

  /// 根据话题获取动态响应
  public var loadTopicMomentRes: OSLoadTopicMomentRes {
    get {
      if case .loadTopicMomentRes(let v)? = body {return v}
      return OSLoadTopicMomentRes()
    }
    set {body = .loadTopicMomentRes(newValue)}
  }

  /// 将互动消息设置为全部已读响应
  public var readInteractionsRes: OSReadInteractionsRes {
    get {
      if case .readInteractionsRes(let v)? = body {return v}
      return OSReadInteractionsRes()
    }
    set {body = .readInteractionsRes(newValue)}
  }

  /// 检查动态消息响应
  public var checkMomentMessageRes: OSCheckMomentMessageRes {
    get {
      if case .checkMomentMessageRes(let v)? = body {return v}
      return OSCheckMomentMessageRes()
    }
    set {body = .checkMomentMessageRes(newValue)}
  }

  /// 获取话题详情响应
  public var topicDetailRes: OSTopicDetailRes {
    get {
      if case .topicDetailRes(let v)? = body {return v}
      return OSTopicDetailRes()
    }
    set {body = .topicDetailRes(newValue)}
  }

  /// 优质推荐房间响应
  public var recommendChannelRes: OSRecommendChannelRes {
    get {
      if case .recommendChannelRes(let v)? = body {return v}
      return OSRecommendChannelRes()
    }
    set {body = .recommendChannelRes(newValue)}
  }

  /// 话题广场列表响应
  public var topicPlazaRes: OSTopicPlazaRes {
    get {
      if case .topicPlazaRes(let v)? = body {return v}
      return OSTopicPlazaRes()
    }
    set {body = .topicPlazaRes(newValue)}
  }

  /// 删除动态评论响应
  public var deleteCommentRes: OSDeleteCommentRes {
    get {
      if case .deleteCommentRes(let v)? = body {return v}
      return OSDeleteCommentRes()
    }
    set {body = .deleteCommentRes(newValue)}
  }

  /// 检测动态用户所在房间状态列表响应
  public var momentStatusListRes: OSMomentStatusListRes {
    get {
      if case .momentStatusListRes(let v)? = body {return v}
      return OSMomentStatusListRes()
    }
    set {body = .momentStatusListRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 加载最新动态列表响应
    case momentListRes(OSMomentListRes)
    /// 动态详情响应
    case momentDetailRes(OSMomentDetailRes)
    /// 加载评论列表响应
    case loadCommentsRes(OSLoadCommentsRes)
    /// 我的/指定用户/标签/关注的人动态列表响应
    case personMomentsRes(OSPersonMomentsRes)
    /// 点赞动态/评论响应
    case applaudRes(OSApplaudRes)
    /// 评论动态请求
    case makeCommentRes(OSMakeCommentRes)
    /// 发布动态响应
    case publishMomentRes(OSPublishMomentRes)
    /// 删除动态响应
    case deleteMomentRes(OSDeleteMomentRes)
    /// 加载互动信息列表响应
    case loadInteractionsRes(OSLoadInteractionsRes)
    /// 获取标签列表响应
    case loadTagsRes(OSLoadTagsRes)
    /// 获取推荐动态列表响应
    case loadRecommendMomentsRes(OSLoadRecommendMomentsRes)
    /// 获取推荐话题列表响应
    case loadRecommendTopicRes(OSLoadRecommendTopicRes)
    /// 根据话题获取动态响应
    case loadTopicMomentRes(OSLoadTopicMomentRes)
    /// 将互动消息设置为全部已读响应
    case readInteractionsRes(OSReadInteractionsRes)
    /// 检查动态消息响应
    case checkMomentMessageRes(OSCheckMomentMessageRes)
    /// 获取话题详情响应
    case topicDetailRes(OSTopicDetailRes)
    /// 优质推荐房间响应
    case recommendChannelRes(OSRecommendChannelRes)
    /// 话题广场列表响应
    case topicPlazaRes(OSTopicPlazaRes)
    /// 删除动态评论响应
    case deleteCommentRes(OSDeleteCommentRes)
    /// 检测动态用户所在房间状态列表响应
    case momentStatusListRes(OSMomentStatusListRes)

  }

  public init() {}
}

/// 加载最新动态列表请求
public struct OSLoadMomentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 每页数量大小
  public var size: Int32 = 0

  /// 0: 加载bottomMomentId（不含）后面的内容,1: 加载topMomentId（不含）前面的内容,为空则从第一个开始加载
  public var direction: Int32 = 0

  /// 本地最后一个动态id,见direction
  public var bottomMomentID: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  /// 本地第一个动态Id,见direction
  public var topMomentID: String = String()

  ///动态类型（0图文 1视频 2音频）（-1默认查询全部）
  public var type: Int32 = 0

  ///查看视频详情传入当前的动态ID
  public var currentMomentID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加载最新动态列表响应
public struct OSMomentListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态信息列表
  public var moments: [OSMomentVo] = []

  /// 是否有新动态, 0:没有 1:有
  public var hasNew_p: Int32 = 0

  /// 数量
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 动态信息
public struct OSMomentVo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态Id
  public var momentID: Int64 {
    get {return _storage._momentID}
    set {_uniqueStorage()._momentID = newValue}
  }

  /// 动态内容
  public var thought: String {
    get {return _storage._thought}
    set {_uniqueStorage()._thought = newValue}
  }

  /// 点赞数
  public var applaudCount: Int32 {
    get {return _storage._applaudCount}
    set {_uniqueStorage()._applaudCount = newValue}
  }

  /// 评论数
  public var commentCount: Int32 {
    get {return _storage._commentCount}
    set {_uniqueStorage()._commentCount = newValue}
  }

  /// 是否可以关注（0:可关注, 1:不可关注（已关注或者是自己））
  public var followed: Int32 {
    get {return _storage._followed}
    set {_uniqueStorage()._followed = newValue}
  }

  /// 是否可以点赞（0:未点赞, 1:已点赞）
  public var applaud: Int32 {
    get {return _storage._applaud}
    set {_uniqueStorage()._applaud = newValue}
  }

  /// 图片列表
  public var pictureUrls: [String] {
    get {return _storage._pictureUrls}
    set {_uniqueStorage()._pictureUrls = newValue}
  }

  /// 发布时间(时间戳)
  public var publishTime: Int64 {
    get {return _storage._publishTime}
    set {_uniqueStorage()._publishTime = newValue}
  }

  /// 发布者信息
  public var publisher: OSPublisher {
    get {return _storage._publisher ?? OSPublisher()}
    set {_uniqueStorage()._publisher = newValue}
  }
  /// Returns true if `publisher` has been explicitly set.
  public var hasPublisher: Bool {return _storage._publisher != nil}
  /// Clears the value of `publisher`. Subsequent reads from it will return its default value.
  public mutating func clearPublisher() {_uniqueStorage()._publisher = nil}

  /// 标签列表
  public var tagsList: [OSTag] {
    get {return _storage._tagsList}
    set {_uniqueStorage()._tagsList = newValue}
  }

  /// 点赞列表,点赞数大于5返回
  public var applaudList: [OSApplaudVo] {
    get {return _storage._applaudList}
    set {_uniqueStorage()._applaudList = newValue}
  }

  /// 黑名单状态(动态详情才返回) 0未拉黑 1已拉黑
  public var blacklistStatus: Int32 {
    get {return _storage._blacklistStatus}
    set {_uniqueStorage()._blacklistStatus = newValue}
  }

  ///置顶类型，0：无，1：普通置顶，2：官方置顶
  public var topType: Int32 {
    get {return _storage._topType}
    set {_uniqueStorage()._topType = newValue}
  }

  ///动态类型（0图文 1视频 2音频）（-1默认查询全部）
  public var type: Int32 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 视频/音频资源地址
  public var resourceURL: String {
    get {return _storage._resourceURL}
    set {_uniqueStorage()._resourceURL = newValue}
  }

  /// 视频/音频资源地址
  public var coverURL: String {
    get {return _storage._coverURL}
    set {_uniqueStorage()._coverURL = newValue}
  }

  ///资源时长(秒)
  public var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  ///视频/资源大小(字节)
  public var resourceSize: Int32 {
    get {return _storage._resourceSize}
    set {_uniqueStorage()._resourceSize = newValue}
  }

  ///视频宽(像素)
  public var width: Int32 {
    get {return _storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  ///视频高(像素)
  public var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  ///房间Id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  ///是否上锁, 0:否 1:是
  public var lockedStatus: Int32 {
    get {return _storage._lockedStatus}
    set {_uniqueStorage()._lockedStatus = newValue}
  }

  /// 用户Id
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 发布者信息
public struct OSPublisher: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 房间id
  public var channelID: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 标签信息
public struct OSTag: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 标签id
  public var id: Int32 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// 标签标题
  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// 标签图片
  public var tagImg: String {
    get {return _storage._tagImg}
    set {_uniqueStorage()._tagImg = newValue}
  }

  /// 标签背景图
  public var coverURL: String {
    get {return _storage._coverURL}
    set {_uniqueStorage()._coverURL = newValue}
  }

  /// 标签描述
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// 角标icon
  public var cornerIcon: String {
    get {return _storage._cornerIcon}
    set {_uniqueStorage()._cornerIcon = newValue}
  }

  /// 动态数量
  public var momentCount: Int32 {
    get {return _storage._momentCount}
    set {_uniqueStorage()._momentCount = newValue}
  }

  /// 点赞数量
  public var applaudCount: Int32 {
    get {return _storage._applaudCount}
    set {_uniqueStorage()._applaudCount = newValue}
  }

  /// 参与用户数量
  public var userCount: Int32 {
    get {return _storage._userCount}
    set {_uniqueStorage()._userCount = newValue}
  }

  /// 排序
  public var sort: Int32 {
    get {return _storage._sort}
    set {_uniqueStorage()._sort = newValue}
  }

  /// 话题图片列表(最多9张),检查动态消息接口返回
  public var pictureList: [String] {
    get {return _storage._pictureList}
    set {_uniqueStorage()._pictureList = newValue}
  }

  /// 最新发布的一条动态消息,话题广场列表接口返回
  public var moment: OSLatestMoment {
    get {return _storage._moment ?? OSLatestMoment()}
    set {_uniqueStorage()._moment = newValue}
  }
  /// Returns true if `moment` has been explicitly set.
  public var hasMoment: Bool {return _storage._moment != nil}
  /// Clears the value of `moment`. Subsequent reads from it will return its default value.
  public mutating func clearMoment() {_uniqueStorage()._moment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 点赞用户信息
public struct OSApplaudVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户昵称
  public var nickname: String = String()

  /// 用户头像
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 最新发布的动态消息
public struct OSLatestMoment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态Id
  public var momentID: Int64 = 0

  /// 用户系统id
  public var userID: String = String()

  /// 账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 动态内容
  public var thought: String = String()

  /// 图片列表
  public var pictureURL: String = String()

  /// 发布时间戳
  public var publishTime: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 动态详情请求
public struct OSMomentDetailReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 动态详情响应
public struct OSMomentDetailRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态信息
  public var moment: OSMomentVo {
    get {return _moment ?? OSMomentVo()}
    set {_moment = newValue}
  }
  /// Returns true if `moment` has been explicitly set.
  public var hasMoment: Bool {return self._moment != nil}
  /// Clears the value of `moment`. Subsequent reads from it will return its default value.
  public mutating func clearMoment() {self._moment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _moment: OSMomentVo? = nil
}

///  加载评论列表请求
public struct OSLoadCommentsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: String = String()

  /// 当前页
  public var current: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加载评论列表响应
public struct OSLoadCommentsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 评论列表
  public var commentList: [OSCommentVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 评论信息
public struct OSCommentVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 评论ID
  public var commentID: String = String()

  /// 评论内容
  public var content: String = String()

  /// 点赞数量
  public var applaudCount: Int32 = 0

  /// 自己是否点赞(0.未点赞 1.已点赞)
  public var ownApplaud: Int32 = 0

  /// 发布时间戳
  public var publishTime: Int64 = 0

  /// 发送者信息
  public var sender: OSSender {
    get {return _sender ?? OSSender()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  /// @某人信息
  public var atComment: OSAtComment {
    get {return _atComment ?? OSAtComment()}
    set {_atComment = newValue}
  }
  /// Returns true if `atComment` has been explicitly set.
  public var hasAtComment: Bool {return self._atComment != nil}
  /// Clears the value of `atComment`. Subsequent reads from it will return its default value.
  public mutating func clearAtComment() {self._atComment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: OSSender? = nil
  fileprivate var _atComment: OSAtComment? = nil
}

/// @某人信息
public struct OSAtComment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @某人的评论Id
  public var atCommentID: Int32 = 0

  /// @某人的昵称
  public var atNickname: String = String()

  /// @某人的用户Id
  public var atUserID: String = String()

  /// @内容
  public var atContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 发送者信息
public struct OSSender: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户昵称
  public var nickname: String = String()

  /// 用户头像
  public var avatarURL: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 我的/指定用户/标签/关注的人动态列表请求
public struct OSPersonMomentsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 查询类型（0.我的 1.查询指定用户 2.标签类型获取动态  3.关注的人动态）
  public var getType: Int32 = 0

  /// 目标用户Id(getType=1时不能为空)
  public var targetUserID: String = String()

  /// 指定标签标题(getType=2时不能为空)
  public var tagTitle: String = String()

  /// 本地第一个动态Id,见direction
  public var topMomentID: String = String()

  /// 本地最后一个动态id,见direction
  public var bottomMomentID: String = String()

  /// 0:加载bottomMomentId(不含)后面的内容,1:加载topMomentId(不含)前面的内容,为空则从第一个开始加载
  public var direction: Int32 = 0

  /// 当前页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  ///动态类型（0图文 1视频 2音频）（-1默认查询全部）
  public var type: Int32 = 0

  ///查看视频详情传入当前的动态ID
  public var currentMomentID: Int64 = 0

  ///话题id(getType=2时传)
  public var topicID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 我的/指定用户/标签/关注的人动态列表响应
public struct OSPersonMomentsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态信息列表
  public var moments: [OSMomentVo] = []

  /// 是否有新动态, 0:没有 1:有
  public var hasNew_p: Int32 = 0

  /// 数量
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 点赞动态/评论请求
public struct OSApplaudReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: String = String()

  /// 点赞类型 0:取消点赞, 1:点赞
  public var liking: Int32 = 0

  /// 评论id,如果是空,则赞的是动态,否则是赞某个评论
  public var commentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 点赞动态/评论响应
public struct OSApplaudRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 评论动态请求
public struct OSMakeCommentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: String = String()

  /// 评论内容
  public var content: String = String()

  /// 非必传
  public var atUserID: String = String()

  /// 非必传
  public var atCommentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 评论动态响应
public struct OSMakeCommentRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 发送者
  public var sender: OSSender {
    get {return _sender ?? OSSender()}
    set {_sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return self._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {self._sender = nil}

  /// 评论id
  public var commentID: String = String()

  /// 点赞数
  public var applaudCount: Int32 = 0

  /// 评论内容
  public var content: String = String()

  /// 自己是否点赞(0.未点赞 1.已点赞)
  public var ownApplaud: Int32 = 0

  /// 评论时间戳
  public var publishTime: Int64 = 0

  /// @某人信息
  public var atComment: OSAtComment {
    get {return _atComment ?? OSAtComment()}
    set {_atComment = newValue}
  }
  /// Returns true if `atComment` has been explicitly set.
  public var hasAtComment: Bool {return self._atComment != nil}
  /// Clears the value of `atComment`. Subsequent reads from it will return its default value.
  public mutating func clearAtComment() {self._atComment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sender: OSSender? = nil
  fileprivate var _atComment: OSAtComment? = nil
}

/// 发布动态请求
public struct OSPublishMomentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 内容
  public var thought: String = String()

  /// 图片列表
  public var pictureUrls: [String] = []

  /// 标签Id列表
  public var tags: [String] = []

  /// 经度
  public var longitude: String = String()

  /// 纬度
  public var latitude: String = String()

  /// 定位
  public var location: String = String()

  ///动态类型（0图文 1视频 2音频）（-1默认查询全部）
  public var type: Int32 = 0

  /// 视频/音频资源地址
  public var resourceURL: String = String()

  ///资源时长(秒)
  public var duration: Int32 = 0

  ///视频/资源大小(字节)
  public var resourceSize: Int64 = 0

  ///视频宽(像素)
  public var width: Int32 = 0

  ///视频高(像素)
  public var height: Int32 = 0

  ///视频封面需要旋转的角度（无旋转传0）
  public var rotationAngle: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 发布动态响应
public struct OSPublishMomentRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: Int64 {
    get {return _storage._momentID}
    set {_uniqueStorage()._momentID = newValue}
  }

  /// 动态内容
  public var thought: String {
    get {return _storage._thought}
    set {_uniqueStorage()._thought = newValue}
  }

  /// 图片列表
  public var pictureUrls: [String] {
    get {return _storage._pictureUrls}
    set {_uniqueStorage()._pictureUrls = newValue}
  }

  /// 标签列表
  public var tagsList: [OSTag] {
    get {return _storage._tagsList}
    set {_uniqueStorage()._tagsList = newValue}
  }

  /// 发布者用户信息
  public var publisher: OSPublisher {
    get {return _storage._publisher ?? OSPublisher()}
    set {_uniqueStorage()._publisher = newValue}
  }
  /// Returns true if `publisher` has been explicitly set.
  public var hasPublisher: Bool {return _storage._publisher != nil}
  /// Clears the value of `publisher`. Subsequent reads from it will return its default value.
  public mutating func clearPublisher() {_uniqueStorage()._publisher = nil}

  /// 点赞数量
  public var applaudCount: Int32 {
    get {return _storage._applaudCount}
    set {_uniqueStorage()._applaudCount = newValue}
  }

  /// 评论数量
  public var commentCount: Int32 {
    get {return _storage._commentCount}
    set {_uniqueStorage()._commentCount = newValue}
  }

  /// 是否关注可以关注 0:可关注,1:不可关注(已关注或者是自己)
  public var followed: Int32 {
    get {return _storage._followed}
    set {_uniqueStorage()._followed = newValue}
  }

  /// 发布时间戳
  public var publishTime: Int64 {
    get {return _storage._publishTime}
    set {_uniqueStorage()._publishTime = newValue}
  }

  /// 视频/音频资源地址
  public var resourceURL: String {
    get {return _storage._resourceURL}
    set {_uniqueStorage()._resourceURL = newValue}
  }

  /// 视频/音频资源地址
  public var coverURL: String {
    get {return _storage._coverURL}
    set {_uniqueStorage()._coverURL = newValue}
  }

  ///资源时长(秒)
  public var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  ///视频/资源大小(字节)
  public var resourceSize: Int64 {
    get {return _storage._resourceSize}
    set {_uniqueStorage()._resourceSize = newValue}
  }

  ///视频宽(像素)
  public var width: Int32 {
    get {return _storage._width}
    set {_uniqueStorage()._width = newValue}
  }

  ///视频高(像素)
  public var height: Int32 {
    get {return _storage._height}
    set {_uniqueStorage()._height = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 删除动态请求
public struct OSDeleteMomentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除动态响应
public struct OSDeleteMomentRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除动态评论请求
public struct OSDeleteCommentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态id
  public var momentID: String = String()

  /// 评论id
  public var commentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 删除动态评论响应
public struct OSDeleteCommentRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加载互动信息列表请求
public struct OSLoadInteractionsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  ///类型,11=点赞,12=评论,13=关注
  public var getType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加载互动信息列表响应
public struct OSLoadInteractionsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 互动消息列表
  public var interactionList: [OSInteractionVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取标签列表请求
public struct OSLoadTagsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 搜索关键字
  public var searchStr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取标签列表响应
public struct OSLoadTagsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 标签列表
  public var tagsList: [OSTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取推荐动态列表请求
public struct OSLoadRecommendMomentsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 每页数量
  public var size: Int32 = 0

  /// 0: 加载bottomMomentId(不含)后面的内容，1: 加载topMomentId(不含)前面的内容,为空则从第一个开始加载
  public var direction: Int32 = 0

  /// 本地最后一个动态id,见direction
  public var bottomMomentID: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  ///话题id
  public var topicID: Int32 = 0

  /// 本地第一个动态Id,见direction
  public var topMomentID: String = String()

  ///动态类型（0图文 1视频 2音频）（-1默认查询全部）
  public var type: Int32 = 0

  ///查看视频详情传入当前的动态ID
  public var currentMomentID: Int64 = 0

  ///当前页
  public var current: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取推荐动态列表响应
public struct OSLoadRecommendMomentsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态信息列表
  public var moments: [OSMomentVo] = []

  /// 是否有新动态, 0:没有 1:有
  public var hasNew_p: Int32 = 0

  /// 数量
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取推荐话题列表请求
public struct OSLoadRecommendTopicReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取推荐话题列表响应
public struct OSLoadRecommendTopicRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 推荐话题列表
  public var recommendTopicList: [OSRecommendTopicList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 推荐话题列表
public struct OSRecommendTopicList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 话题id
  public var topicID: Int32 = 0

  /// 话题名称
  public var topicName: String = String()

  /// 动态数量
  public var momentCount: Int32 = 0

  /// 点赞数量
  public var applaudCount: Int32 = 0

  /// 图片列表，最多四张，最少0张
  public var pictureURLList: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 根据话题获取动态请求
public struct OSLoadTopicMomentReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 每页数量
  public var size: Int32 = 0

  /// 0: 加载bottomMomentId(不含)后面的内容，1: 加载topMomentId(不含)前面的内容,为空则从第一个开始加载
  public var direction: Int32 = 0

  /// 本地最后一个动态id,见direction
  public var bottomMomentID: String = String()

  /// 话题id
  public var topicID: Int32 = 0

  /// 动态类型,0:推荐动态 1:最新动态
  public var momentType: Int32 = 0

  /// 本地第一个动态Id,见direction
  public var topMomentID: String = String()

  ///动态类型（0图文 1视频 2音频）（-1默认查询全部）
  public var type: Int32 = 0

  ///查看视频详情传入当前的动态ID
  public var currentMomentID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 根据话题获取动态响应
public struct OSLoadTopicMomentRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态信息列表
  public var moments: [OSMomentVo] = []

  /// 数量
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 将互动消息设置为已读请求
public struct OSReadInteractionsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///类型,11=点赞,12=评论,13=关注
  public var getType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 将互动消息设置为全部已读响应
public struct OSReadInteractionsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 检查动态消息请求
public struct OSCheckMomentMessageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 检查动态消息响应
public struct OSCheckMomentMessageRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 是否有新动态消息通知,0:否,1:是
  public var hasNew_p: Int32 = 0

  /// 互动消息数量
  public var count: Int32 = 0

  /// 话题列表
  public var topicList: [OSTag] = []

  /// 点赞未读数
  public var likeCount: Int32 = 0

  /// 评论未读数
  public var commentCount: Int32 = 0

  /// 关注未读数
  public var followCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取话题详情请求
public struct OSTopicDetailReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 话题id
  public var topicID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 获取话题详情响应
public struct OSTopicDetailRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 话题详情
  public var momentTag: OSTag {
    get {return _momentTag ?? OSTag()}
    set {_momentTag = newValue}
  }
  /// Returns true if `momentTag` has been explicitly set.
  public var hasMomentTag: Bool {return self._momentTag != nil}
  /// Clears the value of `momentTag`. Subsequent reads from it will return its default value.
  public mutating func clearMomentTag() {self._momentTag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _momentTag: OSTag? = nil
}

/// 优质推荐房间请求
public struct OSRecommendChannelReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 优质推荐房间响应
public struct OSRecommendChannelRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 房间列表数据
  public var records: [OSRecommendChannel] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 推荐房间数据
public struct OSRecommendChannel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 名称
  public var name: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 是否上锁, 0:否 1:是
  public var lockedStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 话题广场列表请求
public struct OSTopicPlazaReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 话题广场列表响应
public struct OSTopicPlazaRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 话题列表
  public var topicList: [OSTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 加载动态视频列表请求
public struct OSLoadMomentVideoReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 每页数量大小
  public var size: Int32 = 0

  /// 0: 加载bottomMomentId（不含）后面的内容,1: 加载topMomentId（不含）前面的内容,为空则从第一个开始加载
  public var direction: Int32 = 0

  /// 本地最后一个动态id,见direction
  public var bottomMomentID: String = String()

  /// 性别
  public var gender: OSGender = .unknown

  ///查看视频详情传入当前的动态ID
  public var currentMomentID: Int64 = 0

  /// 本地第一个动态Id,见direction
  public var topMomentID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 检测动态用户所在房间状态列表请求
public struct OSMomentStatusListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户Id列表
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 检测动态用户所在房间状态列表响应
public struct OSMomentStatusListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 动态-所在房间状态列表
  public var momentStatusList: [OSMomentStatusVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 动态-所在房间状态
public struct OSMomentStatusVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户Id
  public var userID: String = String()

  ///房间Id
  public var channelID: String = String()

  ///是否上锁, 0:否 1:是
  public var lockedStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSMomentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loadMomentsReq"),
    2: .same(proto: "momentDetailReq"),
    3: .same(proto: "loadCommentsReq"),
    4: .same(proto: "personMomentsReq"),
    5: .same(proto: "applaudReq"),
    6: .same(proto: "makeCommentReq"),
    7: .same(proto: "publishMomentReq"),
    8: .same(proto: "deleteMomentReq"),
    9: .same(proto: "loadInteractionsReq"),
    10: .same(proto: "loadTagsReq"),
    11: .same(proto: "loadRecommendMomentsReq"),
    12: .same(proto: "loadRecommendTopicReq"),
    13: .same(proto: "loadTopicMomentReq"),
    14: .same(proto: "readInteractionsReq"),
    15: .same(proto: "checkMomentMessageReq"),
    16: .same(proto: "topicDetailReq"),
    17: .same(proto: "recommendChannelReq"),
    18: .same(proto: "topicPlazaReq"),
    19: .same(proto: "LoadMomentVideoReq"),
    20: .same(proto: "deleteCommentReq"),
    21: .same(proto: "momentStatusListReq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSLoadMomentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadMomentsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadMomentsReq(v)
        }
      }()
      case 2: try {
        var v: OSMomentDetailReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .momentDetailReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .momentDetailReq(v)
        }
      }()
      case 3: try {
        var v: OSLoadCommentsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadCommentsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadCommentsReq(v)
        }
      }()
      case 4: try {
        var v: OSPersonMomentsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personMomentsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personMomentsReq(v)
        }
      }()
      case 5: try {
        var v: OSApplaudReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .applaudReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .applaudReq(v)
        }
      }()
      case 6: try {
        var v: OSMakeCommentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .makeCommentReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .makeCommentReq(v)
        }
      }()
      case 7: try {
        var v: OSPublishMomentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .publishMomentReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .publishMomentReq(v)
        }
      }()
      case 8: try {
        var v: OSDeleteMomentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deleteMomentReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deleteMomentReq(v)
        }
      }()
      case 9: try {
        var v: OSLoadInteractionsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadInteractionsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadInteractionsReq(v)
        }
      }()
      case 10: try {
        var v: OSLoadTagsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadTagsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadTagsReq(v)
        }
      }()
      case 11: try {
        var v: OSLoadRecommendMomentsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadRecommendMomentsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadRecommendMomentsReq(v)
        }
      }()
      case 12: try {
        var v: OSLoadRecommendTopicReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadRecommendTopicReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadRecommendTopicReq(v)
        }
      }()
      case 13: try {
        var v: OSLoadTopicMomentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadTopicMomentReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadTopicMomentReq(v)
        }
      }()
      case 14: try {
        var v: OSReadInteractionsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .readInteractionsReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .readInteractionsReq(v)
        }
      }()
      case 15: try {
        var v: OSCheckMomentMessageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .checkMomentMessageReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .checkMomentMessageReq(v)
        }
      }()
      case 16: try {
        var v: OSTopicDetailReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .topicDetailReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .topicDetailReq(v)
        }
      }()
      case 17: try {
        var v: OSRecommendChannelReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .recommendChannelReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .recommendChannelReq(v)
        }
      }()
      case 18: try {
        var v: OSTopicPlazaReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .topicPlazaReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .topicPlazaReq(v)
        }
      }()
      case 19: try {
        var v: OSLoadMomentVideoReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadMomentVideoReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadMomentVideoReq(v)
        }
      }()
      case 20: try {
        var v: OSDeleteCommentReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deleteCommentReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deleteCommentReq(v)
        }
      }()
      case 21: try {
        var v: OSMomentStatusListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .momentStatusListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .momentStatusListReq(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .loadMomentsReq?: try {
      guard case .loadMomentsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .momentDetailReq?: try {
      guard case .momentDetailReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .loadCommentsReq?: try {
      guard case .loadCommentsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .personMomentsReq?: try {
      guard case .personMomentsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .applaudReq?: try {
      guard case .applaudReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .makeCommentReq?: try {
      guard case .makeCommentReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .publishMomentReq?: try {
      guard case .publishMomentReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteMomentReq?: try {
      guard case .deleteMomentReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .loadInteractionsReq?: try {
      guard case .loadInteractionsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .loadTagsReq?: try {
      guard case .loadTagsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .loadRecommendMomentsReq?: try {
      guard case .loadRecommendMomentsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .loadRecommendTopicReq?: try {
      guard case .loadRecommendTopicReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .loadTopicMomentReq?: try {
      guard case .loadTopicMomentReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .readInteractionsReq?: try {
      guard case .readInteractionsReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .checkMomentMessageReq?: try {
      guard case .checkMomentMessageReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .topicDetailReq?: try {
      guard case .topicDetailReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .recommendChannelReq?: try {
      guard case .recommendChannelReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .topicPlazaReq?: try {
      guard case .topicPlazaReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .loadMomentVideoReq?: try {
      guard case .loadMomentVideoReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .deleteCommentReq?: try {
      guard case .deleteCommentReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .momentStatusListReq?: try {
      guard case .momentStatusListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentRequest, rhs: OSMomentRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "MomentListRes"),
    2: .same(proto: "momentDetailRes"),
    3: .same(proto: "loadCommentsRes"),
    4: .same(proto: "personMomentsRes"),
    5: .same(proto: "applaudRes"),
    6: .same(proto: "makeCommentRes"),
    7: .same(proto: "publishMomentRes"),
    8: .same(proto: "deleteMomentRes"),
    9: .same(proto: "loadInteractionsRes"),
    10: .same(proto: "loadTagsRes"),
    11: .same(proto: "loadRecommendMomentsRes"),
    12: .same(proto: "loadRecommendTopicRes"),
    13: .same(proto: "loadTopicMomentRes"),
    14: .same(proto: "readInteractionsRes"),
    15: .same(proto: "checkMomentMessageRes"),
    16: .same(proto: "topicDetailRes"),
    17: .same(proto: "recommendChannelRes"),
    18: .same(proto: "topicPlazaRes"),
    20: .same(proto: "deleteCommentRes"),
    21: .same(proto: "momentStatusListRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSMomentListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .momentListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .momentListRes(v)
        }
      }()
      case 2: try {
        var v: OSMomentDetailRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .momentDetailRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .momentDetailRes(v)
        }
      }()
      case 3: try {
        var v: OSLoadCommentsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadCommentsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadCommentsRes(v)
        }
      }()
      case 4: try {
        var v: OSPersonMomentsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .personMomentsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .personMomentsRes(v)
        }
      }()
      case 5: try {
        var v: OSApplaudRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .applaudRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .applaudRes(v)
        }
      }()
      case 6: try {
        var v: OSMakeCommentRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .makeCommentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .makeCommentRes(v)
        }
      }()
      case 7: try {
        var v: OSPublishMomentRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .publishMomentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .publishMomentRes(v)
        }
      }()
      case 8: try {
        var v: OSDeleteMomentRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deleteMomentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deleteMomentRes(v)
        }
      }()
      case 9: try {
        var v: OSLoadInteractionsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadInteractionsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadInteractionsRes(v)
        }
      }()
      case 10: try {
        var v: OSLoadTagsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadTagsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadTagsRes(v)
        }
      }()
      case 11: try {
        var v: OSLoadRecommendMomentsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadRecommendMomentsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadRecommendMomentsRes(v)
        }
      }()
      case 12: try {
        var v: OSLoadRecommendTopicRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadRecommendTopicRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadRecommendTopicRes(v)
        }
      }()
      case 13: try {
        var v: OSLoadTopicMomentRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadTopicMomentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadTopicMomentRes(v)
        }
      }()
      case 14: try {
        var v: OSReadInteractionsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .readInteractionsRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .readInteractionsRes(v)
        }
      }()
      case 15: try {
        var v: OSCheckMomentMessageRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .checkMomentMessageRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .checkMomentMessageRes(v)
        }
      }()
      case 16: try {
        var v: OSTopicDetailRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .topicDetailRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .topicDetailRes(v)
        }
      }()
      case 17: try {
        var v: OSRecommendChannelRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .recommendChannelRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .recommendChannelRes(v)
        }
      }()
      case 18: try {
        var v: OSTopicPlazaRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .topicPlazaRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .topicPlazaRes(v)
        }
      }()
      case 20: try {
        var v: OSDeleteCommentRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deleteCommentRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deleteCommentRes(v)
        }
      }()
      case 21: try {
        var v: OSMomentStatusListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .momentStatusListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .momentStatusListRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .momentListRes?: try {
      guard case .momentListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .momentDetailRes?: try {
      guard case .momentDetailRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .loadCommentsRes?: try {
      guard case .loadCommentsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .personMomentsRes?: try {
      guard case .personMomentsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .applaudRes?: try {
      guard case .applaudRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .makeCommentRes?: try {
      guard case .makeCommentRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .publishMomentRes?: try {
      guard case .publishMomentRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteMomentRes?: try {
      guard case .deleteMomentRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .loadInteractionsRes?: try {
      guard case .loadInteractionsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .loadTagsRes?: try {
      guard case .loadTagsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .loadRecommendMomentsRes?: try {
      guard case .loadRecommendMomentsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .loadRecommendTopicRes?: try {
      guard case .loadRecommendTopicRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .loadTopicMomentRes?: try {
      guard case .loadTopicMomentRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .readInteractionsRes?: try {
      guard case .readInteractionsRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .checkMomentMessageRes?: try {
      guard case .checkMomentMessageRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .topicDetailRes?: try {
      guard case .topicDetailRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .recommendChannelRes?: try {
      guard case .recommendChannelRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .topicPlazaRes?: try {
      guard case .topicPlazaRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .deleteCommentRes?: try {
      guard case .deleteCommentRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .momentStatusListRes?: try {
      guard case .momentStatusListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentResponse, rhs: OSMomentResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadMomentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadMomentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "direction"),
    3: .same(proto: "bottomMomentId"),
    4: .same(proto: "gender"),
    5: .same(proto: "topMomentId"),
    9: .same(proto: "type"),
    10: .same(proto: "currentMomentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bottomMomentID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.topMomentID) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.currentMomentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 2)
    }
    if !self.bottomMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomMomentID, fieldNumber: 3)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 4)
    }
    if !self.topMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.topMomentID, fieldNumber: 5)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 9)
    }
    if self.currentMomentID != 0 {
      try visitor.visitSingularInt64Field(value: self.currentMomentID, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadMomentReq, rhs: OSLoadMomentReq) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.bottomMomentID != rhs.bottomMomentID {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.topMomentID != rhs.topMomentID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.currentMomentID != rhs.currentMomentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moments"),
    2: .same(proto: "hasNew"),
    3: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.moments) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hasNew_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moments, fieldNumber: 1)
    }
    if self.hasNew_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasNew_p, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentListRes, rhs: OSMomentListRes) -> Bool {
    if lhs.moments != rhs.moments {return false}
    if lhs.hasNew_p != rhs.hasNew_p {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "thought"),
    3: .same(proto: "applaudCount"),
    4: .same(proto: "commentCount"),
    5: .same(proto: "followed"),
    6: .same(proto: "applaud"),
    7: .same(proto: "pictureUrls"),
    8: .same(proto: "publishTime"),
    9: .same(proto: "publisher"),
    10: .same(proto: "tagsList"),
    11: .same(proto: "applaudList"),
    12: .same(proto: "blacklistStatus"),
    13: .same(proto: "topType"),
    14: .same(proto: "type"),
    15: .same(proto: "resourceUrl"),
    16: .same(proto: "coverUrl"),
    17: .same(proto: "duration"),
    18: .same(proto: "resourceSize"),
    19: .same(proto: "width"),
    20: .same(proto: "height"),
    21: .same(proto: "channelId"),
    22: .same(proto: "lockedStatus"),
    23: .same(proto: "userId"),
  ]

  fileprivate class _StorageClass {
    var _momentID: Int64 = 0
    var _thought: String = String()
    var _applaudCount: Int32 = 0
    var _commentCount: Int32 = 0
    var _followed: Int32 = 0
    var _applaud: Int32 = 0
    var _pictureUrls: [String] = []
    var _publishTime: Int64 = 0
    var _publisher: OSPublisher? = nil
    var _tagsList: [OSTag] = []
    var _applaudList: [OSApplaudVo] = []
    var _blacklistStatus: Int32 = 0
    var _topType: Int32 = 0
    var _type: Int32 = 0
    var _resourceURL: String = String()
    var _coverURL: String = String()
    var _duration: Int32 = 0
    var _resourceSize: Int32 = 0
    var _width: Int32 = 0
    var _height: Int32 = 0
    var _channelID: String = String()
    var _lockedStatus: Int32 = 0
    var _userID: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _momentID = source._momentID
      _thought = source._thought
      _applaudCount = source._applaudCount
      _commentCount = source._commentCount
      _followed = source._followed
      _applaud = source._applaud
      _pictureUrls = source._pictureUrls
      _publishTime = source._publishTime
      _publisher = source._publisher
      _tagsList = source._tagsList
      _applaudList = source._applaudList
      _blacklistStatus = source._blacklistStatus
      _topType = source._topType
      _type = source._type
      _resourceURL = source._resourceURL
      _coverURL = source._coverURL
      _duration = source._duration
      _resourceSize = source._resourceSize
      _width = source._width
      _height = source._height
      _channelID = source._channelID
      _lockedStatus = source._lockedStatus
      _userID = source._userID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._momentID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._thought) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._applaudCount) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._commentCount) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._followed) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._applaud) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._pictureUrls) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._publishTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._publisher) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._tagsList) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._applaudList) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._blacklistStatus) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._topType) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._type) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._resourceURL) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._coverURL) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._resourceSize) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._width) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._lockedStatus) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._momentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._momentID, fieldNumber: 1)
      }
      if !_storage._thought.isEmpty {
        try visitor.visitSingularStringField(value: _storage._thought, fieldNumber: 2)
      }
      if _storage._applaudCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._applaudCount, fieldNumber: 3)
      }
      if _storage._commentCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._commentCount, fieldNumber: 4)
      }
      if _storage._followed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._followed, fieldNumber: 5)
      }
      if _storage._applaud != 0 {
        try visitor.visitSingularInt32Field(value: _storage._applaud, fieldNumber: 6)
      }
      if !_storage._pictureUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._pictureUrls, fieldNumber: 7)
      }
      if _storage._publishTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._publishTime, fieldNumber: 8)
      }
      try { if let v = _storage._publisher {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._tagsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tagsList, fieldNumber: 10)
      }
      if !_storage._applaudList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._applaudList, fieldNumber: 11)
      }
      if _storage._blacklistStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blacklistStatus, fieldNumber: 12)
      }
      if _storage._topType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._topType, fieldNumber: 13)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt32Field(value: _storage._type, fieldNumber: 14)
      }
      if !_storage._resourceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceURL, fieldNumber: 15)
      }
      if !_storage._coverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._coverURL, fieldNumber: 16)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 17)
      }
      if _storage._resourceSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._resourceSize, fieldNumber: 18)
      }
      if _storage._width != 0 {
        try visitor.visitSingularInt32Field(value: _storage._width, fieldNumber: 19)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 20)
      }
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 21)
      }
      if _storage._lockedStatus != 0 {
        try visitor.visitSingularInt32Field(value: _storage._lockedStatus, fieldNumber: 22)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentVo, rhs: OSMomentVo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._momentID != rhs_storage._momentID {return false}
        if _storage._thought != rhs_storage._thought {return false}
        if _storage._applaudCount != rhs_storage._applaudCount {return false}
        if _storage._commentCount != rhs_storage._commentCount {return false}
        if _storage._followed != rhs_storage._followed {return false}
        if _storage._applaud != rhs_storage._applaud {return false}
        if _storage._pictureUrls != rhs_storage._pictureUrls {return false}
        if _storage._publishTime != rhs_storage._publishTime {return false}
        if _storage._publisher != rhs_storage._publisher {return false}
        if _storage._tagsList != rhs_storage._tagsList {return false}
        if _storage._applaudList != rhs_storage._applaudList {return false}
        if _storage._blacklistStatus != rhs_storage._blacklistStatus {return false}
        if _storage._topType != rhs_storage._topType {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._resourceURL != rhs_storage._resourceURL {return false}
        if _storage._coverURL != rhs_storage._coverURL {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._resourceSize != rhs_storage._resourceSize {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._lockedStatus != rhs_storage._lockedStatus {return false}
        if _storage._userID != rhs_storage._userID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPublisher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Publisher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "channelId"),
    6: .same(proto: "gender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 5)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPublisher, rhs: OSPublisher) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "title"),
    3: .same(proto: "tagImg"),
    4: .same(proto: "coverUrl"),
    5: .same(proto: "description"),
    6: .same(proto: "cornerIcon"),
    7: .same(proto: "momentCount"),
    8: .same(proto: "applaudCount"),
    9: .same(proto: "userCount"),
    10: .same(proto: "sort"),
    11: .same(proto: "pictureList"),
    12: .same(proto: "moment"),
  ]

  fileprivate class _StorageClass {
    var _id: Int32 = 0
    var _title: String = String()
    var _tagImg: String = String()
    var _coverURL: String = String()
    var _description_p: String = String()
    var _cornerIcon: String = String()
    var _momentCount: Int32 = 0
    var _applaudCount: Int32 = 0
    var _userCount: Int32 = 0
    var _sort: Int32 = 0
    var _pictureList: [String] = []
    var _moment: OSLatestMoment? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _title = source._title
      _tagImg = source._tagImg
      _coverURL = source._coverURL
      _description_p = source._description_p
      _cornerIcon = source._cornerIcon
      _momentCount = source._momentCount
      _applaudCount = source._applaudCount
      _userCount = source._userCount
      _sort = source._sort
      _pictureList = source._pictureList
      _moment = source._moment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._tagImg) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._coverURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._cornerIcon) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._momentCount) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._applaudCount) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._userCount) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._sort) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._pictureList) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._moment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularInt32Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 2)
      }
      if !_storage._tagImg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tagImg, fieldNumber: 3)
      }
      if !_storage._coverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._coverURL, fieldNumber: 4)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 5)
      }
      if !_storage._cornerIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cornerIcon, fieldNumber: 6)
      }
      if _storage._momentCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._momentCount, fieldNumber: 7)
      }
      if _storage._applaudCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._applaudCount, fieldNumber: 8)
      }
      if _storage._userCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._userCount, fieldNumber: 9)
      }
      if _storage._sort != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sort, fieldNumber: 10)
      }
      if !_storage._pictureList.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._pictureList, fieldNumber: 11)
      }
      try { if let v = _storage._moment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTag, rhs: OSTag) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._tagImg != rhs_storage._tagImg {return false}
        if _storage._coverURL != rhs_storage._coverURL {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._cornerIcon != rhs_storage._cornerIcon {return false}
        if _storage._momentCount != rhs_storage._momentCount {return false}
        if _storage._applaudCount != rhs_storage._applaudCount {return false}
        if _storage._userCount != rhs_storage._userCount {return false}
        if _storage._sort != rhs_storage._sort {return false}
        if _storage._pictureList != rhs_storage._pictureList {return false}
        if _storage._moment != rhs_storage._moment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSApplaudVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplaudVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "nickname"),
    3: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSApplaudVo, rhs: OSApplaudVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLatestMoment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestMoment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "userId"),
    3: .same(proto: "accountId"),
    4: .same(proto: "nickname"),
    5: .same(proto: "avatarUrl"),
    6: .same(proto: "thought"),
    7: .same(proto: "pictureUrl"),
    8: .same(proto: "publishTime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.momentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.thought) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.publishTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.momentID != 0 {
      try visitor.visitSingularInt64Field(value: self.momentID, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 4)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 5)
    }
    if !self.thought.isEmpty {
      try visitor.visitSingularStringField(value: self.thought, fieldNumber: 6)
    }
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 7)
    }
    if self.publishTime != 0 {
      try visitor.visitSingularInt64Field(value: self.publishTime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLatestMoment, rhs: OSLatestMoment) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.thought != rhs.thought {return false}
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs.publishTime != rhs.publishTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentDetailReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentDetailReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.momentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.momentID.isEmpty {
      try visitor.visitSingularStringField(value: self.momentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentDetailReq, rhs: OSMomentDetailReq) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentDetailRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentDetailRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._moment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._moment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentDetailRes, rhs: OSMomentDetailRes) -> Bool {
    if lhs._moment != rhs._moment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadCommentsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadCommentsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "current"),
    3: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.momentID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.momentID.isEmpty {
      try visitor.visitSingularStringField(value: self.momentID, fieldNumber: 1)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadCommentsReq, rhs: OSLoadCommentsReq) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadCommentsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadCommentsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.commentList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commentList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commentList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadCommentsRes, rhs: OSLoadCommentsRes) -> Bool {
    if lhs.commentList != rhs.commentList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCommentVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommentVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commentId"),
    2: .same(proto: "content"),
    3: .same(proto: "applaudCount"),
    4: .same(proto: "ownApplaud"),
    5: .same(proto: "publishTime"),
    6: .same(proto: "sender"),
    7: .same(proto: "atComment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.applaudCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.ownApplaud) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.publishTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._atComment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if self.applaudCount != 0 {
      try visitor.visitSingularInt32Field(value: self.applaudCount, fieldNumber: 3)
    }
    if self.ownApplaud != 0 {
      try visitor.visitSingularInt32Field(value: self.ownApplaud, fieldNumber: 4)
    }
    if self.publishTime != 0 {
      try visitor.visitSingularInt64Field(value: self.publishTime, fieldNumber: 5)
    }
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._atComment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCommentVo, rhs: OSCommentVo) -> Bool {
    if lhs.commentID != rhs.commentID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.applaudCount != rhs.applaudCount {return false}
    if lhs.ownApplaud != rhs.ownApplaud {return false}
    if lhs.publishTime != rhs.publishTime {return false}
    if lhs._sender != rhs._sender {return false}
    if lhs._atComment != rhs._atComment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSAtComment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AtComment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "atCommentId"),
    2: .same(proto: "atNickname"),
    3: .same(proto: "atUserId"),
    4: .same(proto: "atContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.atCommentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.atNickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.atUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.atContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.atCommentID != 0 {
      try visitor.visitSingularInt32Field(value: self.atCommentID, fieldNumber: 1)
    }
    if !self.atNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.atNickname, fieldNumber: 2)
    }
    if !self.atUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.atUserID, fieldNumber: 3)
    }
    if !self.atContent.isEmpty {
      try visitor.visitSingularStringField(value: self.atContent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSAtComment, rhs: OSAtComment) -> Bool {
    if lhs.atCommentID != rhs.atCommentID {return false}
    if lhs.atNickname != rhs.atNickname {return false}
    if lhs.atUserID != rhs.atUserID {return false}
    if lhs.atContent != rhs.atContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSender: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sender"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "nickname"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "gender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSender, rhs: OSSender) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonMomentsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonMomentsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "getType"),
    2: .same(proto: "targetUserId"),
    3: .same(proto: "tagTitle"),
    4: .same(proto: "topMomentId"),
    5: .same(proto: "bottomMomentId"),
    6: .same(proto: "direction"),
    7: .same(proto: "current"),
    8: .same(proto: "size"),
    9: .same(proto: "type"),
    10: .same(proto: "currentMomentId"),
    11: .same(proto: "topicId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.getType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetUserID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tagTitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.topMomentID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bottomMomentID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.currentMomentID) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.topicID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.getType != 0 {
      try visitor.visitSingularInt32Field(value: self.getType, fieldNumber: 1)
    }
    if !self.targetUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUserID, fieldNumber: 2)
    }
    if !self.tagTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.tagTitle, fieldNumber: 3)
    }
    if !self.topMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.topMomentID, fieldNumber: 4)
    }
    if !self.bottomMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomMomentID, fieldNumber: 5)
    }
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 6)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 7)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 8)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 9)
    }
    if self.currentMomentID != 0 {
      try visitor.visitSingularInt64Field(value: self.currentMomentID, fieldNumber: 10)
    }
    if self.topicID != 0 {
      try visitor.visitSingularInt32Field(value: self.topicID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonMomentsReq, rhs: OSPersonMomentsReq) -> Bool {
    if lhs.getType != rhs.getType {return false}
    if lhs.targetUserID != rhs.targetUserID {return false}
    if lhs.tagTitle != rhs.tagTitle {return false}
    if lhs.topMomentID != rhs.topMomentID {return false}
    if lhs.bottomMomentID != rhs.bottomMomentID {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.type != rhs.type {return false}
    if lhs.currentMomentID != rhs.currentMomentID {return false}
    if lhs.topicID != rhs.topicID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPersonMomentsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonMomentsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moments"),
    2: .same(proto: "hasNew"),
    3: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.moments) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hasNew_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moments, fieldNumber: 1)
    }
    if self.hasNew_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasNew_p, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPersonMomentsRes, rhs: OSPersonMomentsRes) -> Bool {
    if lhs.moments != rhs.moments {return false}
    if lhs.hasNew_p != rhs.hasNew_p {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSApplaudReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplaudReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "liking"),
    3: .same(proto: "commentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.momentID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.liking) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.momentID.isEmpty {
      try visitor.visitSingularStringField(value: self.momentID, fieldNumber: 1)
    }
    if self.liking != 0 {
      try visitor.visitSingularInt32Field(value: self.liking, fieldNumber: 2)
    }
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSApplaudReq, rhs: OSApplaudReq) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.liking != rhs.liking {return false}
    if lhs.commentID != rhs.commentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSApplaudRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplaudRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSApplaudRes, rhs: OSApplaudRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMakeCommentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MakeCommentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "content"),
    3: .same(proto: "atUserId"),
    4: .same(proto: "atCommentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.momentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.atUserID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.atCommentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.momentID.isEmpty {
      try visitor.visitSingularStringField(value: self.momentID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    if !self.atUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.atUserID, fieldNumber: 3)
    }
    if !self.atCommentID.isEmpty {
      try visitor.visitSingularStringField(value: self.atCommentID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMakeCommentReq, rhs: OSMakeCommentReq) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.atUserID != rhs.atUserID {return false}
    if lhs.atCommentID != rhs.atCommentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMakeCommentRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MakeCommentRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "commentId"),
    3: .same(proto: "applaudCount"),
    4: .same(proto: "content"),
    5: .same(proto: "ownApplaud"),
    6: .same(proto: "publishTime"),
    7: .same(proto: "atComment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sender) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.applaudCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.ownApplaud) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.publishTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._atComment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 2)
    }
    if self.applaudCount != 0 {
      try visitor.visitSingularInt32Field(value: self.applaudCount, fieldNumber: 3)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 4)
    }
    if self.ownApplaud != 0 {
      try visitor.visitSingularInt32Field(value: self.ownApplaud, fieldNumber: 5)
    }
    if self.publishTime != 0 {
      try visitor.visitSingularInt64Field(value: self.publishTime, fieldNumber: 6)
    }
    try { if let v = self._atComment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMakeCommentRes, rhs: OSMakeCommentRes) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs.commentID != rhs.commentID {return false}
    if lhs.applaudCount != rhs.applaudCount {return false}
    if lhs.content != rhs.content {return false}
    if lhs.ownApplaud != rhs.ownApplaud {return false}
    if lhs.publishTime != rhs.publishTime {return false}
    if lhs._atComment != rhs._atComment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPublishMomentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishMomentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "thought"),
    2: .same(proto: "pictureUrls"),
    3: .same(proto: "tags"),
    4: .same(proto: "longitude"),
    5: .same(proto: "latitude"),
    6: .same(proto: "location"),
    7: .same(proto: "type"),
    8: .same(proto: "resourceUrl"),
    9: .same(proto: "duration"),
    10: .same(proto: "resourceSize"),
    11: .same(proto: "width"),
    12: .same(proto: "height"),
    13: .same(proto: "rotationAngle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.thought) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pictureUrls) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.longitude) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.latitude) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.resourceSize) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.rotationAngle) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.thought.isEmpty {
      try visitor.visitSingularStringField(value: self.thought, fieldNumber: 1)
    }
    if !self.pictureUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pictureUrls, fieldNumber: 2)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 3)
    }
    if !self.longitude.isEmpty {
      try visitor.visitSingularStringField(value: self.longitude, fieldNumber: 4)
    }
    if !self.latitude.isEmpty {
      try visitor.visitSingularStringField(value: self.latitude, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 7)
    }
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 8)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 9)
    }
    if self.resourceSize != 0 {
      try visitor.visitSingularInt64Field(value: self.resourceSize, fieldNumber: 10)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 11)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 12)
    }
    if self.rotationAngle != 0 {
      try visitor.visitSingularInt32Field(value: self.rotationAngle, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPublishMomentReq, rhs: OSPublishMomentReq) -> Bool {
    if lhs.thought != rhs.thought {return false}
    if lhs.pictureUrls != rhs.pictureUrls {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.location != rhs.location {return false}
    if lhs.type != rhs.type {return false}
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.resourceSize != rhs.resourceSize {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.rotationAngle != rhs.rotationAngle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPublishMomentRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishMomentRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "thought"),
    3: .same(proto: "pictureUrls"),
    4: .same(proto: "tagsList"),
    5: .same(proto: "publisher"),
    6: .same(proto: "applaudCount"),
    7: .same(proto: "commentCount"),
    8: .same(proto: "followed"),
    9: .same(proto: "publishTime"),
    10: .same(proto: "resourceUrl"),
    11: .same(proto: "coverUrl"),
    12: .same(proto: "duration"),
    13: .same(proto: "resourceSize"),
    14: .same(proto: "width"),
    15: .same(proto: "height"),
  ]

  fileprivate class _StorageClass {
    var _momentID: Int64 = 0
    var _thought: String = String()
    var _pictureUrls: [String] = []
    var _tagsList: [OSTag] = []
    var _publisher: OSPublisher? = nil
    var _applaudCount: Int32 = 0
    var _commentCount: Int32 = 0
    var _followed: Int32 = 0
    var _publishTime: Int64 = 0
    var _resourceURL: String = String()
    var _coverURL: String = String()
    var _duration: Int32 = 0
    var _resourceSize: Int64 = 0
    var _width: Int32 = 0
    var _height: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _momentID = source._momentID
      _thought = source._thought
      _pictureUrls = source._pictureUrls
      _tagsList = source._tagsList
      _publisher = source._publisher
      _applaudCount = source._applaudCount
      _commentCount = source._commentCount
      _followed = source._followed
      _publishTime = source._publishTime
      _resourceURL = source._resourceURL
      _coverURL = source._coverURL
      _duration = source._duration
      _resourceSize = source._resourceSize
      _width = source._width
      _height = source._height
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._momentID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._thought) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._pictureUrls) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._tagsList) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._publisher) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._applaudCount) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._commentCount) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._followed) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._publishTime) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._resourceURL) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._coverURL) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._resourceSize) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._width) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._height) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._momentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._momentID, fieldNumber: 1)
      }
      if !_storage._thought.isEmpty {
        try visitor.visitSingularStringField(value: _storage._thought, fieldNumber: 2)
      }
      if !_storage._pictureUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._pictureUrls, fieldNumber: 3)
      }
      if !_storage._tagsList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tagsList, fieldNumber: 4)
      }
      try { if let v = _storage._publisher {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._applaudCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._applaudCount, fieldNumber: 6)
      }
      if _storage._commentCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._commentCount, fieldNumber: 7)
      }
      if _storage._followed != 0 {
        try visitor.visitSingularInt32Field(value: _storage._followed, fieldNumber: 8)
      }
      if _storage._publishTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._publishTime, fieldNumber: 9)
      }
      if !_storage._resourceURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceURL, fieldNumber: 10)
      }
      if !_storage._coverURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._coverURL, fieldNumber: 11)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 12)
      }
      if _storage._resourceSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._resourceSize, fieldNumber: 13)
      }
      if _storage._width != 0 {
        try visitor.visitSingularInt32Field(value: _storage._width, fieldNumber: 14)
      }
      if _storage._height != 0 {
        try visitor.visitSingularInt32Field(value: _storage._height, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPublishMomentRes, rhs: OSPublishMomentRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._momentID != rhs_storage._momentID {return false}
        if _storage._thought != rhs_storage._thought {return false}
        if _storage._pictureUrls != rhs_storage._pictureUrls {return false}
        if _storage._tagsList != rhs_storage._tagsList {return false}
        if _storage._publisher != rhs_storage._publisher {return false}
        if _storage._applaudCount != rhs_storage._applaudCount {return false}
        if _storage._commentCount != rhs_storage._commentCount {return false}
        if _storage._followed != rhs_storage._followed {return false}
        if _storage._publishTime != rhs_storage._publishTime {return false}
        if _storage._resourceURL != rhs_storage._resourceURL {return false}
        if _storage._coverURL != rhs_storage._coverURL {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._resourceSize != rhs_storage._resourceSize {return false}
        if _storage._width != rhs_storage._width {return false}
        if _storage._height != rhs_storage._height {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeleteMomentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMomentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.momentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.momentID != 0 {
      try visitor.visitSingularInt64Field(value: self.momentID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeleteMomentReq, rhs: OSDeleteMomentReq) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeleteMomentRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMomentRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeleteMomentRes, rhs: OSDeleteMomentRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeleteCommentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCommentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentId"),
    2: .same(proto: "commentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.momentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.momentID.isEmpty {
      try visitor.visitSingularStringField(value: self.momentID, fieldNumber: 1)
    }
    if !self.commentID.isEmpty {
      try visitor.visitSingularStringField(value: self.commentID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeleteCommentReq, rhs: OSDeleteCommentReq) -> Bool {
    if lhs.momentID != rhs.momentID {return false}
    if lhs.commentID != rhs.commentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDeleteCommentRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteCommentRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDeleteCommentRes, rhs: OSDeleteCommentRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadInteractionsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadInteractionsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "getType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.getType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.getType != 0 {
      try visitor.visitSingularInt32Field(value: self.getType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadInteractionsReq, rhs: OSLoadInteractionsReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.getType != rhs.getType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadInteractionsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadInteractionsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interactionList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.interactionList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interactionList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interactionList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadInteractionsRes, rhs: OSLoadInteractionsRes) -> Bool {
    if lhs.interactionList != rhs.interactionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadTagsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadTagsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
    3: .same(proto: "searchStr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.searchStr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if !self.searchStr.isEmpty {
      try visitor.visitSingularStringField(value: self.searchStr, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadTagsReq, rhs: OSLoadTagsReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.searchStr != rhs.searchStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadTagsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadTagsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .same(proto: "tagsList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.tagsList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagsList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tagsList, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadTagsRes, rhs: OSLoadTagsRes) -> Bool {
    if lhs.tagsList != rhs.tagsList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadRecommendMomentsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadRecommendMomentsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "direction"),
    3: .same(proto: "bottomMomentId"),
    4: .same(proto: "gender"),
    5: .same(proto: "topicId"),
    6: .same(proto: "topMomentId"),
    7: .same(proto: "type"),
    8: .same(proto: "currentMomentId"),
    9: .same(proto: "current"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bottomMomentID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.topicID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.topMomentID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.currentMomentID) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 2)
    }
    if !self.bottomMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomMomentID, fieldNumber: 3)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 4)
    }
    if self.topicID != 0 {
      try visitor.visitSingularInt32Field(value: self.topicID, fieldNumber: 5)
    }
    if !self.topMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.topMomentID, fieldNumber: 6)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 7)
    }
    if self.currentMomentID != 0 {
      try visitor.visitSingularInt64Field(value: self.currentMomentID, fieldNumber: 8)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadRecommendMomentsReq, rhs: OSLoadRecommendMomentsReq) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.bottomMomentID != rhs.bottomMomentID {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.topicID != rhs.topicID {return false}
    if lhs.topMomentID != rhs.topMomentID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.currentMomentID != rhs.currentMomentID {return false}
    if lhs.current != rhs.current {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadRecommendMomentsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadRecommendMomentsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moments"),
    2: .same(proto: "hasNew"),
    3: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.moments) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.hasNew_p) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moments, fieldNumber: 1)
    }
    if self.hasNew_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasNew_p, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadRecommendMomentsRes, rhs: OSLoadRecommendMomentsRes) -> Bool {
    if lhs.moments != rhs.moments {return false}
    if lhs.hasNew_p != rhs.hasNew_p {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadRecommendTopicReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadRecommendTopicReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadRecommendTopicReq, rhs: OSLoadRecommendTopicReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadRecommendTopicRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadRecommendTopicRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recommendTopicList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.recommendTopicList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.recommendTopicList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recommendTopicList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadRecommendTopicRes, rhs: OSLoadRecommendTopicRes) -> Bool {
    if lhs.recommendTopicList != rhs.recommendTopicList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRecommendTopicList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendTopicList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
    2: .same(proto: "topicName"),
    3: .same(proto: "momentCount"),
    4: .same(proto: "applaudCount"),
    5: .same(proto: "pictureUrlList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.topicID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topicName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.momentCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.applaudCount) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.pictureURLList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.topicID != 0 {
      try visitor.visitSingularInt32Field(value: self.topicID, fieldNumber: 1)
    }
    if !self.topicName.isEmpty {
      try visitor.visitSingularStringField(value: self.topicName, fieldNumber: 2)
    }
    if self.momentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.momentCount, fieldNumber: 3)
    }
    if self.applaudCount != 0 {
      try visitor.visitSingularInt32Field(value: self.applaudCount, fieldNumber: 4)
    }
    if !self.pictureURLList.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pictureURLList, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRecommendTopicList, rhs: OSRecommendTopicList) -> Bool {
    if lhs.topicID != rhs.topicID {return false}
    if lhs.topicName != rhs.topicName {return false}
    if lhs.momentCount != rhs.momentCount {return false}
    if lhs.applaudCount != rhs.applaudCount {return false}
    if lhs.pictureURLList != rhs.pictureURLList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadTopicMomentReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadTopicMomentReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "direction"),
    3: .same(proto: "bottomMomentId"),
    4: .same(proto: "topicId"),
    5: .same(proto: "momentType"),
    6: .same(proto: "topMomentId"),
    7: .same(proto: "type"),
    8: .same(proto: "currentMomentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bottomMomentID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.topicID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.momentType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.topMomentID) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.currentMomentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 2)
    }
    if !self.bottomMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomMomentID, fieldNumber: 3)
    }
    if self.topicID != 0 {
      try visitor.visitSingularInt32Field(value: self.topicID, fieldNumber: 4)
    }
    if self.momentType != 0 {
      try visitor.visitSingularInt32Field(value: self.momentType, fieldNumber: 5)
    }
    if !self.topMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.topMomentID, fieldNumber: 6)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 7)
    }
    if self.currentMomentID != 0 {
      try visitor.visitSingularInt64Field(value: self.currentMomentID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadTopicMomentReq, rhs: OSLoadTopicMomentReq) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.bottomMomentID != rhs.bottomMomentID {return false}
    if lhs.topicID != rhs.topicID {return false}
    if lhs.momentType != rhs.momentType {return false}
    if lhs.topMomentID != rhs.topMomentID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.currentMomentID != rhs.currentMomentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadTopicMomentRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadTopicMomentRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moments"),
    2: .same(proto: "totalSize"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.moments) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moments, fieldNumber: 1)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadTopicMomentRes, rhs: OSLoadTopicMomentRes) -> Bool {
    if lhs.moments != rhs.moments {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSReadInteractionsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadInteractionsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "getType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.getType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.getType != 0 {
      try visitor.visitSingularInt32Field(value: self.getType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSReadInteractionsReq, rhs: OSReadInteractionsReq) -> Bool {
    if lhs.getType != rhs.getType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSReadInteractionsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadInteractionsRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSReadInteractionsRes, rhs: OSReadInteractionsRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCheckMomentMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckMomentMessageReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCheckMomentMessageReq, rhs: OSCheckMomentMessageReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCheckMomentMessageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckMomentMessageRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hasNew"),
    2: .same(proto: "count"),
    3: .same(proto: "topicList"),
    4: .same(proto: "likeCount"),
    5: .same(proto: "commentCount"),
    6: .same(proto: "followCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.hasNew_p) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.topicList) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.likeCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.commentCount) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.followCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasNew_p != 0 {
      try visitor.visitSingularInt32Field(value: self.hasNew_p, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    if !self.topicList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topicList, fieldNumber: 3)
    }
    if self.likeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.likeCount, fieldNumber: 4)
    }
    if self.commentCount != 0 {
      try visitor.visitSingularInt32Field(value: self.commentCount, fieldNumber: 5)
    }
    if self.followCount != 0 {
      try visitor.visitSingularInt32Field(value: self.followCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCheckMomentMessageRes, rhs: OSCheckMomentMessageRes) -> Bool {
    if lhs.hasNew_p != rhs.hasNew_p {return false}
    if lhs.count != rhs.count {return false}
    if lhs.topicList != rhs.topicList {return false}
    if lhs.likeCount != rhs.likeCount {return false}
    if lhs.commentCount != rhs.commentCount {return false}
    if lhs.followCount != rhs.followCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTopicDetailReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicDetailReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.topicID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.topicID != 0 {
      try visitor.visitSingularInt32Field(value: self.topicID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTopicDetailReq, rhs: OSTopicDetailReq) -> Bool {
    if lhs.topicID != rhs.topicID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTopicDetailRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicDetailRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentTag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._momentTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._momentTag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTopicDetailRes, rhs: OSTopicDetailRes) -> Bool {
    if lhs._momentTag != rhs._momentTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRecommendChannelReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendChannelReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRecommendChannelReq, rhs: OSRecommendChannelReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRecommendChannelRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendChannelRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRecommendChannelRes, rhs: OSRecommendChannelRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSRecommendChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "name"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "lockedStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSRecommendChannel, rhs: OSRecommendChannel) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTopicPlazaReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicPlazaReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTopicPlazaReq, rhs: OSTopicPlazaReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTopicPlazaRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TopicPlazaRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topicList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topicList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTopicPlazaRes, rhs: OSTopicPlazaRes) -> Bool {
    if lhs.topicList != rhs.topicList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadMomentVideoReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadMomentVideoReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "direction"),
    3: .same(proto: "bottomMomentId"),
    4: .same(proto: "gender"),
    5: .same(proto: "currentMomentId"),
    6: .same(proto: "topMomentId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.direction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bottomMomentID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.currentMomentID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.topMomentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.direction != 0 {
      try visitor.visitSingularInt32Field(value: self.direction, fieldNumber: 2)
    }
    if !self.bottomMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.bottomMomentID, fieldNumber: 3)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 4)
    }
    if self.currentMomentID != 0 {
      try visitor.visitSingularInt64Field(value: self.currentMomentID, fieldNumber: 5)
    }
    if !self.topMomentID.isEmpty {
      try visitor.visitSingularStringField(value: self.topMomentID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadMomentVideoReq, rhs: OSLoadMomentVideoReq) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.bottomMomentID != rhs.bottomMomentID {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.currentMomentID != rhs.currentMomentID {return false}
    if lhs.topMomentID != rhs.topMomentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentStatusListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentStatusListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentStatusListReq, rhs: OSMomentStatusListReq) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentStatusListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentStatusListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "momentStatusList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.momentStatusList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.momentStatusList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.momentStatusList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentStatusListRes, rhs: OSMomentStatusListRes) -> Bool {
    if lhs.momentStatusList != rhs.momentStatusList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMomentStatusVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentStatusVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "channelId"),
    3: .same(proto: "lockedStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMomentStatusVo, rhs: OSMomentStatusVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
