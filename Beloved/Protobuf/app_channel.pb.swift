// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: app_channel.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// PK队伍
public enum STPkTeam: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case teamUnknown // = 0

  /// 蓝方
  case blue // = 1

  /// 红方
  case red // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .teamUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .teamUnknown
    case 1: self = .blue
    case 2: self = .red
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .teamUnknown: return 0
    case .blue: return 1
    case .red: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STPkTeam] = [
    .teamUnknown,
    .blue,
    .red,
  ]

}

/// PK类型
public enum STPkType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// 1v1
  case oneToOne // = 0

  /// 团战PK4v4
  case manyToMany // = 1

  /// 跨厅PK
  case channelToChannel // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .oneToOne
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .oneToOne
    case 1: self = .manyToMany
    case 2: self = .channelToChannel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .oneToOne: return 0
    case .manyToMany: return 1
    case .channelToChannel: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STPkType] = [
    .oneToOne,
    .manyToMany,
    .channelToChannel,
  ]

}

/// 房间火箭信息
public struct STRocketNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 达到顶级次数，不为空，默认为0
  public var count: Int32 = 0

  /// 当前等级，不为空，默认为0
  public var currentLevel: Int32 = 0

  /// 总等级
  public var totalLevel: Int32 = 0

  /// 距离下一等级还差多少值
  public var diffValue: Int32 = 0

  /// 创建时间戳(秒)
  public var createTimeStamp: Int64 = 0

  /// 过期时间戳(秒)
  public var expireTimeStamp: Int64 = 0

  /// 服务器当前时间戳(秒)
  public var currentTimeStamp: Int64 = 0

  /// 房间id
  public var channelID: String = String()

  /// 用户id
  public var userID: String = String()

  /// 用户昵称
  public var nickname: String = String()

  /// 用户头像
  public var avatarURL: String = String()

  /// 火箭图标
  public var iconURL: String = String()

  /// 火箭动画
  public var animationURL: String = String()

  /// 是否显示新征程标签;0=不显示，1=显示
  public var showLabel: Int32 = 0

  /// icon的高度
  public var height: Int32 = 0

  /// 当前等级的最大值
  public var currentLevelMaxValue: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 通用消息推送
public struct STCommonNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var commonBanner: STCommonBanner {
    get {return _commonBanner ?? STCommonBanner()}
    set {_commonBanner = newValue}
  }
  /// Returns true if `commonBanner` has been explicitly set.
  public var hasCommonBanner: Bool {return self._commonBanner != nil}
  /// Clears the value of `commonBanner`. Subsequent reads from it will return its default value.
  public mutating func clearCommonBanner() {self._commonBanner = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commonBanner: STCommonBanner? = nil
}

/// 通用横幅消息推送
public struct STCommonBanner: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 来源,0宝箱抽奖;1宝箱稀有礼物;2宝箱兑换礼物;10火箭
  public var source: Int32 = 0

  public var channelID: String = String()

  public var userID: String = String()

  public var accountID: Int32 = 0

  public var nickName: String = String()

  public var avatarURL: String = String()

  public var bannerContent: String = String()

  public var bannerStyle: String = String()

  public var createTime: Int64 = 0

  /// 是否显示指定频道的横幅(0.否,1.是)
  public var showBanner: Int32 = 0

  /// 是否全频道显示横幅(0.否,1.是)
  public var bannerGlobal: Int32 = 0

  /// 是否显示在指定频道的公屏内(0.否,1.是)
  public var showChat: Int32 = 0

  /// 是否全频道显示在公屏内(0.否,1.是)
  public var chatGlobal: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间模块
public struct STChannelResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var notification: STChannelResponse.OneOf_Notification? = nil

  /// 房间警告横幅
  public var channelWarningBanner: STChannelWarningBanner {
    get {
      if case .channelWarningBanner(let v)? = notification {return v}
      return STChannelWarningBanner()
    }
    set {notification = .channelWarningBanner(newValue)}
  }

  /// 游戏提示
  public var channelGameNotice: STChannelGameNotice {
    get {
      if case .channelGameNotice(let v)? = notification {return v}
      return STChannelGameNotice()
    }
    set {notification = .channelGameNotice(newValue)}
  }

  /// 麦位布局通知
  public var seatLayoutNotification: STSeatLayoutNotification {
    get {
      if case .seatLayoutNotification(let v)? = notification {return v}
      return STSeatLayoutNotification()
    }
    set {notification = .seatLayoutNotification(newValue)}
  }

  /// 发起PK通知
  public var askPkNotification: STAskPkNotification {
    get {
      if case .askPkNotification(let v)? = notification {return v}
      return STAskPkNotification()
    }
    set {notification = .askPkNotification(newValue)}
  }

  /// 开始PK通知
  public var startPkNotification: STStartPkNotification {
    get {
      if case .startPkNotification(let v)? = notification {return v}
      return STStartPkNotification()
    }
    set {notification = .startPkNotification(newValue)}
  }

  /// 拒绝PK通知
  public var refusePkNotification: STRefusePkNotification {
    get {
      if case .refusePkNotification(let v)? = notification {return v}
      return STRefusePkNotification()
    }
    set {notification = .refusePkNotification(newValue)}
  }

  /// 刷新PK数据通知
  public var refreshPkNotification: STRefreshPkNotification {
    get {
      if case .refreshPkNotification(let v)? = notification {return v}
      return STRefreshPkNotification()
    }
    set {notification = .refreshPkNotification(newValue)}
  }

  /// 结束PK通知
  public var finishPkNotification: STFinishPkNotification {
    get {
      if case .finishPkNotification(let v)? = notification {return v}
      return STFinishPkNotification()
    }
    set {notification = .finishPkNotification(newValue)}
  }

  /// 房间基本信息通知
  public var channelInfoNotification: STChannelInfoNotification {
    get {
      if case .channelInfoNotification(let v)? = notification {return v}
      return STChannelInfoNotification()
    }
    set {notification = .channelInfoNotification(newValue)}
  }

  /// 操作用户通知
  public var operateUserNotification: STOperateUserNotification {
    get {
      if case .operateUserNotification(let v)? = notification {return v}
      return STOperateUserNotification()
    }
    set {notification = .operateUserNotification(newValue)}
  }

  /// 移出房间通知
  public var removeUserNotification: STRemoveUserNotification {
    get {
      if case .removeUserNotification(let v)? = notification {return v}
      return STRemoveUserNotification()
    }
    set {notification = .removeUserNotification(newValue)}
  }

  /// 通用横幅通知
  public var commonBannerNotification: STCommonBannerNotification {
    get {
      if case .commonBannerNotification(let v)? = notification {return v}
      return STCommonBannerNotification()
    }
    set {notification = .commonBannerNotification(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Notification: Equatable, Sendable {
    /// 房间警告横幅
    case channelWarningBanner(STChannelWarningBanner)
    /// 游戏提示
    case channelGameNotice(STChannelGameNotice)
    /// 麦位布局通知
    case seatLayoutNotification(STSeatLayoutNotification)
    /// 发起PK通知
    case askPkNotification(STAskPkNotification)
    /// 开始PK通知
    case startPkNotification(STStartPkNotification)
    /// 拒绝PK通知
    case refusePkNotification(STRefusePkNotification)
    /// 刷新PK数据通知
    case refreshPkNotification(STRefreshPkNotification)
    /// 结束PK通知
    case finishPkNotification(STFinishPkNotification)
    /// 房间基本信息通知
    case channelInfoNotification(STChannelInfoNotification)
    /// 操作用户通知
    case operateUserNotification(STOperateUserNotification)
    /// 移出房间通知
    case removeUserNotification(STRemoveUserNotification)
    /// 通用横幅通知
    case commonBannerNotification(STCommonBannerNotification)

  }

  public init() {}
}

/// 全服霸屏特效
public struct STFullScreenEffectLocation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var srcTag: String = String()

  public var srcType: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STFullScreenEffect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///名称
  public var title: String = String()

  ///动效地址
  public var effectsURL: String = String()

  ///banner地址
  public var bannerURL: String = String()

  ///mp4里的用户位置信息
  public var locationInfo: [STFullScreenEffectLocation] = []

  ///banner跳转类型，1=跳转房间，2=跳转网页，3=个人主页
  public var linkType: Int32 = 0

  ///banner跳转内容
  public var linkValue: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间警告横幅推送
public struct STChannelWarningBanner: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 横幅内容
  public var bannerContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 游戏提示
public struct STChannelGameNotice: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 浮窗提示内容
  public var content: String = String()

  /// 持续时长，单位秒
  public var duration: Int32 = 0

  /// 抽奖类型
  public var lotteryType: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 麦位布局通知
public struct STSeatLayoutNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 麦位布局 1:横向排列(传统布局) 2:纵向排列(聊天模式)
  public var seatLayout: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 发起PK通知
public struct STAskPkNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 发起房间id
  public var channelID: String = String()

  /// 目标房间id
  public var targetChannelID: String = String()

  /// pk时长
  public var duration: Int32 = 0

  /// pk话题
  public var topic: String = String()

  /// 房间名称
  public var channelName: String = String()

  /// 房间头像
  public var avatarURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 开始PK通知
public struct STStartPkNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk信息
  public var pkGame: STPkGame {
    get {return _pkGame ?? STPkGame()}
    set {_pkGame = newValue}
  }
  /// Returns true if `pkGame` has been explicitly set.
  public var hasPkGame: Bool {return self._pkGame != nil}
  /// Clears the value of `pkGame`. Subsequent reads from it will return its default value.
  public mutating func clearPkGame() {self._pkGame = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pkGame: STPkGame? = nil
}

/// 拒绝PK通知
public struct STRefusePkNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 拒绝提示信息
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 刷新PK数据通知
public struct STRefreshPkNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk信息
  public var pkGame: STPkGame {
    get {return _pkGame ?? STPkGame()}
    set {_pkGame = newValue}
  }
  /// Returns true if `pkGame` has been explicitly set.
  public var hasPkGame: Bool {return self._pkGame != nil}
  /// Clears the value of `pkGame`. Subsequent reads from it will return its default value.
  public mutating func clearPkGame() {self._pkGame = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pkGame: STPkGame? = nil
}

/// 结束PK通知
public struct STFinishPkNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk信息
  public var pkGame: STPkGame {
    get {return _pkGame ?? STPkGame()}
    set {_pkGame = newValue}
  }
  /// Returns true if `pkGame` has been explicitly set.
  public var hasPkGame: Bool {return self._pkGame != nil}
  /// Clears the value of `pkGame`. Subsequent reads from it will return its default value.
  public mutating func clearPkGame() {self._pkGame = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pkGame: STPkGame? = nil
}

/// PK信息
public struct STPkGame: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// pk回合id
  public var pkRoundID: String {
    get {return _storage._pkRoundID}
    set {_uniqueStorage()._pkRoundID = newValue}
  }

  /// pk话题
  public var topic: String {
    get {return _storage._topic}
    set {_uniqueStorage()._topic = newValue}
  }

  /// PK类型
  public var type: STPkType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 时长
  public var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  /// 蓝方分数
  public var blueTeamScore: Int32 {
    get {return _storage._blueTeamScore}
    set {_uniqueStorage()._blueTeamScore = newValue}
  }

  /// 红方分数
  public var redTeamScore: Int32 {
    get {return _storage._redTeamScore}
    set {_uniqueStorage()._redTeamScore = newValue}
  }

  /// 开始时间
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// 结束时间
  public var endTime: Int64 {
    get {return _storage._endTime}
    set {_uniqueStorage()._endTime = newValue}
  }

  /// 1v1或团战4v4时代表参与者列表,跨厅时代表红方参与者列表
  public var participants: [STParticipantVo] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  /// 蓝方参与者列表(跨厅pk返回)
  public var blueParticipants: [STParticipantVo] {
    get {return _storage._blueParticipants}
    set {_uniqueStorage()._blueParticipants = newValue}
  }

  /// 1v1或团战4v4时代表送礼老板列表,跨厅时代表红方老板列表
  public var pkBossUsers: [STPkBossUserVo] {
    get {return _storage._pkBossUsers}
    set {_uniqueStorage()._pkBossUsers = newValue}
  }

  /// 蓝方老板列表(跨厅pk返回)
  public var bluePkBossUsers: [STPkBossUserVo] {
    get {return _storage._bluePkBossUsers}
    set {_uniqueStorage()._bluePkBossUsers = newValue}
  }

  /// 红方房间信息(跨厅pk返回)
  public var redChannelInfo: STPkChannelInfoVo {
    get {return _storage._redChannelInfo ?? STPkChannelInfoVo()}
    set {_uniqueStorage()._redChannelInfo = newValue}
  }
  /// Returns true if `redChannelInfo` has been explicitly set.
  public var hasRedChannelInfo: Bool {return _storage._redChannelInfo != nil}
  /// Clears the value of `redChannelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRedChannelInfo() {_uniqueStorage()._redChannelInfo = nil}

  /// 蓝方房间信息(跨厅pk返回)
  public var blueChannelInfo: STPkChannelInfoVo {
    get {return _storage._blueChannelInfo ?? STPkChannelInfoVo()}
    set {_uniqueStorage()._blueChannelInfo = newValue}
  }
  /// Returns true if `blueChannelInfo` has been explicitly set.
  public var hasBlueChannelInfo: Bool {return _storage._blueChannelInfo != nil}
  /// Clears the value of `blueChannelInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBlueChannelInfo() {_uniqueStorage()._blueChannelInfo = nil}

  /// pk状态 0已结束 1进行中
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// 系统当前时间
  public var systemTime: Int64 {
    get {return _storage._systemTime}
    set {_uniqueStorage()._systemTime = newValue}
  }

  ///ChannelPkVo targetChannelInfo = 18; // 其他房间信息（个播返回）
  public var redUserInSeats: [STUserInSeats] {
    get {return _storage._redUserInSeats}
    set {_uniqueStorage()._redUserInSeats = newValue}
  }

  /// 蓝方房间麦位列表信息（跨厅pk个播房间返回）
  public var blueUserInSeats: [STUserInSeats] {
    get {return _storage._blueUserInSeats}
    set {_uniqueStorage()._blueUserInSeats = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 房间Pk信息（暂不使用）
public struct STChannelPkVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间号
  public var channelNo: Int32 = 0

  /// 房间Id
  public var channelID: String = String()

  /// 房间名称
  public var channelName: String = String()

  /// 房间模式类型
  public var channelType: STChannelType = .unkown

  /// 房主Id
  public var ownerID: String = String()

  /// 房间头像
  public var avatarURL: String = String()

  /// 心动值
  public var lovenum: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 参与者信息
public struct STParticipantVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pk房间id
  public var pkChannelID: String = String()

  /// pk回合id
  public var pkID: String = String()

  /// pk队伍
  public var team: STPkTeam = .teamUnknown

  /// 用户系统id
  public var userID: String = String()

  /// 用户账号id
  public var accountID: Int32 = 0

  /// 用户昵称
  public var nickname: String = String()

  /// 用户头像
  public var avatarURL: String = String()

  /// 心动值
  public var lovenum: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 跨厅房间信息
public struct STPkChannelInfoVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 房间号
  public var channelNo: Int32 = 0

  /// 房间名称
  public var channelName: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 房主Id
  public var ownerID: String = String()

  /// 0号麦位锁状态
  public var seat0Status: Int32 = 0

  /// 1号麦位锁状态
  public var seat1Status: Int32 = 0

  /// 2号麦位锁状态
  public var seat2Status: Int32 = 0

  /// 3号麦位锁状态
  public var seat3Status: Int32 = 0

  /// 4号麦位锁状态
  public var seat4Status: Int32 = 0

  /// 5号麦位锁状态
  public var seat5Status: Int32 = 0

  /// 6号麦位锁状态
  public var seat6Status: Int32 = 0

  /// 7号麦位锁状态
  public var seat7Status: Int32 = 0

  /// 8号麦位锁状态
  public var seat8Status: Int32 = 0

  /// 观众席开关 0关1开
  public var seatsSwitch: Int32 = 0

  /// 麦位数量
  public var seatCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 送礼老板信息
public struct STPkBossUserVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户系统id
  public var userID: String = String()

  /// 用户账号id
  public var accountID: Int32 = 0

  /// 昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 礼物价值
  public var value: Int32 = 0

  /// pk队伍
  public var team: STPkTeam = .teamUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间基本信息通知
public struct STChannelInfoNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间信息
  public var channel: STChannelVo {
    get {return _channel ?? STChannelVo()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  public var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  public mutating func clearChannel() {self._channel = nil}

  /// 房间设置信息
  public var channelSetting: STChannelSettingVo {
    get {return _channelSetting ?? STChannelSettingVo()}
    set {_channelSetting = newValue}
  }
  /// Returns true if `channelSetting` has been explicitly set.
  public var hasChannelSetting: Bool {return self._channelSetting != nil}
  /// Clears the value of `channelSetting`. Subsequent reads from it will return its default value.
  public mutating func clearChannelSetting() {self._channelSetting = nil}

  /// 房间其他配置信息
  public var other: STChannelOtherVo {
    get {return _other ?? STChannelOtherVo()}
    set {_other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return self._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {self._other = nil}

  /// 麦位列表信息
  public var userInSeatInfo: STUserInSeatVo {
    get {return _userInSeatInfo ?? STUserInSeatVo()}
    set {_userInSeatInfo = newValue}
  }
  /// Returns true if `userInSeatInfo` has been explicitly set.
  public var hasUserInSeatInfo: Bool {return self._userInSeatInfo != nil}
  /// Clears the value of `userInSeatInfo`. Subsequent reads from it will return its default value.
  public mutating func clearUserInSeatInfo() {self._userInSeatInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channel: STChannelVo? = nil
  fileprivate var _channelSetting: STChannelSettingVo? = nil
  fileprivate var _other: STChannelOtherVo? = nil
  fileprivate var _userInSeatInfo: STUserInSeatVo? = nil
}

/// 操作用户通知
public struct STOperateUserNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 操作用户类型
  public var operateUserType: STOperateUserType = .operateUserUnknown

  /// 操作者
  public var userID: String = String()

  /// 操作者昵称
  public var nickname: String = String()

  /// 被操作者
  public var targetID: String = String()

  /// 被操作者昵称
  public var targetNickname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 移出房间通知
public struct STRemoveUserNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 移出用户类型
  public var removeUserType: STRemoveUserType = .removeUserUnknown

  /// 操作者
  public var userID: String = String()

  /// 操作者昵称
  public var nickname: String = String()

  /// 被移出者
  public var targetID: String = String()

  /// 被移出者昵称
  public var targetNickname: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 通用横幅通知
public struct STCommonBannerNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 横幅列表
  public var commonBannerList: [STCommonBannerVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 通用横幅信息
public struct STCommonBannerVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 横幅类型
  public var bannerType: STBannerType = .unknown

  /// 横幅样式
  public var bannerStyle: String = String()

  /// 横幅内容(HTML文本)
  public var bannerContent: String = String()

  /// 房间Id
  public var channelID: String = String()

  /// 用户Id （bannerType==3时有值返回表示用户不在房间内，可跳转用户主页）
  public var userID: String = String()

  /// 房间是否上锁 0未上锁 1已上锁
  public var lockedStatus: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 动作表情消息通知
public struct STExpressionNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 所在频道id
  public var channelID: String = String()

  ///目标id
  public var targetID: String = String()

  ///动作表情id
  public var expressionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间心愿礼物通知信息
public struct STWishGiftNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finish: Int32 = 0

  public var userCount: Int32 = 0

  public var wishSwitch: Int32 = 0

  public var channelID: String = String()

  public var maxLimitValue: Int32 = 0

  public var progressList: [STWishGiftProgress] = []

  public var topUser: [STGiftTopUser] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STWishGiftProgress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finishCount: Int32 = 0

  public var giftCount: Int32 = 0

  public var giftID: Int32 = 0

  public var iconURL: String = String()

  public var name: String = String()

  public var cornerIcon: String = String()

  public var effects: String = String()

  public var maxLimitValue: Int32 = 0

  public var timedCornerMark: Int32 = 0

  public var value: Int32 = 0

  public var finish: Int32 = 0

  public var wishSwitch: Int32 = 0

  public var giftType: Int32 = 0

  public var bannerContent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension STPkTeam: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEAM_UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "RED"),
  ]
}

extension STPkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ONE_TO_ONE"),
    1: .same(proto: "MANY_TO_MANY"),
    2: .same(proto: "CHANNEL_TO_CHANNEL"),
  ]
}

extension STRocketNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RocketNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "currentLevel"),
    3: .same(proto: "totalLevel"),
    4: .same(proto: "diffValue"),
    5: .same(proto: "createTimeStamp"),
    6: .same(proto: "expireTimeStamp"),
    7: .same(proto: "currentTimeStamp"),
    8: .same(proto: "channelId"),
    9: .same(proto: "userId"),
    10: .same(proto: "nickname"),
    11: .same(proto: "avatarUrl"),
    12: .same(proto: "iconUrl"),
    13: .same(proto: "animationUrl"),
    14: .same(proto: "showLabel"),
    15: .same(proto: "height"),
    16: .same(proto: "currentLevelMaxValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.currentLevel) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalLevel) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.diffValue) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTimeStamp) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.expireTimeStamp) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.currentTimeStamp) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.animationURL) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.showLabel) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 16: try { try decoder.decodeSingularInt32Field(value: &self.currentLevelMaxValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 1)
    }
    if self.currentLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.currentLevel, fieldNumber: 2)
    }
    if self.totalLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.totalLevel, fieldNumber: 3)
    }
    if self.diffValue != 0 {
      try visitor.visitSingularInt32Field(value: self.diffValue, fieldNumber: 4)
    }
    if self.createTimeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.createTimeStamp, fieldNumber: 5)
    }
    if self.expireTimeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTimeStamp, fieldNumber: 6)
    }
    if self.currentTimeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.currentTimeStamp, fieldNumber: 7)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 8)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 9)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 10)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 11)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 12)
    }
    if !self.animationURL.isEmpty {
      try visitor.visitSingularStringField(value: self.animationURL, fieldNumber: 13)
    }
    if self.showLabel != 0 {
      try visitor.visitSingularInt32Field(value: self.showLabel, fieldNumber: 14)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 15)
    }
    if self.currentLevelMaxValue != 0 {
      try visitor.visitSingularInt32Field(value: self.currentLevelMaxValue, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRocketNotification, rhs: STRocketNotification) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.currentLevel != rhs.currentLevel {return false}
    if lhs.totalLevel != rhs.totalLevel {return false}
    if lhs.diffValue != rhs.diffValue {return false}
    if lhs.createTimeStamp != rhs.createTimeStamp {return false}
    if lhs.expireTimeStamp != rhs.expireTimeStamp {return false}
    if lhs.currentTimeStamp != rhs.currentTimeStamp {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.animationURL != rhs.animationURL {return false}
    if lhs.showLabel != rhs.showLabel {return false}
    if lhs.height != rhs.height {return false}
    if lhs.currentLevelMaxValue != rhs.currentLevelMaxValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCommonNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CommonNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commonBanner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commonBanner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._commonBanner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCommonNotification, rhs: STCommonNotification) -> Bool {
    if lhs._commonBanner != rhs._commonBanner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCommonBanner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CommonBanner"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "channelId"),
    3: .same(proto: "userId"),
    4: .same(proto: "accountId"),
    5: .same(proto: "nickName"),
    6: .same(proto: "avatarUrl"),
    7: .same(proto: "bannerContent"),
    8: .same(proto: "bannerStyle"),
    9: .same(proto: "createTime"),
    10: .same(proto: "showBanner"),
    11: .same(proto: "bannerGlobal"),
    12: .same(proto: "showChat"),
    13: .same(proto: "chatGlobal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nickName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.bannerStyle) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.createTime) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.showBanner) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.bannerGlobal) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.showChat) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.chatGlobal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.source != 0 {
      try visitor.visitSingularInt32Field(value: self.source, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 4)
    }
    if !self.nickName.isEmpty {
      try visitor.visitSingularStringField(value: self.nickName, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 7)
    }
    if !self.bannerStyle.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerStyle, fieldNumber: 8)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 9)
    }
    if self.showBanner != 0 {
      try visitor.visitSingularInt32Field(value: self.showBanner, fieldNumber: 10)
    }
    if self.bannerGlobal != 0 {
      try visitor.visitSingularInt32Field(value: self.bannerGlobal, fieldNumber: 11)
    }
    if self.showChat != 0 {
      try visitor.visitSingularInt32Field(value: self.showChat, fieldNumber: 12)
    }
    if self.chatGlobal != 0 {
      try visitor.visitSingularInt32Field(value: self.chatGlobal, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCommonBanner, rhs: STCommonBanner) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickName != rhs.nickName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.bannerStyle != rhs.bannerStyle {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.showBanner != rhs.showBanner {return false}
    if lhs.bannerGlobal != rhs.bannerGlobal {return false}
    if lhs.showChat != rhs.showChat {return false}
    if lhs.chatGlobal != rhs.chatGlobal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelWarningBanner"),
    2: .same(proto: "channelGameNotice"),
    3: .same(proto: "seatLayoutNotification"),
    4: .same(proto: "askPkNotification"),
    5: .same(proto: "startPkNotification"),
    6: .same(proto: "refusePkNotification"),
    7: .same(proto: "refreshPkNotification"),
    8: .same(proto: "finishPkNotification"),
    9: .same(proto: "channelInfoNotification"),
    10: .same(proto: "operateUserNotification"),
    11: .same(proto: "removeUserNotification"),
    12: .same(proto: "commonBannerNotification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: STChannelWarningBanner?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .channelWarningBanner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .channelWarningBanner(v)
        }
      }()
      case 2: try {
        var v: STChannelGameNotice?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .channelGameNotice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .channelGameNotice(v)
        }
      }()
      case 3: try {
        var v: STSeatLayoutNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .seatLayoutNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .seatLayoutNotification(v)
        }
      }()
      case 4: try {
        var v: STAskPkNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .askPkNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .askPkNotification(v)
        }
      }()
      case 5: try {
        var v: STStartPkNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .startPkNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .startPkNotification(v)
        }
      }()
      case 6: try {
        var v: STRefusePkNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .refusePkNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .refusePkNotification(v)
        }
      }()
      case 7: try {
        var v: STRefreshPkNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .refreshPkNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .refreshPkNotification(v)
        }
      }()
      case 8: try {
        var v: STFinishPkNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .finishPkNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .finishPkNotification(v)
        }
      }()
      case 9: try {
        var v: STChannelInfoNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .channelInfoNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .channelInfoNotification(v)
        }
      }()
      case 10: try {
        var v: STOperateUserNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .operateUserNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .operateUserNotification(v)
        }
      }()
      case 11: try {
        var v: STRemoveUserNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .removeUserNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .removeUserNotification(v)
        }
      }()
      case 12: try {
        var v: STCommonBannerNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .commonBannerNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .commonBannerNotification(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.notification {
    case .channelWarningBanner?: try {
      guard case .channelWarningBanner(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .channelGameNotice?: try {
      guard case .channelGameNotice(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .seatLayoutNotification?: try {
      guard case .seatLayoutNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .askPkNotification?: try {
      guard case .askPkNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .startPkNotification?: try {
      guard case .startPkNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .refusePkNotification?: try {
      guard case .refusePkNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .refreshPkNotification?: try {
      guard case .refreshPkNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .finishPkNotification?: try {
      guard case .finishPkNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .channelInfoNotification?: try {
      guard case .channelInfoNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .operateUserNotification?: try {
      guard case .operateUserNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .removeUserNotification?: try {
      guard case .removeUserNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .commonBannerNotification?: try {
      guard case .commonBannerNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelResponse, rhs: STChannelResponse) -> Bool {
    if lhs.notification != rhs.notification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFullScreenEffectLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FullScreenEffectLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "srcTag"),
    2: .same(proto: "srcType"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.srcTag) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.srcType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.srcTag.isEmpty {
      try visitor.visitSingularStringField(value: self.srcTag, fieldNumber: 1)
    }
    if !self.srcType.isEmpty {
      try visitor.visitSingularStringField(value: self.srcType, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFullScreenEffectLocation, rhs: STFullScreenEffectLocation) -> Bool {
    if lhs.srcTag != rhs.srcTag {return false}
    if lhs.srcType != rhs.srcType {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFullScreenEffect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FullScreenEffect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "effectsUrl"),
    3: .same(proto: "bannerUrl"),
    4: .same(proto: "locationInfo"),
    5: .same(proto: "linkType"),
    6: .same(proto: "linkValue"),
    7: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.effectsURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bannerURL) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.locationInfo) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.linkType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.linkValue) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.effectsURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectsURL, fieldNumber: 2)
    }
    if !self.bannerURL.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerURL, fieldNumber: 3)
    }
    if !self.locationInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locationInfo, fieldNumber: 4)
    }
    if self.linkType != 0 {
      try visitor.visitSingularInt32Field(value: self.linkType, fieldNumber: 5)
    }
    if !self.linkValue.isEmpty {
      try visitor.visitSingularStringField(value: self.linkValue, fieldNumber: 6)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFullScreenEffect, rhs: STFullScreenEffect) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.effectsURL != rhs.effectsURL {return false}
    if lhs.bannerURL != rhs.bannerURL {return false}
    if lhs.locationInfo != rhs.locationInfo {return false}
    if lhs.linkType != rhs.linkType {return false}
    if lhs.linkValue != rhs.linkValue {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelWarningBanner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelWarningBanner"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "bannerContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelWarningBanner, rhs: STChannelWarningBanner) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelGameNotice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelGameNotice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "duration"),
    3: .same(proto: "lotteryType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.lotteryType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 2)
    }
    if self.lotteryType != 0 {
      try visitor.visitSingularInt32Field(value: self.lotteryType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelGameNotice, rhs: STChannelGameNotice) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.lotteryType != rhs.lotteryType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSeatLayoutNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SeatLayoutNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seatLayout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.seatLayout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seatLayout != 0 {
      try visitor.visitSingularInt32Field(value: self.seatLayout, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSeatLayoutNotification, rhs: STSeatLayoutNotification) -> Bool {
    if lhs.seatLayout != rhs.seatLayout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STAskPkNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AskPkNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetChannelId"),
    3: .same(proto: "duration"),
    4: .same(proto: "topic"),
    5: .same(proto: "channelName"),
    6: .same(proto: "avatarUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetChannelID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetChannelID, fieldNumber: 2)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 3)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 4)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STAskPkNotification, rhs: STAskPkNotification) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetChannelID != rhs.targetChannelID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STStartPkNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "StartPkNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkGame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pkGame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pkGame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STStartPkNotification, rhs: STStartPkNotification) -> Bool {
    if lhs._pkGame != rhs._pkGame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRefusePkNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RefusePkNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRefusePkNotification, rhs: STRefusePkNotification) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRefreshPkNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RefreshPkNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkGame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pkGame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pkGame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRefreshPkNotification, rhs: STRefreshPkNotification) -> Bool {
    if lhs._pkGame != rhs._pkGame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFinishPkNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FinishPkNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkGame"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pkGame) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pkGame {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFinishPkNotification, rhs: STFinishPkNotification) -> Bool {
    if lhs._pkGame != rhs._pkGame {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STPkGame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PkGame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "pkRoundId"),
    3: .same(proto: "topic"),
    4: .same(proto: "type"),
    5: .same(proto: "duration"),
    6: .same(proto: "blueTeamScore"),
    7: .same(proto: "redTeamScore"),
    8: .same(proto: "createTime"),
    9: .same(proto: "endTime"),
    10: .same(proto: "participants"),
    11: .same(proto: "blueParticipants"),
    12: .same(proto: "pkBossUsers"),
    13: .same(proto: "bluePkBossUsers"),
    14: .same(proto: "redChannelInfo"),
    15: .same(proto: "blueChannelInfo"),
    16: .same(proto: "status"),
    17: .same(proto: "systemTime"),
    18: .same(proto: "redUserInSeats"),
    19: .same(proto: "blueUserInSeats"),
  ]

  fileprivate class _StorageClass {
    var _channelID: String = String()
    var _pkRoundID: String = String()
    var _topic: String = String()
    var _type: STPkType = .oneToOne
    var _duration: Int32 = 0
    var _blueTeamScore: Int32 = 0
    var _redTeamScore: Int32 = 0
    var _createTime: Int64 = 0
    var _endTime: Int64 = 0
    var _participants: [STParticipantVo] = []
    var _blueParticipants: [STParticipantVo] = []
    var _pkBossUsers: [STPkBossUserVo] = []
    var _bluePkBossUsers: [STPkBossUserVo] = []
    var _redChannelInfo: STPkChannelInfoVo? = nil
    var _blueChannelInfo: STPkChannelInfoVo? = nil
    var _status: Int32 = 0
    var _systemTime: Int64 = 0
    var _redUserInSeats: [STUserInSeats] = []
    var _blueUserInSeats: [STUserInSeats] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _channelID = source._channelID
      _pkRoundID = source._pkRoundID
      _topic = source._topic
      _type = source._type
      _duration = source._duration
      _blueTeamScore = source._blueTeamScore
      _redTeamScore = source._redTeamScore
      _createTime = source._createTime
      _endTime = source._endTime
      _participants = source._participants
      _blueParticipants = source._blueParticipants
      _pkBossUsers = source._pkBossUsers
      _bluePkBossUsers = source._bluePkBossUsers
      _redChannelInfo = source._redChannelInfo
      _blueChannelInfo = source._blueChannelInfo
      _status = source._status
      _systemTime = source._systemTime
      _redUserInSeats = source._redUserInSeats
      _blueUserInSeats = source._blueUserInSeats
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._channelID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._pkRoundID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._topic) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._blueTeamScore) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._redTeamScore) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._createTime) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._endTime) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._participants) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._blueParticipants) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._pkBossUsers) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._bluePkBossUsers) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._redChannelInfo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._blueChannelInfo) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._systemTime) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._redUserInSeats) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._blueUserInSeats) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._channelID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelID, fieldNumber: 1)
      }
      if !_storage._pkRoundID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pkRoundID, fieldNumber: 2)
      }
      if !_storage._topic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._topic, fieldNumber: 3)
      }
      if _storage._type != .oneToOne {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 5)
      }
      if _storage._blueTeamScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blueTeamScore, fieldNumber: 6)
      }
      if _storage._redTeamScore != 0 {
        try visitor.visitSingularInt32Field(value: _storage._redTeamScore, fieldNumber: 7)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 8)
      }
      if _storage._endTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._endTime, fieldNumber: 9)
      }
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._participants, fieldNumber: 10)
      }
      if !_storage._blueParticipants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blueParticipants, fieldNumber: 11)
      }
      if !_storage._pkBossUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pkBossUsers, fieldNumber: 12)
      }
      if !_storage._bluePkBossUsers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bluePkBossUsers, fieldNumber: 13)
      }
      try { if let v = _storage._redChannelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._blueChannelInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 16)
      }
      if _storage._systemTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._systemTime, fieldNumber: 17)
      }
      if !_storage._redUserInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._redUserInSeats, fieldNumber: 18)
      }
      if !_storage._blueUserInSeats.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._blueUserInSeats, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STPkGame, rhs: STPkGame) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._channelID != rhs_storage._channelID {return false}
        if _storage._pkRoundID != rhs_storage._pkRoundID {return false}
        if _storage._topic != rhs_storage._topic {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._blueTeamScore != rhs_storage._blueTeamScore {return false}
        if _storage._redTeamScore != rhs_storage._redTeamScore {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._participants != rhs_storage._participants {return false}
        if _storage._blueParticipants != rhs_storage._blueParticipants {return false}
        if _storage._pkBossUsers != rhs_storage._pkBossUsers {return false}
        if _storage._bluePkBossUsers != rhs_storage._bluePkBossUsers {return false}
        if _storage._redChannelInfo != rhs_storage._redChannelInfo {return false}
        if _storage._blueChannelInfo != rhs_storage._blueChannelInfo {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._systemTime != rhs_storage._systemTime {return false}
        if _storage._redUserInSeats != rhs_storage._redUserInSeats {return false}
        if _storage._blueUserInSeats != rhs_storage._blueUserInSeats {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelPkVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelPkVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelNo"),
    2: .same(proto: "channelId"),
    3: .same(proto: "channelName"),
    4: .same(proto: "channelType"),
    5: .same(proto: "ownerId"),
    6: .same(proto: "avatarUrl"),
    7: .same(proto: "lovenum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.channelNo) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelNo != 0 {
      try visitor.visitSingularInt32Field(value: self.channelNo, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if self.channelType != .unkown {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 4)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelPkVo, rhs: STChannelPkVo) -> Bool {
    if lhs.channelNo != rhs.channelNo {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STParticipantVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ParticipantVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pkChannelId"),
    2: .same(proto: "pkId"),
    3: .same(proto: "team"),
    4: .same(proto: "userId"),
    5: .same(proto: "accountId"),
    6: .same(proto: "nickname"),
    7: .same(proto: "avatarUrl"),
    8: .same(proto: "lovenum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pkChannelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pkID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.team) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.lovenum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pkChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkChannelID, fieldNumber: 1)
    }
    if !self.pkID.isEmpty {
      try visitor.visitSingularStringField(value: self.pkID, fieldNumber: 2)
    }
    if self.team != .teamUnknown {
      try visitor.visitSingularEnumField(value: self.team, fieldNumber: 3)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 4)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 5)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 6)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 7)
    }
    if self.lovenum != 0 {
      try visitor.visitSingularInt32Field(value: self.lovenum, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STParticipantVo, rhs: STParticipantVo) -> Bool {
    if lhs.pkChannelID != rhs.pkChannelID {return false}
    if lhs.pkID != rhs.pkID {return false}
    if lhs.team != rhs.team {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.lovenum != rhs.lovenum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STPkChannelInfoVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PkChannelInfoVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "channelNo"),
    3: .same(proto: "channelName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "ownerId"),
    6: .same(proto: "seat0Status"),
    7: .same(proto: "seat1Status"),
    8: .same(proto: "seat2Status"),
    9: .same(proto: "seat3Status"),
    10: .same(proto: "seat4Status"),
    11: .same(proto: "seat5Status"),
    12: .same(proto: "seat6Status"),
    13: .same(proto: "seat7Status"),
    14: .same(proto: "seat8Status"),
    15: .same(proto: "seatsSwitch"),
    16: .same(proto: "seatCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channelNo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.seat0Status) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.seat1Status) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.seat2Status) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.seat3Status) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.seat4Status) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.seat5Status) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.seat6Status) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.seat7Status) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.seat8Status) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.seatsSwitch) }()
      case 16: try { try decoder.decodeSingularInt32Field(value: &self.seatCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.channelNo != 0 {
      try visitor.visitSingularInt32Field(value: self.channelNo, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 5)
    }
    if self.seat0Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat0Status, fieldNumber: 6)
    }
    if self.seat1Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat1Status, fieldNumber: 7)
    }
    if self.seat2Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat2Status, fieldNumber: 8)
    }
    if self.seat3Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat3Status, fieldNumber: 9)
    }
    if self.seat4Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat4Status, fieldNumber: 10)
    }
    if self.seat5Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat5Status, fieldNumber: 11)
    }
    if self.seat6Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat6Status, fieldNumber: 12)
    }
    if self.seat7Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat7Status, fieldNumber: 13)
    }
    if self.seat8Status != 0 {
      try visitor.visitSingularInt32Field(value: self.seat8Status, fieldNumber: 14)
    }
    if self.seatsSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.seatsSwitch, fieldNumber: 15)
    }
    if self.seatCount != 0 {
      try visitor.visitSingularInt32Field(value: self.seatCount, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STPkChannelInfoVo, rhs: STPkChannelInfoVo) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelNo != rhs.channelNo {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.seat0Status != rhs.seat0Status {return false}
    if lhs.seat1Status != rhs.seat1Status {return false}
    if lhs.seat2Status != rhs.seat2Status {return false}
    if lhs.seat3Status != rhs.seat3Status {return false}
    if lhs.seat4Status != rhs.seat4Status {return false}
    if lhs.seat5Status != rhs.seat5Status {return false}
    if lhs.seat6Status != rhs.seat6Status {return false}
    if lhs.seat7Status != rhs.seat7Status {return false}
    if lhs.seat8Status != rhs.seat8Status {return false}
    if lhs.seatsSwitch != rhs.seatsSwitch {return false}
    if lhs.seatCount != rhs.seatCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STPkBossUserVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "PkBossUserVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "accountId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "value"),
    6: .same(proto: "team"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.team) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 4)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 5)
    }
    if self.team != .teamUnknown {
      try visitor.visitSingularEnumField(value: self.team, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STPkBossUserVo, rhs: STPkBossUserVo) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.value != rhs.value {return false}
    if lhs.team != rhs.team {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChannelInfoNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChannelInfoNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channel"),
    2: .same(proto: "channelSetting"),
    3: .same(proto: "other"),
    4: .same(proto: "userInSeatInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channelSetting) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._other) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userInSeatInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._channelSetting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._other {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._userInSeatInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChannelInfoNotification, rhs: STChannelInfoNotification) -> Bool {
    if lhs._channel != rhs._channel {return false}
    if lhs._channelSetting != rhs._channelSetting {return false}
    if lhs._other != rhs._other {return false}
    if lhs._userInSeatInfo != rhs._userInSeatInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STOperateUserNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "OperateUserNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operateUserType"),
    2: .same(proto: "userId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "targetId"),
    5: .same(proto: "targetNickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operateUserType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetNickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.operateUserType != .operateUserUnknown {
      try visitor.visitSingularEnumField(value: self.operateUserType, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 4)
    }
    if !self.targetNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNickname, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STOperateUserNotification, rhs: STOperateUserNotification) -> Bool {
    if lhs.operateUserType != rhs.operateUserType {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.targetNickname != rhs.targetNickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRemoveUserNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RemoveUserNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removeUserType"),
    2: .same(proto: "userId"),
    3: .same(proto: "nickname"),
    4: .same(proto: "targetId"),
    5: .same(proto: "targetNickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.removeUserType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetNickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.removeUserType != .removeUserUnknown {
      try visitor.visitSingularEnumField(value: self.removeUserType, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 3)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 4)
    }
    if !self.targetNickname.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNickname, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRemoveUserNotification, rhs: STRemoveUserNotification) -> Bool {
    if lhs.removeUserType != rhs.removeUserType {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.targetNickname != rhs.targetNickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCommonBannerNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CommonBannerNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commonBannerList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.commonBannerList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commonBannerList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commonBannerList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCommonBannerNotification, rhs: STCommonBannerNotification) -> Bool {
    if lhs.commonBannerList != rhs.commonBannerList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STCommonBannerVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CommonBannerVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bannerType"),
    2: .same(proto: "bannerStyle"),
    3: .same(proto: "bannerContent"),
    4: .same(proto: "channelId"),
    5: .same(proto: "userId"),
    6: .same(proto: "lockedStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.bannerType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.bannerStyle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bannerType != .unknown {
      try visitor.visitSingularEnumField(value: self.bannerType, fieldNumber: 1)
    }
    if !self.bannerStyle.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerStyle, fieldNumber: 2)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 3)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 4)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 5)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STCommonBannerVo, rhs: STCommonBannerVo) -> Bool {
    if lhs.bannerType != rhs.bannerType {return false}
    if lhs.bannerStyle != rhs.bannerStyle {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STExpressionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ExpressionNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "targetId"),
    3: .same(proto: "expressionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.expressionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if !self.expressionID.isEmpty {
      try visitor.visitSingularStringField(value: self.expressionID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STExpressionNotification, rhs: STExpressionNotification) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.expressionID != rhs.expressionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STWishGiftNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "WishGiftNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finish"),
    2: .same(proto: "userCount"),
    3: .same(proto: "wishSwitch"),
    4: .same(proto: "channelId"),
    5: .same(proto: "maxLimitValue"),
    100: .same(proto: "progressList"),
    101: .same(proto: "topUser"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.userCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.wishSwitch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxLimitValue) }()
      case 100: try { try decoder.decodeRepeatedMessageField(value: &self.progressList) }()
      case 101: try { try decoder.decodeRepeatedMessageField(value: &self.topUser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 1)
    }
    if self.userCount != 0 {
      try visitor.visitSingularInt32Field(value: self.userCount, fieldNumber: 2)
    }
    if self.wishSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.wishSwitch, fieldNumber: 3)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 4)
    }
    if self.maxLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLimitValue, fieldNumber: 5)
    }
    if !self.progressList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.progressList, fieldNumber: 100)
    }
    if !self.topUser.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topUser, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STWishGiftNotification, rhs: STWishGiftNotification) -> Bool {
    if lhs.finish != rhs.finish {return false}
    if lhs.userCount != rhs.userCount {return false}
    if lhs.wishSwitch != rhs.wishSwitch {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.maxLimitValue != rhs.maxLimitValue {return false}
    if lhs.progressList != rhs.progressList {return false}
    if lhs.topUser != rhs.topUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STWishGiftProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "WishGiftProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "finishCount"),
    2: .same(proto: "giftCount"),
    3: .same(proto: "giftId"),
    4: .same(proto: "iconUrl"),
    5: .same(proto: "name"),
    6: .same(proto: "cornerIcon"),
    7: .same(proto: "effects"),
    8: .same(proto: "maxLimitValue"),
    9: .same(proto: "timedCornerMark"),
    10: .same(proto: "value"),
    11: .same(proto: "finish"),
    12: .same(proto: "wishSwitch"),
    13: .same(proto: "giftType"),
    14: .same(proto: "bannerContent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finishCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.giftCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.cornerIcon) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.effects) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.maxLimitValue) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.timedCornerMark) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.value) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.finish) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.wishSwitch) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.giftType) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.bannerContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finishCount != 0 {
      try visitor.visitSingularInt32Field(value: self.finishCount, fieldNumber: 1)
    }
    if self.giftCount != 0 {
      try visitor.visitSingularInt32Field(value: self.giftCount, fieldNumber: 2)
    }
    if self.giftID != 0 {
      try visitor.visitSingularInt32Field(value: self.giftID, fieldNumber: 3)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.cornerIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.cornerIcon, fieldNumber: 6)
    }
    if !self.effects.isEmpty {
      try visitor.visitSingularStringField(value: self.effects, fieldNumber: 7)
    }
    if self.maxLimitValue != 0 {
      try visitor.visitSingularInt32Field(value: self.maxLimitValue, fieldNumber: 8)
    }
    if self.timedCornerMark != 0 {
      try visitor.visitSingularInt32Field(value: self.timedCornerMark, fieldNumber: 9)
    }
    if self.value != 0 {
      try visitor.visitSingularInt32Field(value: self.value, fieldNumber: 10)
    }
    if self.finish != 0 {
      try visitor.visitSingularInt32Field(value: self.finish, fieldNumber: 11)
    }
    if self.wishSwitch != 0 {
      try visitor.visitSingularInt32Field(value: self.wishSwitch, fieldNumber: 12)
    }
    if self.giftType != 0 {
      try visitor.visitSingularInt32Field(value: self.giftType, fieldNumber: 13)
    }
    if !self.bannerContent.isEmpty {
      try visitor.visitSingularStringField(value: self.bannerContent, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STWishGiftProgress, rhs: STWishGiftProgress) -> Bool {
    if lhs.finishCount != rhs.finishCount {return false}
    if lhs.giftCount != rhs.giftCount {return false}
    if lhs.giftID != rhs.giftID {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.name != rhs.name {return false}
    if lhs.cornerIcon != rhs.cornerIcon {return false}
    if lhs.effects != rhs.effects {return false}
    if lhs.maxLimitValue != rhs.maxLimitValue {return false}
    if lhs.timedCornerMark != rhs.timedCornerMark {return false}
    if lhs.value != rhs.value {return false}
    if lhs.finish != rhs.finish {return false}
    if lhs.wishSwitch != rhs.wishSwitch {return false}
    if lhs.giftType != rhs.giftType {return false}
    if lhs.bannerContent != rhs.bannerContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
