// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum STChatSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0

  ///关注用户
  case followUser // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .followUser
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .followUser: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [STChatSource] = [
    .none,
    .followUser,
  ]

}

public struct STMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: STMessageRequest.OneOf_Body? = nil

  /// 发送私聊
  public var sendChatMessage: STSendChatMessageReq {
    get {
      if case .sendChatMessage(let v)? = body {return v}
      return STSendChatMessageReq()
    }
    set {body = .sendChatMessage(newValue)}
  }

  /// 收到私聊后，app发送回执
  public var sendChatMessageReceipt: STSendMessageReceiptReq {
    get {
      if case .sendChatMessageReceipt(let v)? = body {return v}
      return STSendMessageReceiptReq()
    }
    set {body = .sendChatMessageReceipt(newValue)}
  }

  /// 撤回消息
  public var retractChatMessage: STRetractChatMessageReq {
    get {
      if case .retractChatMessage(let v)? = body {return v}
      return STRetractChatMessageReq()
    }
    set {body = .retractChatMessage(newValue)}
  }

  ///删除消息
  public var deleteChatMessage: STDeleteChatMessageReq {
    get {
      if case .deleteChatMessage(let v)? = body {return v}
      return STDeleteChatMessageReq()
    }
    set {body = .deleteChatMessage(newValue)}
  }

  ///私信聊天相关设置
  public var chatMessageConfig: STChatMessageConfigReq {
    get {
      if case .chatMessageConfig(let v)? = body {return v}
      return STChatMessageConfigReq()
    }
    set {body = .chatMessageConfig(newValue)}
  }

  ///加载聊天记录&离线消息
  public var loadChatRecord: STLoadChatRecordReq {
    get {
      if case .loadChatRecord(let v)? = body {return v}
      return STLoadChatRecordReq()
    }
    set {body = .loadChatRecord(newValue)}
  }

  ///获取消息状态
  public var loadChatStatus: STLoadChatStatusReq {
    get {
      if case .loadChatStatus(let v)? = body {return v}
      return STLoadChatStatusReq()
    }
    set {body = .loadChatStatus(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 发送私聊
    case sendChatMessage(STSendChatMessageReq)
    /// 收到私聊后，app发送回执
    case sendChatMessageReceipt(STSendMessageReceiptReq)
    /// 撤回消息
    case retractChatMessage(STRetractChatMessageReq)
    ///删除消息
    case deleteChatMessage(STDeleteChatMessageReq)
    ///私信聊天相关设置
    case chatMessageConfig(STChatMessageConfigReq)
    ///加载聊天记录&离线消息
    case loadChatRecord(STLoadChatRecordReq)
    ///获取消息状态
    case loadChatStatus(STLoadChatStatusReq)

  }

  public init() {}
}

public struct STMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: STMessageResponse.OneOf_Body? = nil

  /// 发送私聊
  public var sendChatMessage: STSendChatMessageRes {
    get {
      if case .sendChatMessage(let v)? = body {return v}
      return STSendChatMessageRes()
    }
    set {body = .sendChatMessage(newValue)}
  }

  /// 收到私聊后，app发送回执
  public var sendChatMessageReceipt: STSendMessageReceiptRes {
    get {
      if case .sendChatMessageReceipt(let v)? = body {return v}
      return STSendMessageReceiptRes()
    }
    set {body = .sendChatMessageReceipt(newValue)}
  }

  /// 撤回消息
  public var retractChatMessage: STRetractChatMessageRes {
    get {
      if case .retractChatMessage(let v)? = body {return v}
      return STRetractChatMessageRes()
    }
    set {body = .retractChatMessage(newValue)}
  }

  ///删除消息
  public var deleteChatMessage: STDeleteChatMessageRes {
    get {
      if case .deleteChatMessage(let v)? = body {return v}
      return STDeleteChatMessageRes()
    }
    set {body = .deleteChatMessage(newValue)}
  }

  ///私信聊天相关设置
  public var chatMessageConfig: STChatMessageConfigRes {
    get {
      if case .chatMessageConfig(let v)? = body {return v}
      return STChatMessageConfigRes()
    }
    set {body = .chatMessageConfig(newValue)}
  }

  ///加载聊天记录&离线消息
  public var loadChatRecord: STLoadChatRecordRes {
    get {
      if case .loadChatRecord(let v)? = body {return v}
      return STLoadChatRecordRes()
    }
    set {body = .loadChatRecord(newValue)}
  }

  ///获取消息状态
  public var loadChatStatus: STLoadChatStatusRes {
    get {
      if case .loadChatStatus(let v)? = body {return v}
      return STLoadChatStatusRes()
    }
    set {body = .loadChatStatus(newValue)}
  }

  public var notification: STMessageResponse.OneOf_Notification? = nil

  /// 收到消息
  public var messageNotification: STMessageNotification {
    get {
      if case .messageNotification(let v)? = notification {return v}
      return STMessageNotification()
    }
    set {notification = .messageNotification(newValue)}
  }

  ///已读消息通知
  public var readMessageNotification: STReadMessageNotification {
    get {
      if case .readMessageNotification(let v)? = notification {return v}
      return STReadMessageNotification()
    }
    set {notification = .readMessageNotification(newValue)}
  }

  ///审核消息回调通知
  public var chatMessageCallback: STAuditChatMessageCallback {
    get {
      if case .chatMessageCallback(let v)? = notification {return v}
      return STAuditChatMessageCallback()
    }
    set {notification = .chatMessageCallback(newValue)}
  }

  ///用户关注消息通知
  public var userFollow: STUserFollowNotification {
    get {
      if case .userFollow(let v)? = notification {return v}
      return STUserFollowNotification()
    }
    set {notification = .userFollow(newValue)}
  }

  /// 消息推送通知
  public var messagePush: STMessagePush {
    get {
      if case .messagePush(let v)? = notification {return v}
      return STMessagePush()
    }
    set {notification = .messagePush(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 发送私聊
    case sendChatMessage(STSendChatMessageRes)
    /// 收到私聊后，app发送回执
    case sendChatMessageReceipt(STSendMessageReceiptRes)
    /// 撤回消息
    case retractChatMessage(STRetractChatMessageRes)
    ///删除消息
    case deleteChatMessage(STDeleteChatMessageRes)
    ///私信聊天相关设置
    case chatMessageConfig(STChatMessageConfigRes)
    ///加载聊天记录&离线消息
    case loadChatRecord(STLoadChatRecordRes)
    ///获取消息状态
    case loadChatStatus(STLoadChatStatusRes)

  }

  public enum OneOf_Notification: Equatable, Sendable {
    /// 收到消息
    case messageNotification(STMessageNotification)
    ///已读消息通知
    case readMessageNotification(STReadMessageNotification)
    ///审核消息回调通知
    case chatMessageCallback(STAuditChatMessageCallback)
    ///用户关注消息通知
    case userFollow(STUserFollowNotification)
    /// 消息推送通知
    case messagePush(STMessagePush)

  }

  public init() {}
}

public struct STLoadChatStatusReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STLoadChatStatusRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageStatus: STMessageStatus {
    get {return _messageStatus ?? STMessageStatus()}
    set {_messageStatus = newValue}
  }
  /// Returns true if `messageStatus` has been explicitly set.
  public var hasMessageStatus: Bool {return self._messageStatus != nil}
  /// Clears the value of `messageStatus`. Subsequent reads from it will return its default value.
  public mutating func clearMessageStatus() {self._messageStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageStatus: STMessageStatus? = nil
}

public struct STMessageStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息
  public var messages: [STMessageItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STLoadChatRecordReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatRecordType: STChatRecordType = .notset

  public var page: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STLoadChatRecordRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 批次ID，对应一次推送，增加
  public var batchID: Int64 = 0

  /// 消息补丁
  public var sessionPatches: [STSessionPatch] = []

  /// 有没有更多
  public var hasMore_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STChatMessageConfigReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 对方userId
  public var targetID: String = String()

  public var content: STChatMessageConfigReq.OneOf_Content? = nil

  ///备注名
  public var remarks: String {
    get {
      if case .remarks(let v)? = content {return v}
      return String()
    }
    set {content = .remarks(newValue)}
  }

  ///true-开启 false-关闭
  public var disturb: Bool {
    get {
      if case .disturb(let v)? = content {return v}
      return false
    }
    set {content = .disturb(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable, Sendable {
    ///备注名
    case remarks(String)
    ///true-开启 false-关闭
    case disturb(Bool)

  }

  public init() {}
}

public struct STChatMessageConfigRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STDeleteChatMessageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 对方userId
  public var targetID: String = String()

  /// 消息Id
  public var messageID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STDeleteChatMessageRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STSendChatMessageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 对方userId
  public var targetID: String = String()

  /// 消息内容
  public var message: STChatMessage {
    get {return _message ?? STChatMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  ///来源（后端用到）
  public var source: STChatSource = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _message: STChatMessage? = nil
}

public struct STSendChatMessageRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///接收者
  public var receiver: STUserInCommon {
    get {return _storage._receiver ?? STUserInCommon()}
    set {_uniqueStorage()._receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  public var hasReceiver: Bool {return _storage._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  public mutating func clearReceiver() {_uniqueStorage()._receiver = nil}

  ///消息内容
  public var message: STMessageItem {
    get {return _storage._message ?? STMessageItem()}
    set {_uniqueStorage()._message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return _storage._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {_uniqueStorage()._message = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct STChatMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STChatMessage.OneOf_Type? = nil

  /// 文本
  public var text: String {
    get {
      if case .text(let v)? = type {return v}
      return String()
    }
    set {type = .text(newValue)}
  }

  /// 录音
  public var audio: STAudioAndVideoMessage {
    get {
      if case .audio(let v)? = type {return v}
      return STAudioAndVideoMessage()
    }
    set {type = .audio(newValue)}
  }

  /// 视频
  public var video: STAudioAndVideoMessage {
    get {
      if case .video(let v)? = type {return v}
      return STAudioAndVideoMessage()
    }
    set {type = .video(newValue)}
  }

  /// 图片
  public var image: STImageMessage {
    get {
      if case .image(let v)? = type {return v}
      return STImageMessage()
    }
    set {type = .image(newValue)}
  }

  ///系统警告，提示消息（客户端本地插入）
  public var systemWarning: String {
    get {
      if case .systemWarning(let v)? = type {return v}
      return String()
    }
    set {type = .systemWarning(newValue)}
  }

  ///撤回消息
  public var retract: STRetractChatMessage {
    get {
      if case .retract(let v)? = type {return v}
      return STRetractChatMessage()
    }
    set {type = .retract(newValue)}
  }

  ///互动通知
  public var invite: STInterrelationMessage {
    get {
      if case .invite(let v)? = type {return v}
      return STInterrelationMessage()
    }
    set {type = .invite(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    /// 文本
    case text(String)
    /// 录音
    case audio(STAudioAndVideoMessage)
    /// 视频
    case video(STAudioAndVideoMessage)
    /// 图片
    case image(STImageMessage)
    ///系统警告，提示消息（客户端本地插入）
    case systemWarning(String)
    ///撤回消息
    case retract(STRetractChatMessage)
    ///互动通知
    case invite(STInterrelationMessage)

  }

  public init() {}
}

public struct STInterrelationMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STAudioAndVideoMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///播放地址
  public var url: String = String()

  ///时长
  public var duration: Int32 = 0

  ///客户端用
  public var filePath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STImageMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int32 = 0

  public var height: Int32 = 0

  public var imageURL: String = String()

  ///客户端用
  public var filePath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STMessageItem: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息ID
  public var messageID: Int64 = 0

  /// 发送者的userId
  public var senderID: String = String()

  /// 接收者的userId
  public var receiverID: String = String()

  /// 警告。如：不要转账！
  public var warning: String = String()

  public var timestamp: Int64 = 0

  public var state: STMessageState = .notset

  /// 提示语。如：消息已发出但被对方拒收
  public var tips: String = String()

  public var type: STMessageItem.OneOf_Type? = nil

  /// 系统消息（废弃）
  public var systemMessage: STSystemMessage {
    get {
      if case .systemMessage(let v)? = type {return v}
      return STSystemMessage()
    }
    set {type = .systemMessage(newValue)}
  }

  /// 互动消息
  public var interactMessage: STInteractMessage {
    get {
      if case .interactMessage(let v)? = type {return v}
      return STInteractMessage()
    }
    set {type = .interactMessage(newValue)}
  }

  /// 广告消息
  public var advertisingMessage: STAdvertisingMessage {
    get {
      if case .advertisingMessage(let v)? = type {return v}
      return STAdvertisingMessage()
    }
    set {type = .advertisingMessage(newValue)}
  }

  /// 私聊消息
  public var chatMessage: STChatMessage {
    get {
      if case .chatMessage(let v)? = type {return v}
      return STChatMessage()
    }
    set {type = .chatMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    /// 系统消息（废弃）
    case systemMessage(STSystemMessage)
    /// 互动消息
    case interactMessage(STInteractMessage)
    /// 广告消息
    case advertisingMessage(STAdvertisingMessage)
    /// 私聊消息
    case chatMessage(STChatMessage)

  }

  public init() {}
}

/// 消息推送通知
public struct STMessagePush: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STMessagePush.OneOf_Type? = nil

  /// 系统消息提醒
  public var systemPrompt: STSystemPrompt {
    get {
      if case .systemPrompt(let v)? = type {return v}
      return STSystemPrompt()
    }
    set {type = .systemPrompt(newValue)}
  }

  /// 互动消息提醒
  public var interactPrompt: STInteractPrompt {
    get {
      if case .interactPrompt(let v)? = type {return v}
      return STInteractPrompt()
    }
    set {type = .interactPrompt(newValue)}
  }

  /// 家族消息提醒
  public var familyPrompt: STFamilyPrompt {
    get {
      if case .familyPrompt(let v)? = type {return v}
      return STFamilyPrompt()
    }
    set {type = .familyPrompt(newValue)}
  }

  /// 首充奖品列表提醒
  public var firstChargePrompt: STFirstChargePrompt {
    get {
      if case .firstChargePrompt(let v)? = type {return v}
      return STFirstChargePrompt()
    }
    set {type = .firstChargePrompt(newValue)}
  }

  /// 首充奖品列表提醒
  public var followPrompt: STFollowPrompt {
    get {
      if case .followPrompt(let v)? = type {return v}
      return STFollowPrompt()
    }
    set {type = .followPrompt(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    /// 系统消息提醒
    case systemPrompt(STSystemPrompt)
    /// 互动消息提醒
    case interactPrompt(STInteractPrompt)
    /// 家族消息提醒
    case familyPrompt(STFamilyPrompt)
    /// 首充奖品列表提醒
    case firstChargePrompt(STFirstChargePrompt)
    /// 首充奖品列表提醒
    case followPrompt(STFollowPrompt)

  }

  public init() {}
}

/// 系统消息提醒
public struct STSystemPrompt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息内容
  public var msgContent: String = String()

  /// 时间戳
  public var timestamp: Int64 = 0

  /// 是否有未读消息 0否1是
  public var unread: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 互动消息提醒
public struct STInteractPrompt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 时间戳
  public var timestamp: Int64 = 0

  /// 是否有未读消息 0否1是
  public var unread: Int32 = 0

  /// 消息数量
  public var count: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 关注消息提醒
public struct STFollowPrompt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 时间戳
  public var timestamp: Int64 = 0

  /// 是否有未读消息 0否1是
  public var unread: Int32 = 0

  /// 消息数量
  public var count: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 家族消息提醒
public struct STFamilyPrompt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息内容
  public var msgContent: String = String()

  /// 时间戳
  public var timestamp: Int64 = 0

  /// 是否有未读消息 0否1是
  public var unread: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 充奖励列表消息提醒
public struct STFirstChargePrompt: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 礼包名称
  public var bagName: String = String()

  ///奖品列表
  public var prizes: [STFirstChargePrize] = []

  /// 礼包奖品总价值
  public var prizeValue: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STFirstChargePrize: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 奖品名称
  public var giftName: String = String()

  /// 奖品图标
  public var giftIcon: String = String()

  /// 奖品类型
  public var giftType: Int32 = 0

  /// 装扮类型
  public var dressupType: Int32 = 0

  /// 有效天数
  public var duration: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STSystemMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 系统消息唯一ID，当unique_id非0，本地将删除旧的同unique_id消息
  public var uniqueID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STInteractMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STInteractMessage.OneOf_Type? = nil

  /// 关注了我
  public var follow: STInteractionMessage {
    get {
      if case .follow(let v)? = type {return v}
      return STInteractionMessage()
    }
    set {type = .follow(newValue)}
  }

  ///动态评论
  public var momentComment: STInteractionMessage {
    get {
      if case .momentComment(let v)? = type {return v}
      return STInteractionMessage()
    }
    set {type = .momentComment(newValue)}
  }

  ///动态点赞
  public var applaud: STInteractionMessage {
    get {
      if case .applaud(let v)? = type {return v}
      return STInteractionMessage()
    }
    set {type = .applaud(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    /// 关注了我
    case follow(STInteractionMessage)
    ///动态评论
    case momentComment(STInteractionMessage)
    ///动态点赞
    case applaud(STInteractionMessage)

  }

  public init() {}
}

public struct STAdvertisingMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STInteractionMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STInteractionMessageType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 消息ID
  public var messageID: Int64 {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  /// 发送人
  public var sender: STUserInCommon {
    get {return _storage._sender ?? STUserInCommon()}
    set {_uniqueStorage()._sender = newValue}
  }
  /// Returns true if `sender` has been explicitly set.
  public var hasSender: Bool {return _storage._sender != nil}
  /// Clears the value of `sender`. Subsequent reads from it will return its default value.
  public mutating func clearSender() {_uniqueStorage()._sender = nil}

  /// 动态ID
  public var momentID: Int64 {
    get {return _storage._momentID}
    set {_uniqueStorage()._momentID = newValue}
  }

  /// 评论ID，可选
  public var commentID: Int64 {
    get {return _storage._commentID}
    set {_uniqueStorage()._commentID = newValue}
  }

  /// 已读
  public var read: Bool {
    get {return _storage._read}
    set {_uniqueStorage()._read = newValue}
  }

  ///评论内容
  public var content: String {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  ///目标内容(Json)
  public var targetContent: String {
    get {return _storage._targetContent}
    set {_uniqueStorage()._targetContent = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct STSendMessageReceiptReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STMessageReceiptType = .notset

  /// RECEIVED_PATCHES 时使用
  public var batchID: Int64 = 0

  /// 读消息时使用
  public var messageID: Int64 = 0

  /// 读用户消息时使用
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STSendMessageReceiptRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STMessageNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 批次ID，对应一次推送，增加
  public var batchID: Int64 = 0

  /// 消息补丁
  public var sessionPatches: [STSessionPatch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STSessionPatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: STSessionPatch.OneOf_Type? = nil

  /// 系统消息
  public var system: STNone {
    get {
      if case .system(let v)? = type {return v}
      return STNone()
    }
    set {type = .system(newValue)}
  }

  /// 互动消息
  public var interactive: STNone {
    get {
      if case .interactive(let v)? = type {return v}
      return STNone()
    }
    set {type = .interactive(newValue)}
  }

  /// 广告消息（活动中心）
  public var advertising: STNone {
    get {
      if case .advertising(let v)? = type {return v}
      return STNone()
    }
    set {type = .advertising(newValue)}
  }

  /// 普通消息，收到该消息的对方用户
  public var chat: STUserInCommon {
    get {
      if case .chat(let v)? = type {return v}
      return STUserInCommon()
    }
    set {type = .chat(newValue)}
  }

  /// 消息
  public var messages: [STMessageItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable, Sendable {
    /// 系统消息
    case system(STNone)
    /// 互动消息
    case interactive(STNone)
    /// 广告消息（活动中心）
    case advertising(STNone)
    /// 普通消息，收到该消息的对方用户
    case chat(STUserInCommon)

  }

  public init() {}
}

public struct STRetractChatMessageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 对方userId
  public var targetID: String = String()

  /// 消息Id
  public var messageID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STRetractChatMessageRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STRetractChatMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息Id
  public var messageID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STReadMessageNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 批次ID
  public var batchID: Int64 = 0

  public var readMessage: [STReadMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STReadMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 最新的消息Id
  public var messageID: Int64 = 0

  /// 用户ID
  public var targetID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STAuditChatMessageCallback: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户ID
  public var targetID: String = String()

  ///消息Id
  public var messageID: Int64 = 0

  ///状态 true-通过,false-失败
  public var status: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct STUserFollowNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 用户ID
  public var targetID: String = String()

  ///关注状态
  public var state: STFollowState = .notset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension STChatSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ChatSource_None"),
    1: .same(proto: "Follow_User"),
  ]
}

extension STMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "send_chat_message"),
    2: .standard(proto: "send_chat_message_receipt"),
    3: .standard(proto: "retract_chat_message"),
    4: .standard(proto: "delete_chat_message"),
    5: .standard(proto: "chat_message_config"),
    20: .standard(proto: "load_chat_record"),
    21: .standard(proto: "load_chat_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: STSendChatMessageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sendChatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sendChatMessage(v)
        }
      }()
      case 2: try {
        var v: STSendMessageReceiptReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sendChatMessageReceipt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sendChatMessageReceipt(v)
        }
      }()
      case 3: try {
        var v: STRetractChatMessageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .retractChatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .retractChatMessage(v)
        }
      }()
      case 4: try {
        var v: STDeleteChatMessageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deleteChatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deleteChatMessage(v)
        }
      }()
      case 5: try {
        var v: STChatMessageConfigReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .chatMessageConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .chatMessageConfig(v)
        }
      }()
      case 20: try {
        var v: STLoadChatRecordReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadChatRecord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadChatRecord(v)
        }
      }()
      case 21: try {
        var v: STLoadChatStatusReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadChatStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadChatStatus(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .sendChatMessage?: try {
      guard case .sendChatMessage(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendChatMessageReceipt?: try {
      guard case .sendChatMessageReceipt(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .retractChatMessage?: try {
      guard case .retractChatMessage(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteChatMessage?: try {
      guard case .deleteChatMessage(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .chatMessageConfig?: try {
      guard case .chatMessageConfig(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .loadChatRecord?: try {
      guard case .loadChatRecord(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .loadChatStatus?: try {
      guard case .loadChatStatus(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMessageRequest, rhs: STMessageRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "send_chat_message"),
    2: .standard(proto: "send_chat_message_receipt"),
    3: .standard(proto: "retract_chat_message"),
    4: .standard(proto: "delete_chat_message"),
    5: .standard(proto: "chat_message_config"),
    20: .standard(proto: "load_chat_record"),
    21: .standard(proto: "load_chat_status"),
    101: .standard(proto: "message_notification"),
    102: .standard(proto: "read_message_notification"),
    103: .standard(proto: "chat_message_callback"),
    104: .standard(proto: "user_follow"),
    105: .standard(proto: "message_push"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: STSendChatMessageRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sendChatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sendChatMessage(v)
        }
      }()
      case 2: try {
        var v: STSendMessageReceiptRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .sendChatMessageReceipt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .sendChatMessageReceipt(v)
        }
      }()
      case 3: try {
        var v: STRetractChatMessageRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .retractChatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .retractChatMessage(v)
        }
      }()
      case 4: try {
        var v: STDeleteChatMessageRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .deleteChatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .deleteChatMessage(v)
        }
      }()
      case 5: try {
        var v: STChatMessageConfigRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .chatMessageConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .chatMessageConfig(v)
        }
      }()
      case 20: try {
        var v: STLoadChatRecordRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadChatRecord(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadChatRecord(v)
        }
      }()
      case 21: try {
        var v: STLoadChatStatusRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadChatStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadChatStatus(v)
        }
      }()
      case 101: try {
        var v: STMessageNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .messageNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .messageNotification(v)
        }
      }()
      case 102: try {
        var v: STReadMessageNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .readMessageNotification(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .readMessageNotification(v)
        }
      }()
      case 103: try {
        var v: STAuditChatMessageCallback?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .chatMessageCallback(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .chatMessageCallback(v)
        }
      }()
      case 104: try {
        var v: STUserFollowNotification?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .userFollow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .userFollow(v)
        }
      }()
      case 105: try {
        var v: STMessagePush?
        var hadOneofValue = false
        if let current = self.notification {
          hadOneofValue = true
          if case .messagePush(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.notification = .messagePush(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .sendChatMessage?: try {
      guard case .sendChatMessage(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sendChatMessageReceipt?: try {
      guard case .sendChatMessageReceipt(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .retractChatMessage?: try {
      guard case .retractChatMessage(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteChatMessage?: try {
      guard case .deleteChatMessage(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .chatMessageConfig?: try {
      guard case .chatMessageConfig(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .loadChatRecord?: try {
      guard case .loadChatRecord(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .loadChatStatus?: try {
      guard case .loadChatStatus(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    switch self.notification {
    case .messageNotification?: try {
      guard case .messageNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .readMessageNotification?: try {
      guard case .readMessageNotification(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .chatMessageCallback?: try {
      guard case .chatMessageCallback(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .userFollow?: try {
      guard case .userFollow(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .messagePush?: try {
      guard case .messagePush(let v)? = self.notification else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMessageResponse, rhs: STMessageResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.notification != rhs.notification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STLoadChatStatusReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LoadChatStatusReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STLoadChatStatusReq, rhs: STLoadChatStatusReq) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STLoadChatStatusRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LoadChatStatusRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STLoadChatStatusRes, rhs: STLoadChatStatusRes) -> Bool {
    if lhs._messageStatus != rhs._messageStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMessageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMessageStatus, rhs: STMessageStatus) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STLoadChatRecordReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LoadChatRecordReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_record_type"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.chatRecordType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.page) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chatRecordType != .notset {
      try visitor.visitSingularEnumField(value: self.chatRecordType, fieldNumber: 1)
    }
    if self.page != 0 {
      try visitor.visitSingularInt64Field(value: self.page, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STLoadChatRecordReq, rhs: STLoadChatRecordReq) -> Bool {
    if lhs.chatRecordType != rhs.chatRecordType {return false}
    if lhs.page != rhs.page {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STLoadChatRecordRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "LoadChatRecordRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_id"),
    2: .standard(proto: "session_patches"),
    3: .standard(proto: "has_more"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.batchID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sessionPatches) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hasMore_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchID != 0 {
      try visitor.visitSingularInt64Field(value: self.batchID, fieldNumber: 1)
    }
    if !self.sessionPatches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionPatches, fieldNumber: 2)
    }
    if self.hasMore_p != false {
      try visitor.visitSingularBoolField(value: self.hasMore_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STLoadChatRecordRes, rhs: STLoadChatRecordRes) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.sessionPatches != rhs.sessionPatches {return false}
    if lhs.hasMore_p != rhs.hasMore_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChatMessageConfigReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatMessageConfigReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .same(proto: "remarks"),
    3: .same(proto: "disturb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .remarks(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .disturb(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    switch self.content {
    case .remarks?: try {
      guard case .remarks(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .disturb?: try {
      guard case .disturb(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChatMessageConfigReq, rhs: STChatMessageConfigReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChatMessageConfigRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatMessageConfigRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChatMessageConfigRes, rhs: STChatMessageConfigRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STDeleteChatMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteChatMessageReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STDeleteChatMessageReq, rhs: STDeleteChatMessageReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STDeleteChatMessageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "DeleteChatMessageRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STDeleteChatMessageRes, rhs: STDeleteChatMessageRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSendChatMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendChatMessageReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .same(proto: "message"),
    3: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.source != .none {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSendChatMessageReq, rhs: STSendChatMessageReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSendChatMessageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendChatMessageRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .same(proto: "message"),
  ]

  fileprivate class _StorageClass {
    var _receiver: STUserInCommon? = nil
    var _message: STMessageItem? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _receiver = source._receiver
      _message = source._message
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._receiver) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._message) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._receiver {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._message {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSendChatMessageRes, rhs: STSendChatMessageRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._receiver != rhs_storage._receiver {return false}
        if _storage._message != rhs_storage._message {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ChatMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "audio"),
    3: .same(proto: "video"),
    4: .same(proto: "image"),
    5: .standard(proto: "system_warning"),
    10: .same(proto: "retract"),
    11: .same(proto: "invite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 2: try {
        var v: STAudioAndVideoMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .audio(v)
        }
      }()
      case 3: try {
        var v: STAudioAndVideoMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .video(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .video(v)
        }
      }()
      case 4: try {
        var v: STImageMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .image(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .systemWarning(v)
        }
      }()
      case 10: try {
        var v: STRetractChatMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .retract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .retract(v)
        }
      }()
      case 11: try {
        var v: STInterrelationMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .invite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .invite(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .audio?: try {
      guard case .audio(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .video?: try {
      guard case .video(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .image?: try {
      guard case .image(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .systemWarning?: try {
      guard case .systemWarning(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .retract?: try {
      guard case .retract(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .invite?: try {
      guard case .invite(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STChatMessage, rhs: STChatMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STInterrelationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InterrelationMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STInterrelationMessage, rhs: STInterrelationMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STAudioAndVideoMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AudioAndVideoMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "duration"),
    3: .standard(proto: "file_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 2)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STAudioAndVideoMessage, rhs: STAudioAndVideoMessage) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STImageMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImageMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .standard(proto: "image_url"),
    4: .standard(proto: "file_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 3)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STImageMessage, rhs: STImageMessage) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.filePath != rhs.filePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMessageItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "sender_id"),
    3: .standard(proto: "receiver_id"),
    4: .same(proto: "warning"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "state"),
    7: .same(proto: "tips"),
    10: .standard(proto: "system_message"),
    11: .standard(proto: "interact_message"),
    12: .standard(proto: "advertising_message"),
    13: .standard(proto: "chat_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.senderID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.receiverID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.warning) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.tips) }()
      case 10: try {
        var v: STSystemMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .systemMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .systemMessage(v)
        }
      }()
      case 11: try {
        var v: STInteractMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .interactMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .interactMessage(v)
        }
      }()
      case 12: try {
        var v: STAdvertisingMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .advertisingMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .advertisingMessage(v)
        }
      }()
      case 13: try {
        var v: STChatMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chatMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chatMessage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    if !self.senderID.isEmpty {
      try visitor.visitSingularStringField(value: self.senderID, fieldNumber: 2)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 3)
    }
    if !self.warning.isEmpty {
      try visitor.visitSingularStringField(value: self.warning, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    if self.state != .notset {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if !self.tips.isEmpty {
      try visitor.visitSingularStringField(value: self.tips, fieldNumber: 7)
    }
    switch self.type {
    case .systemMessage?: try {
      guard case .systemMessage(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .interactMessage?: try {
      guard case .interactMessage(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .advertisingMessage?: try {
      guard case .advertisingMessage(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .chatMessage?: try {
      guard case .chatMessage(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMessageItem, rhs: STMessageItem) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.senderID != rhs.senderID {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.warning != rhs.warning {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.state != rhs.state {return false}
    if lhs.tips != rhs.tips {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMessagePush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessagePush"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_prompt"),
    2: .standard(proto: "interact_prompt"),
    3: .standard(proto: "family_prompt"),
    4: .same(proto: "firstChargePrompt"),
    5: .same(proto: "followPrompt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: STSystemPrompt?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .systemPrompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .systemPrompt(v)
        }
      }()
      case 2: try {
        var v: STInteractPrompt?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .interactPrompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .interactPrompt(v)
        }
      }()
      case 3: try {
        var v: STFamilyPrompt?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .familyPrompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .familyPrompt(v)
        }
      }()
      case 4: try {
        var v: STFirstChargePrompt?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .firstChargePrompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .firstChargePrompt(v)
        }
      }()
      case 5: try {
        var v: STFollowPrompt?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .followPrompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .followPrompt(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .systemPrompt?: try {
      guard case .systemPrompt(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .interactPrompt?: try {
      guard case .interactPrompt(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .familyPrompt?: try {
      guard case .familyPrompt(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .firstChargePrompt?: try {
      guard case .firstChargePrompt(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .followPrompt?: try {
      guard case .followPrompt(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMessagePush, rhs: STMessagePush) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSystemPrompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SystemPrompt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_content"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "unread"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgContent) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unread) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgContent.isEmpty {
      try visitor.visitSingularStringField(value: self.msgContent, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.unread != 0 {
      try visitor.visitSingularInt32Field(value: self.unread, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSystemPrompt, rhs: STSystemPrompt) -> Bool {
    if lhs.msgContent != rhs.msgContent {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unread != rhs.unread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STInteractPrompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InteractPrompt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "unread"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unread) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.unread != 0 {
      try visitor.visitSingularInt32Field(value: self.unread, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STInteractPrompt, rhs: STInteractPrompt) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unread != rhs.unread {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFollowPrompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FollowPrompt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "unread"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unread) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.unread != 0 {
      try visitor.visitSingularInt32Field(value: self.unread, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFollowPrompt, rhs: STFollowPrompt) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unread != rhs.unread {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFamilyPrompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FamilyPrompt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_content"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "unread"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgContent) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unread) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgContent.isEmpty {
      try visitor.visitSingularStringField(value: self.msgContent, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    if self.unread != 0 {
      try visitor.visitSingularInt32Field(value: self.unread, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFamilyPrompt, rhs: STFamilyPrompt) -> Bool {
    if lhs.msgContent != rhs.msgContent {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unread != rhs.unread {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFirstChargePrompt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FirstChargePrompt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bagName"),
    2: .same(proto: "prizes"),
    3: .same(proto: "prizeValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bagName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.prizes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prizeValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bagName.isEmpty {
      try visitor.visitSingularStringField(value: self.bagName, fieldNumber: 1)
    }
    if !self.prizes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.prizes, fieldNumber: 2)
    }
    if !self.prizeValue.isEmpty {
      try visitor.visitSingularStringField(value: self.prizeValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFirstChargePrompt, rhs: STFirstChargePrompt) -> Bool {
    if lhs.bagName != rhs.bagName {return false}
    if lhs.prizes != rhs.prizes {return false}
    if lhs.prizeValue != rhs.prizeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STFirstChargePrize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FirstChargePrize"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "giftName"),
    2: .same(proto: "giftIcon"),
    3: .same(proto: "giftType"),
    4: .same(proto: "dressupType"),
    5: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.giftName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.giftIcon) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.giftType) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.dressupType) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.giftName.isEmpty {
      try visitor.visitSingularStringField(value: self.giftName, fieldNumber: 1)
    }
    if !self.giftIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.giftIcon, fieldNumber: 2)
    }
    if self.giftType != 0 {
      try visitor.visitSingularInt32Field(value: self.giftType, fieldNumber: 3)
    }
    if self.dressupType != 0 {
      try visitor.visitSingularInt32Field(value: self.dressupType, fieldNumber: 4)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt32Field(value: self.duration, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STFirstChargePrize, rhs: STFirstChargePrize) -> Bool {
    if lhs.giftName != rhs.giftName {return false}
    if lhs.giftIcon != rhs.giftIcon {return false}
    if lhs.giftType != rhs.giftType {return false}
    if lhs.dressupType != rhs.dressupType {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSystemMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SystemMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unique_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uniqueID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uniqueID != 0 {
      try visitor.visitSingularInt64Field(value: self.uniqueID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSystemMessage, rhs: STSystemMessage) -> Bool {
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STInteractMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InteractMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "follow"),
    2: .standard(proto: "moment_comment"),
    3: .same(proto: "applaud"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: STInteractionMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .follow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .follow(v)
        }
      }()
      case 2: try {
        var v: STInteractionMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .momentComment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .momentComment(v)
        }
      }()
      case 3: try {
        var v: STInteractionMessage?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .applaud(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .applaud(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .follow?: try {
      guard case .follow(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .momentComment?: try {
      guard case .momentComment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .applaud?: try {
      guard case .applaud(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STInteractMessage, rhs: STInteractMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STAdvertisingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AdvertisingMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STAdvertisingMessage, rhs: STAdvertisingMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STInteractionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "InteractionMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "sender"),
    4: .standard(proto: "moment_id"),
    5: .standard(proto: "comment_id"),
    6: .same(proto: "read"),
    7: .same(proto: "content"),
    8: .standard(proto: "target_content"),
  ]

  fileprivate class _StorageClass {
    var _type: STInteractionMessageType = .notset
    var _messageID: Int64 = 0
    var _sender: STUserInCommon? = nil
    var _momentID: Int64 = 0
    var _commentID: Int64 = 0
    var _read: Bool = false
    var _content: String = String()
    var _targetContent: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _messageID = source._messageID
      _sender = source._sender
      _momentID = source._momentID
      _commentID = source._commentID
      _read = source._read
      _content = source._content
      _targetContent = source._targetContent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._messageID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sender) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._momentID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._commentID) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._read) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._content) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._targetContent) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .notset {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._messageID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._messageID, fieldNumber: 2)
      }
      try { if let v = _storage._sender {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._momentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._momentID, fieldNumber: 4)
      }
      if _storage._commentID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._commentID, fieldNumber: 5)
      }
      if _storage._read != false {
        try visitor.visitSingularBoolField(value: _storage._read, fieldNumber: 6)
      }
      if !_storage._content.isEmpty {
        try visitor.visitSingularStringField(value: _storage._content, fieldNumber: 7)
      }
      if !_storage._targetContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetContent, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STInteractionMessage, rhs: STInteractionMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._sender != rhs_storage._sender {return false}
        if _storage._momentID != rhs_storage._momentID {return false}
        if _storage._commentID != rhs_storage._commentID {return false}
        if _storage._read != rhs_storage._read {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._targetContent != rhs_storage._targetContent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSendMessageReceiptReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageReceiptReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "batch_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "target_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.batchID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .notset {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.batchID != 0 {
      try visitor.visitSingularInt64Field(value: self.batchID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSendMessageReceiptReq, rhs: STSendMessageReceiptReq) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.batchID != rhs.batchID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSendMessageReceiptRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SendMessageReceiptRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSendMessageReceiptRes, rhs: STSendMessageReceiptRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STMessageNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "MessageNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "batch_id"),
    1: .standard(proto: "session_patches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessionPatches) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.batchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionPatches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionPatches, fieldNumber: 1)
    }
    if self.batchID != 0 {
      try visitor.visitSingularInt64Field(value: self.batchID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STMessageNotification, rhs: STMessageNotification) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.sessionPatches != rhs.sessionPatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STSessionPatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SessionPatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "system"),
    2: .same(proto: "interactive"),
    3: .same(proto: "advertising"),
    4: .same(proto: "chat"),
    10: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: STNone?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .system(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .system(v)
        }
      }()
      case 2: try {
        var v: STNone?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .interactive(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .interactive(v)
        }
      }()
      case 3: try {
        var v: STNone?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .advertising(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .advertising(v)
        }
      }()
      case 4: try {
        var v: STUserInCommon?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .chat(v)
        }
      }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .system?: try {
      guard case .system(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .interactive?: try {
      guard case .interactive(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .advertising?: try {
      guard case .advertising(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .chat?: try {
      guard case .chat(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STSessionPatch, rhs: STSessionPatch) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRetractChatMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RetractChatMessageReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRetractChatMessageReq, rhs: STRetractChatMessageReq) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRetractChatMessageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RetractChatMessageRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRetractChatMessageRes, rhs: STRetractChatMessageRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STRetractChatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "RetractChatMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STRetractChatMessage, rhs: STRetractChatMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STReadMessageNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReadMessageNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "batch_id"),
    2: .same(proto: "readMessage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.batchID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.readMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.batchID != 0 {
      try visitor.visitSingularInt64Field(value: self.batchID, fieldNumber: 1)
    }
    if !self.readMessage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.readMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STReadMessageNotification, rhs: STReadMessageNotification) -> Bool {
    if lhs.batchID != rhs.batchID {return false}
    if lhs.readMessage != rhs.readMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STReadMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ReadMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .standard(proto: "target_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STReadMessage, rhs: STReadMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STAuditChatMessageCallback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "AuditChatMessageCallback"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularInt64Field(value: self.messageID, fieldNumber: 2)
    }
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STAuditChatMessageCallback, rhs: STAuditChatMessageCallback) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension STUserFollowNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserFollowNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if self.state != .notset {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: STUserFollowNotification, rhs: STUserFollowNotification) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
