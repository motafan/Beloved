// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 消息相关请求
public struct OSMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSMessageRequest.OneOf_Body? = nil

  /// 房间公屏最新3条历史消息请求
  public var channelMsgReq: OSChannelMsgReq {
    get {
      if case .channelMsgReq(let v)? = body {return v}
      return OSChannelMsgReq()
    }
    set {body = .channelMsgReq(newValue)}
  }

  /// 房间公屏消息上报请求
  public var channelReportReq: OSChannelReportReq {
    get {
      if case .channelReportReq(let v)? = body {return v}
      return OSChannelReportReq()
    }
    set {body = .channelReportReq(newValue)}
  }

  /// 最新消息请求
  public var latestMessageReq: OSLatestMessageReq {
    get {
      if case .latestMessageReq(let v)? = body {return v}
      return OSLatestMessageReq()
    }
    set {body = .latestMessageReq(newValue)}
  }

  /// 系统消息(官方小助手)请求
  public var systemMessageReq: OSSystemMessageReq {
    get {
      if case .systemMessageReq(let v)? = body {return v}
      return OSSystemMessageReq()
    }
    set {body = .systemMessageReq(newValue)}
  }

  /// 用户在线状态列表请求
  public var onlineStateListReq: OSOnlineStateListReq {
    get {
      if case .onlineStateListReq(let v)? = body {return v}
      return OSOnlineStateListReq()
    }
    set {body = .onlineStateListReq(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 房间公屏最新3条历史消息请求
    case channelMsgReq(OSChannelMsgReq)
    /// 房间公屏消息上报请求
    case channelReportReq(OSChannelReportReq)
    /// 最新消息请求
    case latestMessageReq(OSLatestMessageReq)
    /// 系统消息(官方小助手)请求
    case systemMessageReq(OSSystemMessageReq)
    /// 用户在线状态列表请求
    case onlineStateListReq(OSOnlineStateListReq)

  }

  public init() {}
}

/// 消息相关响应
public struct OSMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSMessageResponse.OneOf_Body? = nil

  /// 房间公屏最新3条历史消息响应
  public var channelMsgRes: OSChannelMsgRes {
    get {
      if case .channelMsgRes(let v)? = body {return v}
      return OSChannelMsgRes()
    }
    set {body = .channelMsgRes(newValue)}
  }

  /// 房间公屏消息上报响应
  public var channelReportRes: OSChannelReportRes {
    get {
      if case .channelReportRes(let v)? = body {return v}
      return OSChannelReportRes()
    }
    set {body = .channelReportRes(newValue)}
  }

  /// 最新消息响应
  public var latestMessageRes: OSLatestMessageRes {
    get {
      if case .latestMessageRes(let v)? = body {return v}
      return OSLatestMessageRes()
    }
    set {body = .latestMessageRes(newValue)}
  }

  /// 系统消息(官方小助手)响应
  public var systemMessageRes: OSSystemMessageRes {
    get {
      if case .systemMessageRes(let v)? = body {return v}
      return OSSystemMessageRes()
    }
    set {body = .systemMessageRes(newValue)}
  }

  /// 用户在线状态列表响应
  public var onlineStateListRes: OSOnlineStateListRes {
    get {
      if case .onlineStateListRes(let v)? = body {return v}
      return OSOnlineStateListRes()
    }
    set {body = .onlineStateListRes(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 房间公屏最新3条历史消息响应
    case channelMsgRes(OSChannelMsgRes)
    /// 房间公屏消息上报响应
    case channelReportRes(OSChannelReportRes)
    /// 最新消息响应
    case latestMessageRes(OSLatestMessageRes)
    /// 系统消息(官方小助手)响应
    case systemMessageRes(OSSystemMessageRes)
    /// 用户在线状态列表响应
    case onlineStateListRes(OSOnlineStateListRes)

  }

  public init() {}
}

/// 房间公屏最新3条历史消息请求
public struct OSChannelMsgReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间公屏最新3条历史消息响应
public struct OSChannelMsgRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var channelMsgList: [OSChannelMsg] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 公屏消息
public struct OSChannelMsg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息id
  public var id: Int32 = 0

  /// 房间id
  public var channelID: String = String()

  /// 用户系统id
  public var userID: String = String()

  public var accountID: Int32 = 0

  /// 用户昵称
  public var nickname: String = String()

  /// 头像
  public var avatarURL: String = String()

  /// 内容
  public var content: String = String()

  /// 权限 OWNER:房主 SUPER_ADMIN:超级管理员 ADMIN:管理员 NORMAL:普通用户 FAMILY_OWNER:公会会长 BLACKLIST:黑名单用户
  public var powerType: OSPowerType = .unknown

  /// 消息类型
  public var msgType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间公屏消息上报请求
public struct OSChannelReportReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间id
  public var channelID: String = String()

  /// 消息内容
  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 房间公屏消息上报响应
public struct OSChannelReportRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 勋章列表
  public var medalList: [OSMedalList] {
    get {return _storage._medalList}
    set {_uniqueStorage()._medalList = newValue}
  }

  /// 尾灯信息
  public var taillightInfo: OSTaillightInfo {
    get {return _storage._taillightInfo ?? OSTaillightInfo()}
    set {_uniqueStorage()._taillightInfo = newValue}
  }
  /// Returns true if `taillightInfo` has been explicitly set.
  public var hasTaillightInfo: Bool {return _storage._taillightInfo != nil}
  /// Clears the value of `taillightInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTaillightInfo() {_uniqueStorage()._taillightInfo = nil}

  /// 气泡框信息
  public var bubbleInfo: OSBubbleInfo {
    get {return _storage._bubbleInfo ?? OSBubbleInfo()}
    set {_uniqueStorage()._bubbleInfo = newValue}
  }
  /// Returns true if `bubbleInfo` has been explicitly set.
  public var hasBubbleInfo: Bool {return _storage._bubbleInfo != nil}
  /// Clears the value of `bubbleInfo`. Subsequent reads from it will return its default value.
  public mutating func clearBubbleInfo() {_uniqueStorage()._bubbleInfo = nil}

  /// 挂件信息
  public var pendantList: [OSPendantInfo] {
    get {return _storage._pendantList}
    set {_uniqueStorage()._pendantList = newValue}
  }

  /// 贵宾卡信息
  public var honouredGuestCard: OSHonouredGuestCard {
    get {return _storage._honouredGuestCard ?? OSHonouredGuestCard()}
    set {_uniqueStorage()._honouredGuestCard = newValue}
  }
  /// Returns true if `honouredGuestCard` has been explicitly set.
  public var hasHonouredGuestCard: Bool {return _storage._honouredGuestCard != nil}
  /// Clears the value of `honouredGuestCard`. Subsequent reads from it will return its default value.
  public mutating func clearHonouredGuestCard() {_uniqueStorage()._honouredGuestCard = nil}

  /// 粉丝团徽章信息
  public var fansBadge: OSFansClubVo {
    get {return _storage._fansBadge ?? OSFansClubVo()}
    set {_uniqueStorage()._fansBadge = newValue}
  }
  /// Returns true if `fansBadge` has been explicitly set.
  public var hasFansBadge: Bool {return _storage._fansBadge != nil}
  /// Clears the value of `fansBadge`. Subsequent reads from it will return its default value.
  public mutating func clearFansBadge() {_uniqueStorage()._fansBadge = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 尾灯信息
public struct OSTaillightInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  /// 装扮名称
  public var dressName: String = String()

  /// 装扮图标
  public var dressIcon: String = String()

  /// 装扮特效
  public var effectURL: String = String()

  /// 背景图
  public var backgroudURL: String = String()

  /// 获得方式说明
  public var approach: String = String()

  /// 获得方式说明颜色值
  public var approachColor: String = String()

  /// 装扮名称颜色值
  public var dressNameColor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 气泡框信息
public struct OSBubbleInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  /// 装扮名称
  public var dressName: String = String()

  /// 装扮图标
  public var dressIcon: String = String()

  /// 装扮特效
  public var effectURL: String = String()

  ///装扮图标（新）
  public var dressIconURL: OSDressIconUrl {
    get {return _dressIconURL ?? OSDressIconUrl()}
    set {_dressIconURL = newValue}
  }
  /// Returns true if `dressIconURL` has been explicitly set.
  public var hasDressIconURL: Bool {return self._dressIconURL != nil}
  /// Clears the value of `dressIconURL`. Subsequent reads from it will return its default value.
  public mutating func clearDressIconURL() {self._dressIconURL = nil}

  ///角标（新）
  public var cornerURL: OSCornerUrl {
    get {return _cornerURL ?? OSCornerUrl()}
    set {_cornerURL = newValue}
  }
  /// Returns true if `cornerURL` has been explicitly set.
  public var hasCornerURL: Bool {return self._cornerURL != nil}
  /// Clears the value of `cornerURL`. Subsequent reads from it will return its default value.
  public mutating func clearCornerURL() {self._cornerURL = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dressIconURL: OSDressIconUrl? = nil
  fileprivate var _cornerURL: OSCornerUrl? = nil
}

public struct OSDressIconUrl: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///小图
  public var smallURL: String = String()

  ///中图
  public var middleURL: String = String()

  ///大图
  public var bigURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSCornerUrl: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///左上角标
  public var leftUpperCorner: String = String()

  ///左下角标
  public var leftDownCorner: String = String()

  ///右上角标
  public var rightUpperCorner: String = String()

  ///右下角标
  public var rightDownCorner: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 挂件信息
public struct OSPendantInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 装扮id
  public var dressID: Int32 = 0

  /// 装扮名称
  public var dressName: String = String()

  /// 装扮图标
  public var dressIcon: String = String()

  /// 装扮特效
  public var effectURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 最新消息请求
public struct OSLatestMessageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 最新消息响应
public struct OSLatestMessageRes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 系统消息
  public var systemMessage: OSSystemMessageVo {
    get {return _storage._systemMessage ?? OSSystemMessageVo()}
    set {_uniqueStorage()._systemMessage = newValue}
  }
  /// Returns true if `systemMessage` has been explicitly set.
  public var hasSystemMessage: Bool {return _storage._systemMessage != nil}
  /// Clears the value of `systemMessage`. Subsequent reads from it will return its default value.
  public mutating func clearSystemMessage() {_uniqueStorage()._systemMessage = nil}

  /// 互动消息
  public var interactionMessage: OSInteractionVo {
    get {return _storage._interactionMessage ?? OSInteractionVo()}
    set {_uniqueStorage()._interactionMessage = newValue}
  }
  /// Returns true if `interactionMessage` has been explicitly set.
  public var hasInteractionMessage: Bool {return _storage._interactionMessage != nil}
  /// Clears the value of `interactionMessage`. Subsequent reads from it will return its default value.
  public mutating func clearInteractionMessage() {_uniqueStorage()._interactionMessage = nil}

  /// 家族消息
  public var familyMessage: OSFamilyMessageVo {
    get {return _storage._familyMessage ?? OSFamilyMessageVo()}
    set {_uniqueStorage()._familyMessage = newValue}
  }
  /// Returns true if `familyMessage` has been explicitly set.
  public var hasFamilyMessage: Bool {return _storage._familyMessage != nil}
  /// Clears the value of `familyMessage`. Subsequent reads from it will return its default value.
  public mutating func clearFamilyMessage() {_uniqueStorage()._familyMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// 系统消息
public struct OSSystemMessageVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息id
  public var msgID: Int32 = 0

  /// 消息类型,1文本消息 2图文消息 3公会消息
  public var msgType: OSSystemMessageType = .unknown

  /// 消息内容
  public var msgContent: String = String()

  /// 是否已读,0未读 1已读 (请求列表时不返回)
  public var readState: Int32 = 0

  /// 时间戳
  public var createTimestamp: Int64 = 0

  /// 标题
  public var msgTitle: String = String()

  /// 跳转类型,0房间 1浏览器(H5) 2APP页面
  public var msgLinkType: OSMsgLinkType = .linkChannel

  /// 跳转内容
  public var msgLinkValue: String = String()

  /// 图片
  public var msgImgURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 家族消息
public struct OSFamilyMessageVo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 消息id
  public var msgID: Int32 = 0

  /// 消息类型
  public var msgType: OSFamilyMessageType = .unknown

  /// 消息内容
  public var msgContent: String = String()

  /// 是否已读,0未读 1已读 (请求列表时不返回)
  public var readState: Int32 = 0

  /// 时间戳
  public var createTimestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 系统消息(官方小助手)请求
public struct OSSystemMessageReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 页数
  public var current: Int32 = 0

  /// 每页数量大小
  public var size: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 系统消息(官方小助手)响应
public struct OSSystemMessageRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 总数
  public var total: Int32 = 0

  /// 每页数量
  public var size: Int32 = 0

  /// 当前页
  public var current: Int32 = 0

  /// 消息列表
  public var records: [OSSystemMessageVo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户在线状态列表请求
public struct OSOnlineStateListReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用户Id列表
  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// 用户在线状态列表响应
public struct OSOnlineStateListRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var onlineStateList: [OSOnlineStateList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSOnlineStateList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///用户Id
  public var userID: String = String()

  ///在线状态 0不在线 1在线
  public var onlineState: Int32 = 0

  /// 用户当前所在房间信息
  public var channelOnlineInfo: OSChannelOnlineInfo {
    get {return _channelOnlineInfo ?? OSChannelOnlineInfo()}
    set {_channelOnlineInfo = newValue}
  }
  /// Returns true if `channelOnlineInfo` has been explicitly set.
  public var hasChannelOnlineInfo: Bool {return self._channelOnlineInfo != nil}
  /// Clears the value of `channelOnlineInfo`. Subsequent reads from it will return its default value.
  public mutating func clearChannelOnlineInfo() {self._channelOnlineInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _channelOnlineInfo: OSChannelOnlineInfo? = nil
}

/// 用户当前所在房间信息
public struct OSChannelOnlineInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 房间Id
  public var channelID: String = String()

  /// 房间号
  public var channelNo: Int32 = 0

  /// 房间名称
  public var channelName: String = String()

  /// 房间锁状态
  public var lockedStatus: Int32 = 0

  /// 标签名称
  public var labelName: String = String()

  /// 房间类型
  public var channelType: OSChannelType = .unkown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelMsgReq"),
    2: .same(proto: "channelReportReq"),
    3: .same(proto: "latestMessageReq"),
    4: .same(proto: "systemMessageReq"),
    5: .same(proto: "OnlineStateListReq"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSChannelMsgReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelMsgReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelMsgReq(v)
        }
      }()
      case 2: try {
        var v: OSChannelReportReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelReportReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelReportReq(v)
        }
      }()
      case 3: try {
        var v: OSLatestMessageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .latestMessageReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .latestMessageReq(v)
        }
      }()
      case 4: try {
        var v: OSSystemMessageReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .systemMessageReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .systemMessageReq(v)
        }
      }()
      case 5: try {
        var v: OSOnlineStateListReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .onlineStateListReq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .onlineStateListReq(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .channelMsgReq?: try {
      guard case .channelMsgReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .channelReportReq?: try {
      guard case .channelReportReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .latestMessageReq?: try {
      guard case .latestMessageReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .systemMessageReq?: try {
      guard case .systemMessageReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .onlineStateListReq?: try {
      guard case .onlineStateListReq(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMessageRequest, rhs: OSMessageRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelMsgRes"),
    2: .same(proto: "channelReportRes"),
    3: .same(proto: "latestMessageRes"),
    4: .same(proto: "systemMessageRes"),
    5: .same(proto: "OnlineStateListRes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSChannelMsgRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelMsgRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelMsgRes(v)
        }
      }()
      case 2: try {
        var v: OSChannelReportRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .channelReportRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .channelReportRes(v)
        }
      }()
      case 3: try {
        var v: OSLatestMessageRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .latestMessageRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .latestMessageRes(v)
        }
      }()
      case 4: try {
        var v: OSSystemMessageRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .systemMessageRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .systemMessageRes(v)
        }
      }()
      case 5: try {
        var v: OSOnlineStateListRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .onlineStateListRes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .onlineStateListRes(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .channelMsgRes?: try {
      guard case .channelMsgRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .channelReportRes?: try {
      guard case .channelReportRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .latestMessageRes?: try {
      guard case .latestMessageRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .systemMessageRes?: try {
      guard case .systemMessageRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .onlineStateListRes?: try {
      guard case .onlineStateListRes(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSMessageResponse, rhs: OSMessageResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelMsgReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMsgReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelMsgReq, rhs: OSChannelMsgReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelMsgRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMsgRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelMsgList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channelMsgList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelMsgList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelMsgList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelMsgRes, rhs: OSChannelMsgRes) -> Bool {
    if lhs.channelMsgList != rhs.channelMsgList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelMsg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "channelId"),
    3: .same(proto: "userId"),
    4: .same(proto: "accountId"),
    5: .same(proto: "nickname"),
    6: .same(proto: "avatarUrl"),
    7: .same(proto: "content"),
    8: .same(proto: "powerType"),
    9: .same(proto: "msgType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.powerType) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.msgType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 4)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 5)
    }
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 6)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 7)
    }
    if self.powerType != .unknown {
      try visitor.visitSingularEnumField(value: self.powerType, fieldNumber: 8)
    }
    if !self.msgType.isEmpty {
      try visitor.visitSingularStringField(value: self.msgType, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelMsg, rhs: OSChannelMsg) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs.content != rhs.content {return false}
    if lhs.powerType != rhs.powerType {return false}
    if lhs.msgType != rhs.msgType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelReportReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelReportReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelReportReq, rhs: OSChannelReportReq) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelReportRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelReportRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "medalList"),
    2: .same(proto: "taillightInfo"),
    3: .same(proto: "bubbleInfo"),
    4: .same(proto: "pendantList"),
    5: .same(proto: "honouredGuestCard"),
    6: .same(proto: "fansBadge"),
  ]

  fileprivate class _StorageClass {
    var _medalList: [OSMedalList] = []
    var _taillightInfo: OSTaillightInfo? = nil
    var _bubbleInfo: OSBubbleInfo? = nil
    var _pendantList: [OSPendantInfo] = []
    var _honouredGuestCard: OSHonouredGuestCard? = nil
    var _fansBadge: OSFansClubVo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _medalList = source._medalList
      _taillightInfo = source._taillightInfo
      _bubbleInfo = source._bubbleInfo
      _pendantList = source._pendantList
      _honouredGuestCard = source._honouredGuestCard
      _fansBadge = source._fansBadge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._medalList) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._taillightInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bubbleInfo) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendantList) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._honouredGuestCard) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._fansBadge) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._medalList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._medalList, fieldNumber: 1)
      }
      try { if let v = _storage._taillightInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._bubbleInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._pendantList.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendantList, fieldNumber: 4)
      }
      try { if let v = _storage._honouredGuestCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._fansBadge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelReportRes, rhs: OSChannelReportRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._medalList != rhs_storage._medalList {return false}
        if _storage._taillightInfo != rhs_storage._taillightInfo {return false}
        if _storage._bubbleInfo != rhs_storage._bubbleInfo {return false}
        if _storage._pendantList != rhs_storage._pendantList {return false}
        if _storage._honouredGuestCard != rhs_storage._honouredGuestCard {return false}
        if _storage._fansBadge != rhs_storage._fansBadge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSTaillightInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TaillightInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "dressName"),
    3: .same(proto: "dressIcon"),
    4: .same(proto: "effectUrl"),
    5: .same(proto: "backgroudUrl"),
    6: .same(proto: "approach"),
    7: .same(proto: "approachColor"),
    8: .same(proto: "dressNameColor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressIcon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.backgroudURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.approach) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.approachColor) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.dressNameColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 2)
    }
    if !self.dressIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIcon, fieldNumber: 3)
    }
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 4)
    }
    if !self.backgroudURL.isEmpty {
      try visitor.visitSingularStringField(value: self.backgroudURL, fieldNumber: 5)
    }
    if !self.approach.isEmpty {
      try visitor.visitSingularStringField(value: self.approach, fieldNumber: 6)
    }
    if !self.approachColor.isEmpty {
      try visitor.visitSingularStringField(value: self.approachColor, fieldNumber: 7)
    }
    if !self.dressNameColor.isEmpty {
      try visitor.visitSingularStringField(value: self.dressNameColor, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSTaillightInfo, rhs: OSTaillightInfo) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.dressName != rhs.dressName {return false}
    if lhs.dressIcon != rhs.dressIcon {return false}
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs.backgroudURL != rhs.backgroudURL {return false}
    if lhs.approach != rhs.approach {return false}
    if lhs.approachColor != rhs.approachColor {return false}
    if lhs.dressNameColor != rhs.dressNameColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSBubbleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BubbleInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "dressName"),
    3: .same(proto: "dressIcon"),
    4: .same(proto: "effectUrl"),
    5: .same(proto: "dressIconUrl"),
    6: .same(proto: "cornerUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressIcon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._dressIconURL) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._cornerURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 2)
    }
    if !self.dressIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIcon, fieldNumber: 3)
    }
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 4)
    }
    try { if let v = self._dressIconURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._cornerURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSBubbleInfo, rhs: OSBubbleInfo) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.dressName != rhs.dressName {return false}
    if lhs.dressIcon != rhs.dressIcon {return false}
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs._dressIconURL != rhs._dressIconURL {return false}
    if lhs._cornerURL != rhs._cornerURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSDressIconUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DressIconUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "smallUrl"),
    2: .same(proto: "middleUrl"),
    3: .same(proto: "bigUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.smallURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.middleURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bigURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.smallURL.isEmpty {
      try visitor.visitSingularStringField(value: self.smallURL, fieldNumber: 1)
    }
    if !self.middleURL.isEmpty {
      try visitor.visitSingularStringField(value: self.middleURL, fieldNumber: 2)
    }
    if !self.bigURL.isEmpty {
      try visitor.visitSingularStringField(value: self.bigURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSDressIconUrl, rhs: OSDressIconUrl) -> Bool {
    if lhs.smallURL != rhs.smallURL {return false}
    if lhs.middleURL != rhs.middleURL {return false}
    if lhs.bigURL != rhs.bigURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCornerUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CornerUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "leftUpperCorner"),
    2: .same(proto: "leftDownCorner"),
    3: .same(proto: "rightUpperCorner"),
    4: .same(proto: "rightDownCorner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.leftUpperCorner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.leftDownCorner) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rightUpperCorner) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rightDownCorner) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.leftUpperCorner.isEmpty {
      try visitor.visitSingularStringField(value: self.leftUpperCorner, fieldNumber: 1)
    }
    if !self.leftDownCorner.isEmpty {
      try visitor.visitSingularStringField(value: self.leftDownCorner, fieldNumber: 2)
    }
    if !self.rightUpperCorner.isEmpty {
      try visitor.visitSingularStringField(value: self.rightUpperCorner, fieldNumber: 3)
    }
    if !self.rightDownCorner.isEmpty {
      try visitor.visitSingularStringField(value: self.rightDownCorner, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCornerUrl, rhs: OSCornerUrl) -> Bool {
    if lhs.leftUpperCorner != rhs.leftUpperCorner {return false}
    if lhs.leftDownCorner != rhs.leftDownCorner {return false}
    if lhs.rightUpperCorner != rhs.rightUpperCorner {return false}
    if lhs.rightDownCorner != rhs.rightDownCorner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPendantInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendantInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dressId"),
    2: .same(proto: "dressName"),
    3: .same(proto: "dressIcon"),
    4: .same(proto: "effectUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.dressID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dressName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dressIcon) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.effectURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dressID != 0 {
      try visitor.visitSingularInt32Field(value: self.dressID, fieldNumber: 1)
    }
    if !self.dressName.isEmpty {
      try visitor.visitSingularStringField(value: self.dressName, fieldNumber: 2)
    }
    if !self.dressIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.dressIcon, fieldNumber: 3)
    }
    if !self.effectURL.isEmpty {
      try visitor.visitSingularStringField(value: self.effectURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPendantInfo, rhs: OSPendantInfo) -> Bool {
    if lhs.dressID != rhs.dressID {return false}
    if lhs.dressName != rhs.dressName {return false}
    if lhs.dressIcon != rhs.dressIcon {return false}
    if lhs.effectURL != rhs.effectURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLatestMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestMessageReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLatestMessageReq, rhs: OSLatestMessageReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLatestMessageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestMessageRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "systemMessage"),
    2: .same(proto: "interactionMessage"),
    3: .same(proto: "familyMessage"),
  ]

  fileprivate class _StorageClass {
    var _systemMessage: OSSystemMessageVo? = nil
    var _interactionMessage: OSInteractionVo? = nil
    var _familyMessage: OSFamilyMessageVo? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _systemMessage = source._systemMessage
      _interactionMessage = source._interactionMessage
      _familyMessage = source._familyMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._systemMessage) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._interactionMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._familyMessage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._systemMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._interactionMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._familyMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLatestMessageRes, rhs: OSLatestMessageRes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._systemMessage != rhs_storage._systemMessage {return false}
        if _storage._interactionMessage != rhs_storage._interactionMessage {return false}
        if _storage._familyMessage != rhs_storage._familyMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSystemMessageVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemMessageVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgId"),
    2: .same(proto: "msgType"),
    3: .same(proto: "msgContent"),
    4: .same(proto: "readState"),
    5: .same(proto: "createTimestamp"),
    6: .same(proto: "msgTitle"),
    7: .same(proto: "msgLinkType"),
    8: .same(proto: "msgLinkValue"),
    9: .same(proto: "msgImgUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.msgType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgContent) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.readState) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTimestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.msgTitle) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.msgLinkType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.msgLinkValue) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.msgImgURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgID != 0 {
      try visitor.visitSingularInt32Field(value: self.msgID, fieldNumber: 1)
    }
    if self.msgType != .unknown {
      try visitor.visitSingularEnumField(value: self.msgType, fieldNumber: 2)
    }
    if !self.msgContent.isEmpty {
      try visitor.visitSingularStringField(value: self.msgContent, fieldNumber: 3)
    }
    if self.readState != 0 {
      try visitor.visitSingularInt32Field(value: self.readState, fieldNumber: 4)
    }
    if self.createTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.createTimestamp, fieldNumber: 5)
    }
    if !self.msgTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.msgTitle, fieldNumber: 6)
    }
    if self.msgLinkType != .linkChannel {
      try visitor.visitSingularEnumField(value: self.msgLinkType, fieldNumber: 7)
    }
    if !self.msgLinkValue.isEmpty {
      try visitor.visitSingularStringField(value: self.msgLinkValue, fieldNumber: 8)
    }
    if !self.msgImgURL.isEmpty {
      try visitor.visitSingularStringField(value: self.msgImgURL, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSystemMessageVo, rhs: OSSystemMessageVo) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.msgType != rhs.msgType {return false}
    if lhs.msgContent != rhs.msgContent {return false}
    if lhs.readState != rhs.readState {return false}
    if lhs.createTimestamp != rhs.createTimestamp {return false}
    if lhs.msgTitle != rhs.msgTitle {return false}
    if lhs.msgLinkType != rhs.msgLinkType {return false}
    if lhs.msgLinkValue != rhs.msgLinkValue {return false}
    if lhs.msgImgURL != rhs.msgImgURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSFamilyMessageVo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FamilyMessageVo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgId"),
    2: .same(proto: "msgType"),
    3: .same(proto: "msgContent"),
    4: .same(proto: "readState"),
    5: .same(proto: "createTimestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.msgID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.msgType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgContent) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.readState) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.createTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.msgID != 0 {
      try visitor.visitSingularInt32Field(value: self.msgID, fieldNumber: 1)
    }
    if self.msgType != .unknown {
      try visitor.visitSingularEnumField(value: self.msgType, fieldNumber: 2)
    }
    if !self.msgContent.isEmpty {
      try visitor.visitSingularStringField(value: self.msgContent, fieldNumber: 3)
    }
    if self.readState != 0 {
      try visitor.visitSingularInt32Field(value: self.readState, fieldNumber: 4)
    }
    if self.createTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.createTimestamp, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSFamilyMessageVo, rhs: OSFamilyMessageVo) -> Bool {
    if lhs.msgID != rhs.msgID {return false}
    if lhs.msgType != rhs.msgType {return false}
    if lhs.msgContent != rhs.msgContent {return false}
    if lhs.readState != rhs.readState {return false}
    if lhs.createTimestamp != rhs.createTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSystemMessageReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemMessageReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "current"),
    2: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSystemMessageReq, rhs: OSSystemMessageReq) -> Bool {
    if lhs.current != rhs.current {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSSystemMessageRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SystemMessageRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "size"),
    3: .same(proto: "current"),
    4: .same(proto: "records"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.current) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.records) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 2)
    }
    if self.current != 0 {
      try visitor.visitSingularInt32Field(value: self.current, fieldNumber: 3)
    }
    if !self.records.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.records, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSSystemMessageRes, rhs: OSSystemMessageRes) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.size != rhs.size {return false}
    if lhs.current != rhs.current {return false}
    if lhs.records != rhs.records {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineStateListReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineStateListReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineStateListReq, rhs: OSOnlineStateListReq) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineStateListRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineStateListRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "onlineStateList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.onlineStateList) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.onlineStateList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.onlineStateList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineStateListRes, rhs: OSOnlineStateListRes) -> Bool {
    if lhs.onlineStateList != rhs.onlineStateList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSOnlineStateList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnlineStateList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "onlineState"),
    3: .same(proto: "channelOnlineInfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.onlineState) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._channelOnlineInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.onlineState != 0 {
      try visitor.visitSingularInt32Field(value: self.onlineState, fieldNumber: 2)
    }
    try { if let v = self._channelOnlineInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSOnlineStateList, rhs: OSOnlineStateList) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.onlineState != rhs.onlineState {return false}
    if lhs._channelOnlineInfo != rhs._channelOnlineInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSChannelOnlineInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelOnlineInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channelId"),
    2: .same(proto: "channelNo"),
    3: .same(proto: "channelName"),
    4: .same(proto: "lockedStatus"),
    5: .same(proto: "labelName"),
    6: .same(proto: "channelType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.channelNo) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.lockedStatus) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.labelName) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.channelType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 1)
    }
    if self.channelNo != 0 {
      try visitor.visitSingularInt32Field(value: self.channelNo, fieldNumber: 2)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 3)
    }
    if self.lockedStatus != 0 {
      try visitor.visitSingularInt32Field(value: self.lockedStatus, fieldNumber: 4)
    }
    if !self.labelName.isEmpty {
      try visitor.visitSingularStringField(value: self.labelName, fieldNumber: 5)
    }
    if self.channelType != .unkown {
      try visitor.visitSingularEnumField(value: self.channelType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSChannelOnlineInfo, rhs: OSChannelOnlineInfo) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.channelNo != rhs.channelNo {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.lockedStatus != rhs.lockedStatus {return false}
    if lhs.labelName != rhs.labelName {return false}
    if lhs.channelType != rhs.channelType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
