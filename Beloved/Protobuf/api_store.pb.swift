// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api_store.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum OSStoreCategoryType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case storetypeNotSet // = 0
  case storetypeDress // = 1
  case storetypeBody // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .storetypeNotSet
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .storetypeNotSet
    case 1: self = .storetypeDress
    case 3: self = .storetypeBody
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .storetypeNotSet: return 0
    case .storetypeDress: return 1
    case .storetypeBody: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSStoreCategoryType] = [
    .storetypeNotSet,
    .storetypeDress,
    .storetypeBody,
  ]

}

public enum OSProductType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case notset // = 0
  case equipment // = 1
  case expression // = 2

  ///身体部位捏脸的
  case body // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notset
    case 1: self = .equipment
    case 2: self = .expression
    case 3: self = .body
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notset: return 0
    case .equipment: return 1
    case .expression: return 2
    case .body: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSProductType] = [
    .notset,
    .equipment,
    .expression,
    .body,
  ]

}

///*
/// 限定类型
public enum OSProductLimitType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case notset // = 0

  ///免费获得
  case free // = 1

  ///付费获得，普通商品
  case general // = 2

  ///财富魅力值要求获得
  case level // = 3

  ///等级贵族专用
  case nobility // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .notset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notset
    case 1: self = .free
    case 2: self = .general
    case 3: self = .level
    case 4: self = .nobility
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notset: return 0
    case .free: return 1
    case .general: return 2
    case .level: return 3
    case .nobility: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSProductLimitType] = [
    .notset,
    .free,
    .general,
    .level,
    .nobility,
  ]

}

public enum OSOwnState: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case notset // = 0

  /// 未拥有
  case unowned // = 2

  /// 已拥有
  case owned // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .notset
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notset
    case 2: self = .unowned
    case 3: self = .owned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .notset: return 0
    case .unowned: return 2
    case .owned: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [OSOwnState] = [
    .notset,
    .unowned,
    .owned,
  ]

}

/// 请求体
public struct OSStoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSStoreRequest.OneOf_Body? = nil

  /// 初始化商店数据
  public var init_p: OSStoreInitReq {
    get {
      if case .init_p(let v)? = body {return v}
      return OSStoreInitReq()
    }
    set {body = .init_p(newValue)}
  }

  /// 购买装扮
  public var purchaseProducts: OSPurchaseProductsReq {
    get {
      if case .purchaseProducts(let v)? = body {return v}
      return OSPurchaseProductsReq()
    }
    set {body = .purchaseProducts(newValue)}
  }

  /// 佩戴装扮
  public var wearProducts: OSWearProductsReq {
    get {
      if case .wearProducts(let v)? = body {return v}
      return OSWearProductsReq()
    }
    set {body = .wearProducts(newValue)}
  }

  ///给购物车检查下架商品
  public var checkProduct: OSCheckProductReq {
    get {
      if case .checkProduct(let v)? = body {return v}
      return OSCheckProductReq()
    }
    set {body = .checkProduct(newValue)}
  }

  /// 加载钱包
  public var loadWallet: OSLoadWalletReq {
    get {
      if case .loadWallet(let v)? = body {return v}
      return OSLoadWalletReq()
    }
    set {body = .loadWallet(newValue)}
  }

  /// 加载全部商品
  public var loadAllProducts: OSLoadAllProductsReq {
    get {
      if case .loadAllProducts(let v)? = body {return v}
      return OSLoadAllProductsReq()
    }
    set {body = .loadAllProducts(newValue)}
  }

  /// 加载背包的商品
  public var loadBagProducts: OSLoadBagProductsReq {
    get {
      if case .loadBagProducts(let v)? = body {return v}
      return OSLoadBagProductsReq()
    }
    set {body = .loadBagProducts(newValue)}
  }

  ///物品使用数据上报
  public var goodsUsing: OSGoodsUsingReportReq {
    get {
      if case .goodsUsing(let v)? = body {return v}
      return OSGoodsUsingReportReq()
    }
    set {body = .goodsUsing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 初始化商店数据
    case init_p(OSStoreInitReq)
    /// 购买装扮
    case purchaseProducts(OSPurchaseProductsReq)
    /// 佩戴装扮
    case wearProducts(OSWearProductsReq)
    ///给购物车检查下架商品
    case checkProduct(OSCheckProductReq)
    /// 加载钱包
    case loadWallet(OSLoadWalletReq)
    /// 加载全部商品
    case loadAllProducts(OSLoadAllProductsReq)
    /// 加载背包的商品
    case loadBagProducts(OSLoadBagProductsReq)
    ///物品使用数据上报
    case goodsUsing(OSGoodsUsingReportReq)

  }

  public init() {}
}

/// 响应体
public struct OSStoreResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: OSStoreResponse.OneOf_Body? = nil

  /// 初始化商店数据
  public var init_p: OSStoreInitRes {
    get {
      if case .init_p(let v)? = body {return v}
      return OSStoreInitRes()
    }
    set {body = .init_p(newValue)}
  }

  /// 购买装扮
  public var purchaseProducts: OSPurchaseProductsRes {
    get {
      if case .purchaseProducts(let v)? = body {return v}
      return OSPurchaseProductsRes()
    }
    set {body = .purchaseProducts(newValue)}
  }

  /// 佩戴装备
  public var wearProducts: OSWearProductsRes {
    get {
      if case .wearProducts(let v)? = body {return v}
      return OSWearProductsRes()
    }
    set {body = .wearProducts(newValue)}
  }

  ///给购物车检查下架商品
  public var checkProduct: OSCheckProductRes {
    get {
      if case .checkProduct(let v)? = body {return v}
      return OSCheckProductRes()
    }
    set {body = .checkProduct(newValue)}
  }

  /// 加载钱包
  public var loadWallet: OSLoadWalletRes {
    get {
      if case .loadWallet(let v)? = body {return v}
      return OSLoadWalletRes()
    }
    set {body = .loadWallet(newValue)}
  }

  /// 加载全部商品
  public var loadAllProducts: OSLoadAllProductsRes {
    get {
      if case .loadAllProducts(let v)? = body {return v}
      return OSLoadAllProductsRes()
    }
    set {body = .loadAllProducts(newValue)}
  }

  /// 加载背包的商品
  public var loadBagProducts: OSLoadBagProductsRes {
    get {
      if case .loadBagProducts(let v)? = body {return v}
      return OSLoadBagProductsRes()
    }
    set {body = .loadBagProducts(newValue)}
  }

  ///物品使用数据上报
  public var goodsUsing: OSGoodsUsingReportRes {
    get {
      if case .goodsUsing(let v)? = body {return v}
      return OSGoodsUsingReportRes()
    }
    set {body = .goodsUsing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Body: Equatable, Sendable {
    /// 初始化商店数据
    case init_p(OSStoreInitRes)
    /// 购买装扮
    case purchaseProducts(OSPurchaseProductsRes)
    /// 佩戴装备
    case wearProducts(OSWearProductsRes)
    ///给购物车检查下架商品
    case checkProduct(OSCheckProductRes)
    /// 加载钱包
    case loadWallet(OSLoadWalletRes)
    /// 加载全部商品
    case loadAllProducts(OSLoadAllProductsRes)
    /// 加载背包的商品
    case loadBagProducts(OSLoadBagProductsRes)
    ///物品使用数据上报
    case goodsUsing(OSGoodsUsingReportRes)

  }

  public init() {}
}

public struct OSStoreInitReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSProductCategory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var iconURL: String = String()

  public var type: OSProductType = .notset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSStoreCategory: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var name: String = String()

  public var iconURL: String = String()

  ///选中时icon
  public var iconSelected: String = String()

  public var type: OSStoreCategoryType = .storetypeNotSet

  public var subCategory: [OSStoreCategory] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSStoreInitRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var wallet: OSWallet {
    get {return _wallet ?? OSWallet()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  public var wearingProducts: [OSProduct] = []

  ///装扮商城目录
  public var dressStoreCategories: [OSStoreCategory] = []

  ///捏脸商城目录
  public var bodyStoreCategories: [OSStoreCategory] = []

  /// 在背包的捏脸类目
  public var bodyProductCategories: [OSProductCategory] = []

  /// 在背包的装扮类目
  public var dressProductCategories: [OSProductCategory] = []

  ///默认选中表情
  public var ownDefeaultExpressionProduct: OSProduct {
    get {return _ownDefeaultExpressionProduct ?? OSProduct()}
    set {_ownDefeaultExpressionProduct = newValue}
  }
  /// Returns true if `ownDefeaultExpressionProduct` has been explicitly set.
  public var hasOwnDefeaultExpressionProduct: Bool {return self._ownDefeaultExpressionProduct != nil}
  /// Clears the value of `ownDefeaultExpressionProduct`. Subsequent reads from it will return its default value.
  public mutating func clearOwnDefeaultExpressionProduct() {self._ownDefeaultExpressionProduct = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wallet: OSWallet? = nil
  fileprivate var _ownDefeaultExpressionProduct: OSProduct? = nil
}

public struct OSProduct: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: OSProductType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// 商品ID
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var iconURL: String {
    get {return _storage._iconURL}
    set {_uniqueStorage()._iconURL = newValue}
  }

  /// 单位：天。 用于表示持续天数，多个可选，0为永久。
  public var durations: [Int32] {
    get {return _storage._durations}
    set {_uniqueStorage()._durations = newValue}
  }

  /// 价格，单位：钻石，与durations对应
  public var durationPrices: [Int32] {
    get {return _storage._durationPrices}
    set {_uniqueStorage()._durationPrices = newValue}
  }

  public var tagName: String {
    get {return _storage._tagName}
    set {_uniqueStorage()._tagName = newValue}
  }

  public var own: OSOwnState {
    get {return _storage._own}
    set {_uniqueStorage()._own = newValue}
  }

  public var limitType: OSProductLimitType {
    get {return _storage._limitType}
    set {_uniqueStorage()._limitType = newValue}
  }

  /// 包含的装备
  public var equipmentIds: [UInt64] {
    get {return _storage._equipmentIds}
    set {_uniqueStorage()._equipmentIds = newValue}
  }

  /// 包含的动作表情
  public var expressionIds: [UInt64] {
    get {return _storage._expressionIds}
    set {_uniqueStorage()._expressionIds = newValue}
  }

  ///提示文本
  public var purchaseHint: String {
    get {return _storage._purchaseHint}
    set {_uniqueStorage()._purchaseHint = newValue}
  }

  public var cornerIcon: String {
    get {return _storage._cornerIcon}
    set {_uniqueStorage()._cornerIcon = newValue}
  }

  /// 以下属性用于背包或购物车
  public var backpackID: Int64 {
    get {return _storage._backpackID}
    set {_uniqueStorage()._backpackID = newValue}
  }

  public var count: Int32 {
    get {return _storage._count}
    set {_uniqueStorage()._count = newValue}
  }

  /// 所购买的天数，durations值中的一个
  public var duration: Int32 {
    get {return _storage._duration}
    set {_uniqueStorage()._duration = newValue}
  }

  /// 到期时间
  public var expireTimestamp: UInt64 {
    get {return _storage._expireTimestamp}
    set {_uniqueStorage()._expireTimestamp = newValue}
  }

  /// 更新时间
  public var updateTimestamp: UInt64 {
    get {return _storage._updateTimestamp}
    set {_uniqueStorage()._updateTimestamp = newValue}
  }

  /// 生效时间
  public var effectiveTimestamp: UInt64 {
    get {return _storage._effectiveTimestamp}
    set {_uniqueStorage()._effectiveTimestamp = newValue}
  }

  /// 在背包里面的分类，背包增加时使用
  public var categoryID: Int32 {
    get {return _storage._categoryID}
    set {_uniqueStorage()._categoryID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct OSLoadAllProductsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: OSPageReq {
    get {return _page ?? OSPageReq()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var categoryID: Int32 = 0

  public var subCategoryID: Int32 = 0

  public var character: OSCharacterType = .notset

  public var type: OSProductType = .notset

  public var ownState: OSOwnState = .notset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: OSPageReq? = nil
}

public struct OSLoadAllProductsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: OSPageRes {
    get {return _page ?? OSPageRes()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var items: [OSProduct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: OSPageRes? = nil
}

public struct OSGoodsUsingReportReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var productID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSGoodsUsingReportRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSLoadBagProductsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: OSPageReq {
    get {return _page ?? OSPageReq()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var categoryID: Int32 = 0

  public var character: OSCharacterType = .notset

  public var type: OSProductType = .notset

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: OSPageReq? = nil
}

public struct OSLoadBagProductsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var page: OSPageRes {
    get {return _page ?? OSPageRes()}
    set {_page = newValue}
  }
  /// Returns true if `page` has been explicitly set.
  public var hasPage: Bool {return self._page != nil}
  /// Clears the value of `page`. Subsequent reads from it will return its default value.
  public mutating func clearPage() {self._page = nil}

  public var items: [OSProduct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _page: OSPageRes? = nil
}

public struct OSPurchaseProductsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 填id, count, duration
  public var products: [OSProduct] = []

  /// 账号ID（赠送填写）
  public var accountID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSPurchaseProductsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var wallet: OSWallet {
    get {return _wallet ?? OSWallet()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  /// 更新的背包
  public var products: [OSProduct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wallet: OSWallet? = nil
}

public struct OSCheckProductReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var products: [OSProduct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSCheckProductRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSWearProductsReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///repeated int64 product_ids = 1;// 装备ID
  public var backpackIds: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSWearProductsRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var products: [OSProduct] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSLoadWalletReq: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct OSLoadWalletRes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var wallet: OSWallet {
    get {return _wallet ?? OSWallet()}
    set {_wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  public var hasWallet: Bool {return self._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  public mutating func clearWallet() {self._wallet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _wallet: OSWallet? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.mm.proto"

extension OSStoreCategoryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORETYPE_NotSet"),
    1: .same(proto: "STORETYPE_Dress"),
    3: .same(proto: "STORETYPE_Body"),
  ]
}

extension OSProductType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ProductType_NOTSET"),
    1: .same(proto: "ProductType_Equipment"),
    2: .same(proto: "ProductType_Expression"),
    3: .same(proto: "ProductType_Body"),
  ]
}

extension OSProductLimitType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ProductLimitType_NOTSET"),
    1: .same(proto: "ProductLimitType_FREE"),
    2: .same(proto: "ProductLimitType_GENERAL"),
    3: .same(proto: "ProductLimitType_LEVEL"),
    4: .same(proto: "ProductLimitType_NOBILITY"),
  ]
}

extension OSOwnState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OwnState_NOTSET"),
    2: .same(proto: "Unowned"),
    3: .same(proto: "Owned"),
  ]
}

extension OSStoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoreRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    5: .standard(proto: "purchase_products"),
    6: .standard(proto: "wear_products"),
    7: .standard(proto: "check_product"),
    8: .standard(proto: "load_wallet"),
    81: .standard(proto: "load_all_products"),
    82: .standard(proto: "load_bag_products"),
    90: .standard(proto: "goods_using"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSStoreInitReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .init_p(v)
        }
      }()
      case 5: try {
        var v: OSPurchaseProductsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .purchaseProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .purchaseProducts(v)
        }
      }()
      case 6: try {
        var v: OSWearProductsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wearProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wearProducts(v)
        }
      }()
      case 7: try {
        var v: OSCheckProductReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .checkProduct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .checkProduct(v)
        }
      }()
      case 8: try {
        var v: OSLoadWalletReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadWallet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadWallet(v)
        }
      }()
      case 81: try {
        var v: OSLoadAllProductsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadAllProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadAllProducts(v)
        }
      }()
      case 82: try {
        var v: OSLoadBagProductsReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadBagProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadBagProducts(v)
        }
      }()
      case 90: try {
        var v: OSGoodsUsingReportReq?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .goodsUsing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .goodsUsing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .init_p?: try {
      guard case .init_p(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .purchaseProducts?: try {
      guard case .purchaseProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .wearProducts?: try {
      guard case .wearProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .checkProduct?: try {
      guard case .checkProduct(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .loadWallet?: try {
      guard case .loadWallet(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .loadAllProducts?: try {
      guard case .loadAllProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
    }()
    case .loadBagProducts?: try {
      guard case .loadBagProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
    }()
    case .goodsUsing?: try {
      guard case .goodsUsing(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStoreRequest, rhs: OSStoreRequest) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoreResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    5: .standard(proto: "purchase_products"),
    6: .standard(proto: "wear_products"),
    7: .standard(proto: "check_product"),
    8: .standard(proto: "load_wallet"),
    81: .standard(proto: "load_all_products"),
    82: .standard(proto: "load_bag_products"),
    90: .standard(proto: "goods_using"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: OSStoreInitRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .init_p(v)
        }
      }()
      case 5: try {
        var v: OSPurchaseProductsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .purchaseProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .purchaseProducts(v)
        }
      }()
      case 6: try {
        var v: OSWearProductsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .wearProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .wearProducts(v)
        }
      }()
      case 7: try {
        var v: OSCheckProductRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .checkProduct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .checkProduct(v)
        }
      }()
      case 8: try {
        var v: OSLoadWalletRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadWallet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadWallet(v)
        }
      }()
      case 81: try {
        var v: OSLoadAllProductsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadAllProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadAllProducts(v)
        }
      }()
      case 82: try {
        var v: OSLoadBagProductsRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .loadBagProducts(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .loadBagProducts(v)
        }
      }()
      case 90: try {
        var v: OSGoodsUsingReportRes?
        var hadOneofValue = false
        if let current = self.body {
          hadOneofValue = true
          if case .goodsUsing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.body = .goodsUsing(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.body {
    case .init_p?: try {
      guard case .init_p(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .purchaseProducts?: try {
      guard case .purchaseProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .wearProducts?: try {
      guard case .wearProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .checkProduct?: try {
      guard case .checkProduct(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .loadWallet?: try {
      guard case .loadWallet(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .loadAllProducts?: try {
      guard case .loadAllProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
    }()
    case .loadBagProducts?: try {
      guard case .loadBagProducts(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
    }()
    case .goodsUsing?: try {
      guard case .goodsUsing(let v)? = self.body else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStoreResponse, rhs: OSStoreResponse) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStoreInitReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoreInitReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStoreInitReq, rhs: OSStoreInitReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSProductCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductCategory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "icon_url"),
    5: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 3)
    }
    if self.type != .notset {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSProductCategory, rhs: OSProductCategory) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStoreCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoreCategory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "icon_url"),
    4: .standard(proto: "icon_selected"),
    5: .same(proto: "type"),
    6: .standard(proto: "sub_category"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.iconSelected) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.subCategory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 3)
    }
    if !self.iconSelected.isEmpty {
      try visitor.visitSingularStringField(value: self.iconSelected, fieldNumber: 4)
    }
    if self.type != .storetypeNotSet {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if !self.subCategory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subCategory, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStoreCategory, rhs: OSStoreCategory) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.iconSelected != rhs.iconSelected {return false}
    if lhs.type != rhs.type {return false}
    if lhs.subCategory != rhs.subCategory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSStoreInitRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StoreInitRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wallet"),
    4: .standard(proto: "wearing_products"),
    6: .standard(proto: "dress_store_categories"),
    7: .standard(proto: "body_store_categories"),
    8: .standard(proto: "body_product_categories"),
    9: .standard(proto: "dress_product_categories"),
    10: .standard(proto: "own_defeaultExpression_product"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.wearingProducts) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.dressStoreCategories) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.bodyStoreCategories) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.bodyProductCategories) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.dressProductCategories) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._ownDefeaultExpressionProduct) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.wearingProducts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.wearingProducts, fieldNumber: 4)
    }
    if !self.dressStoreCategories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dressStoreCategories, fieldNumber: 6)
    }
    if !self.bodyStoreCategories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyStoreCategories, fieldNumber: 7)
    }
    if !self.bodyProductCategories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyProductCategories, fieldNumber: 8)
    }
    if !self.dressProductCategories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dressProductCategories, fieldNumber: 9)
    }
    try { if let v = self._ownDefeaultExpressionProduct {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSStoreInitRes, rhs: OSStoreInitRes) -> Bool {
    if lhs._wallet != rhs._wallet {return false}
    if lhs.wearingProducts != rhs.wearingProducts {return false}
    if lhs.dressStoreCategories != rhs.dressStoreCategories {return false}
    if lhs.bodyStoreCategories != rhs.bodyStoreCategories {return false}
    if lhs.bodyProductCategories != rhs.bodyProductCategories {return false}
    if lhs.dressProductCategories != rhs.dressProductCategories {return false}
    if lhs._ownDefeaultExpressionProduct != rhs._ownDefeaultExpressionProduct {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSProduct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Product"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .same(proto: "name"),
    4: .standard(proto: "icon_url"),
    5: .same(proto: "durations"),
    6: .standard(proto: "duration_prices"),
    7: .standard(proto: "tag_name"),
    8: .same(proto: "own"),
    9: .standard(proto: "limit_type"),
    10: .standard(proto: "equipment_ids"),
    11: .standard(proto: "expression_ids"),
    12: .standard(proto: "purchase_hint"),
    13: .standard(proto: "corner_icon"),
    29: .standard(proto: "backpack_id"),
    30: .same(proto: "count"),
    31: .same(proto: "duration"),
    32: .standard(proto: "expire_timestamp"),
    33: .standard(proto: "update_timestamp"),
    34: .standard(proto: "effective_timestamp"),
    40: .standard(proto: "category_id"),
  ]

  fileprivate class _StorageClass {
    var _type: OSProductType = .notset
    var _id: Int64 = 0
    var _name: String = String()
    var _iconURL: String = String()
    var _durations: [Int32] = []
    var _durationPrices: [Int32] = []
    var _tagName: String = String()
    var _own: OSOwnState = .notset
    var _limitType: OSProductLimitType = .notset
    var _equipmentIds: [UInt64] = []
    var _expressionIds: [UInt64] = []
    var _purchaseHint: String = String()
    var _cornerIcon: String = String()
    var _backpackID: Int64 = 0
    var _count: Int32 = 0
    var _duration: Int32 = 0
    var _expireTimestamp: UInt64 = 0
    var _updateTimestamp: UInt64 = 0
    var _effectiveTimestamp: UInt64 = 0
    var _categoryID: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _id = source._id
      _name = source._name
      _iconURL = source._iconURL
      _durations = source._durations
      _durationPrices = source._durationPrices
      _tagName = source._tagName
      _own = source._own
      _limitType = source._limitType
      _equipmentIds = source._equipmentIds
      _expressionIds = source._expressionIds
      _purchaseHint = source._purchaseHint
      _cornerIcon = source._cornerIcon
      _backpackID = source._backpackID
      _count = source._count
      _duration = source._duration
      _expireTimestamp = source._expireTimestamp
      _updateTimestamp = source._updateTimestamp
      _effectiveTimestamp = source._effectiveTimestamp
      _categoryID = source._categoryID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._iconURL) }()
        case 5: try { try decoder.decodeRepeatedInt32Field(value: &_storage._durations) }()
        case 6: try { try decoder.decodeRepeatedInt32Field(value: &_storage._durationPrices) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._tagName) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._own) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._limitType) }()
        case 10: try { try decoder.decodeRepeatedFixed64Field(value: &_storage._equipmentIds) }()
        case 11: try { try decoder.decodeRepeatedFixed64Field(value: &_storage._expressionIds) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._purchaseHint) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._cornerIcon) }()
        case 29: try { try decoder.decodeSingularInt64Field(value: &_storage._backpackID) }()
        case 30: try { try decoder.decodeSingularInt32Field(value: &_storage._count) }()
        case 31: try { try decoder.decodeSingularInt32Field(value: &_storage._duration) }()
        case 32: try { try decoder.decodeSingularFixed64Field(value: &_storage._expireTimestamp) }()
        case 33: try { try decoder.decodeSingularFixed64Field(value: &_storage._updateTimestamp) }()
        case 34: try { try decoder.decodeSingularFixed64Field(value: &_storage._effectiveTimestamp) }()
        case 40: try { try decoder.decodeSingularInt32Field(value: &_storage._categoryID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .notset {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._iconURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._iconURL, fieldNumber: 4)
      }
      if !_storage._durations.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._durations, fieldNumber: 5)
      }
      if !_storage._durationPrices.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._durationPrices, fieldNumber: 6)
      }
      if !_storage._tagName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tagName, fieldNumber: 7)
      }
      if _storage._own != .notset {
        try visitor.visitSingularEnumField(value: _storage._own, fieldNumber: 8)
      }
      if _storage._limitType != .notset {
        try visitor.visitSingularEnumField(value: _storage._limitType, fieldNumber: 9)
      }
      if !_storage._equipmentIds.isEmpty {
        try visitor.visitPackedFixed64Field(value: _storage._equipmentIds, fieldNumber: 10)
      }
      if !_storage._expressionIds.isEmpty {
        try visitor.visitPackedFixed64Field(value: _storage._expressionIds, fieldNumber: 11)
      }
      if !_storage._purchaseHint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._purchaseHint, fieldNumber: 12)
      }
      if !_storage._cornerIcon.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cornerIcon, fieldNumber: 13)
      }
      if _storage._backpackID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._backpackID, fieldNumber: 29)
      }
      if _storage._count != 0 {
        try visitor.visitSingularInt32Field(value: _storage._count, fieldNumber: 30)
      }
      if _storage._duration != 0 {
        try visitor.visitSingularInt32Field(value: _storage._duration, fieldNumber: 31)
      }
      if _storage._expireTimestamp != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._expireTimestamp, fieldNumber: 32)
      }
      if _storage._updateTimestamp != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._updateTimestamp, fieldNumber: 33)
      }
      if _storage._effectiveTimestamp != 0 {
        try visitor.visitSingularFixed64Field(value: _storage._effectiveTimestamp, fieldNumber: 34)
      }
      if _storage._categoryID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._categoryID, fieldNumber: 40)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSProduct, rhs: OSProduct) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._iconURL != rhs_storage._iconURL {return false}
        if _storage._durations != rhs_storage._durations {return false}
        if _storage._durationPrices != rhs_storage._durationPrices {return false}
        if _storage._tagName != rhs_storage._tagName {return false}
        if _storage._own != rhs_storage._own {return false}
        if _storage._limitType != rhs_storage._limitType {return false}
        if _storage._equipmentIds != rhs_storage._equipmentIds {return false}
        if _storage._expressionIds != rhs_storage._expressionIds {return false}
        if _storage._purchaseHint != rhs_storage._purchaseHint {return false}
        if _storage._cornerIcon != rhs_storage._cornerIcon {return false}
        if _storage._backpackID != rhs_storage._backpackID {return false}
        if _storage._count != rhs_storage._count {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._expireTimestamp != rhs_storage._expireTimestamp {return false}
        if _storage._updateTimestamp != rhs_storage._updateTimestamp {return false}
        if _storage._effectiveTimestamp != rhs_storage._effectiveTimestamp {return false}
        if _storage._categoryID != rhs_storage._categoryID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadAllProductsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadAllProductsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .standard(proto: "category_id"),
    3: .standard(proto: "sub_category_id"),
    4: .same(proto: "character"),
    5: .same(proto: "type"),
    6: .standard(proto: "own_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.categoryID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.subCategoryID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.character) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.ownState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.categoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryID, fieldNumber: 2)
    }
    if self.subCategoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.subCategoryID, fieldNumber: 3)
    }
    if self.character != .notset {
      try visitor.visitSingularEnumField(value: self.character, fieldNumber: 4)
    }
    if self.type != .notset {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if self.ownState != .notset {
      try visitor.visitSingularEnumField(value: self.ownState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadAllProductsReq, rhs: OSLoadAllProductsReq) -> Bool {
    if lhs._page != rhs._page {return false}
    if lhs.categoryID != rhs.categoryID {return false}
    if lhs.subCategoryID != rhs.subCategoryID {return false}
    if lhs.character != rhs.character {return false}
    if lhs.type != rhs.type {return false}
    if lhs.ownState != rhs.ownState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadAllProductsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadAllProductsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadAllProductsRes, rhs: OSLoadAllProductsRes) -> Bool {
    if lhs._page != rhs._page {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGoodsUsingReportReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoodsUsingReportReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "product_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.productID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.productID != 0 {
      try visitor.visitSingularInt64Field(value: self.productID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGoodsUsingReportReq, rhs: OSGoodsUsingReportReq) -> Bool {
    if lhs.productID != rhs.productID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSGoodsUsingReportRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoodsUsingReportRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSGoodsUsingReportRes, rhs: OSGoodsUsingReportRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadBagProductsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadBagProductsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .standard(proto: "category_id"),
    3: .same(proto: "character"),
    5: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.categoryID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.character) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.categoryID != 0 {
      try visitor.visitSingularInt32Field(value: self.categoryID, fieldNumber: 2)
    }
    if self.character != .notset {
      try visitor.visitSingularEnumField(value: self.character, fieldNumber: 3)
    }
    if self.type != .notset {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadBagProductsReq, rhs: OSLoadBagProductsReq) -> Bool {
    if lhs._page != rhs._page {return false}
    if lhs.categoryID != rhs.categoryID {return false}
    if lhs.character != rhs.character {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadBagProductsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadBagProductsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "page"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._page) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._page {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadBagProductsRes, rhs: OSLoadBagProductsRes) -> Bool {
    if lhs._page != rhs._page {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPurchaseProductsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurchaseProductsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "products"),
    3: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 1)
    }
    if self.accountID != 0 {
      try visitor.visitSingularInt32Field(value: self.accountID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPurchaseProductsReq, rhs: OSPurchaseProductsReq) -> Bool {
    if lhs.products != rhs.products {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSPurchaseProductsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PurchaseProductsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wallet"),
    2: .same(proto: "products"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSPurchaseProductsRes, rhs: OSPurchaseProductsRes) -> Bool {
    if lhs._wallet != rhs._wallet {return false}
    if lhs.products != rhs.products {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCheckProductReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckProductReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "products"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCheckProductReq, rhs: OSCheckProductReq) -> Bool {
    if lhs.products != rhs.products {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSCheckProductRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckProductRes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSCheckProductRes, rhs: OSCheckProductRes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWearProductsReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WearProductsReq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "backpack_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.backpackIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.backpackIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.backpackIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWearProductsReq, rhs: OSWearProductsReq) -> Bool {
    if lhs.backpackIds != rhs.backpackIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSWearProductsRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WearProductsRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "products"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSWearProductsRes, rhs: OSWearProductsRes) -> Bool {
    if lhs.products != rhs.products {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadWalletReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadWalletReq"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadWalletReq, rhs: OSLoadWalletReq) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OSLoadWalletRes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadWalletRes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wallet"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._wallet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wallet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: OSLoadWalletRes, rhs: OSLoadWalletRes) -> Bool {
    if lhs._wallet != rhs._wallet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
